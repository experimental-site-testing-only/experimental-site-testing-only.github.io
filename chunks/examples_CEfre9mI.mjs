const id = "Language Overview/examples.md";
						const collection = "docs";
						const slug = "language-overview/examples";
						const body = "## Overview\nThis is meant for a quick reference, to the learn more of the details, check the relevant sections.\n\n## If Statement\n```c3\nfn void if_example(int a)\n{\n    if (a > 0)\n    {\n        // ..\n    }\n    else\n    {\n        // ..\n    }\n}\n```\n\n## For Loop\n```c3\nfn void example_for()\n{\n    // the for-loop is the same as C99.\n    for (int i = 0; i < 10; i++)\n    {\n        io::printfn(\"%d\", i);\n    }\n\n    // also equal\n    for (;;)\n    {\n        // ..\n    }\n}\n```\n\n## Foreach Loop\n```c3\n// Prints the values in the slice.\nfn void example_foreach(float[] values)\n{\n    foreach (index, value : values)\n    {\n        io::printfn(\"%d: %f\", index, value);\n    }\n}\n\n// Updates each value in the slice\n// by multiplying it by 2.\nfn void example_foreach_by_ref(float[] values)\n{\n    foreach (&value : values)\n    {\n        *value *= 2;\n    }\n}\n```\n\n## While Loop\n\n```c3\nfn void example_while()\n{\n    // again exactly the same as C\n    int a = 10;\n    while (a > 0)\n    {\n        a--;\n    }\n\n    // Declaration\n    while (Point* p = getPoint())\n    {\n        // ..\n    }\n}\n```\n\n## Enum And Switch\n\nSwitches have implicit break and scope. Use \"nextcase\" to implicitly fallthrough or use comma:\n\n```c3\nenum Height : uint\n{\n    LOW,\n    MEDIUM,\n    HIGH,\n}\n\nfn void demo_enum(Height h)\n{\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case HIGH:\n            io::printn(\"High\");\n    }\n\n    // This also works\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case Height.HIGH:\n            io::printn(\"High\");\n    }\n\n    // Completely empty cases are not allowed.\n    switch (h)\n    {\n        case LOW:\n            break; // Explicit break required, since switches can't be empty.\n        case MEDIUM:\n            io::printn(\"Medium\");\n        case HIGH:\n            break;\n    }\n\n    // special checking of switching on enum types\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n        case HIGH:\n            break;\n        default:    // warning: default label in switch which covers all enumeration value\n            break;\n    }\n\n    // Using \"nextcase\" will fallthrough to the next case statement,\n    // and each case statement starts its own scope.\n    switch (h)\n    {\n        case LOW:\n            int a = 1;\n            io::printn(\"A\");\n            nextcase;\n        case MEDIUM:\n            int a = 2;\n            io::printn(\"B\");\n            nextcase;\n        case HIGH:\n            // a is not defined here\n            io::printn(\"C\");\n    }\n}\n```\n\n\nEnums are always namespaced.\n\nEnum support various reflection properties: `.values` returns an array with all enums. `.len` or `.elements` returns the number\nof enum values, `.inner` returns the storage type. `.names` returns an array with the names of all enums. `.associated`\nreturns an array of the typeids of the associated values for the enum.\n\n```c3\nenum State : uint\n{\n    START,\n    STOP,\n}\n\nState start = State.values[0];\nusz enums = State.elements;   // 2\nString[] names = State.names; // [ \"START\", \"STOP\" ]\n```\n\n## Defer\n\nDefer will be invoked on scope exit.\n\n```c3\nfn void test(int x)\n{\n    defer io::printn();\n    defer io::print(\"A\");\n    if (x == 1) return;\n    {\n        defer io::print(\"B\");\n        if (x == 0) return;\n    }\n    io::print(\"!\");\n}\n\nfn void main()\n{\n    test(1); // Prints \"A\"\n    test(0); // Prints \"BA\"\n    test(10); // Prints \"B!A\"\n}\n```\n\nBecause it's often relevant to run different defers when having an error return there is also a way to create an error defer, by using the `catch` keyword directly after the defer.\nSimilarly using `defer try` can be used to only run if the scope exits in a regular way.\n\n```c3\nfn void? test(int x)\n{\n    defer io::printn(\"\");\n    defer io::print(\"A\");\n    defer try io::print(\"X\");\n    defer catch io::print(\"B\");\n    defer (catch err) io::printf(\"%s\", err);\n    if (x == 1) return SearchResult.MISSING?;\n    io::print(\"!\");\n}\n\ntest(0); // Prints \"!XA\"\ntest(1); // Prints \"MISSINGBA\" and returns a FooError\n```\n\n## Struct Types\n\n```c3\nalias Callback = fn int(char c);\n\nenum Status : int\n{\n    IDLE,\n    BUSY,\n    DONE,\n}\n\nstruct MyData\n{\n    char* name;\n    Callback open;\n    Callback close;\n    State status;\n\n    // named sub-structs (x.other.value)\n    struct other\n    {\n        int value;\n        int status;   // ok, no name clash with other status\n    }\n\n    // anonymous sub-structs (x.value)\n    struct\n    {\n        int value;\n        int status;   // error, name clash with other status in MyData\n    }\n\n    // anonymous union (x.person)\n    union\n    {\n        Person* person;\n        Company* company;\n    }\n\n    // named sub-unions (x.either.this)\n    union either\n    {\n        int this;\n        bool  or;\n        char* that;\n    }\n}\n```\n\n\n## Function Pointers\n\n```c3\nmodule demo;\n\nalias Callback = fn int(char* text, int value);\n\nfn int my_callback(char* text, int value)\n{\n    return 0;\n}\n\nCallback cb = &my_callback;\n\nfn void example_cb()\n{\n    int result = cb(\"demo\", 123);\n    // ..\n}\n```\n\n## Error Handling\n\nErrors are handled using optional results, denoted with a '?' suffix. A variable of an optional\nresult type may either contain the regular value or a `fault` enum value.\n\n```c3\nfault DIVISION_BY_ZERO;\n\nfn double? divide(int a, int b)\n{\n    // We return an optional result of type DIVISION_BY_ZERO\n    // when b is zero.\n    if (b == 0) return DIVISION_BY_ZERO?;\n    return (double)a / (double)b;\n}\n\n// Re-returning an optional result uses \"?\" suffix\nfn void? testMayError()\n{\n    divide(foo(), bar())!;\n}\n\nfn void main()\n{\n    // ratio is an optional result.\n    double? ratio = divide(foo(), bar());\n\n    // Handle the optional result value if it exists.\n    if (catch err = ratio)\n    {\n        case DIVISION_BY_ZERO:\n            io::printn(\"Division by zero\");\n            return;\n        default:\n            io::printn(\"Unexpected error!\");\n            return;\n    }\n    // Flow typing makes \"ratio\"\n    // have the plain type 'double' here.\n    io::printfn(\"Ratio was %f\", ratio);\n}\n```\n\n```c3\nfn void print_file(String filename)\n{\n    String? file = io::load_file(filename);\n\n    // The following function is not called on error,\n    // so we must explicitly discard it with a void cast.\n    (void)io::printfn(\"Loaded %s and got:%s\", filename, file);\n\n    if (catch err = file)\n    {\n        case io::FILE_NOT_FOUND:\n            io::printfn(\"I could not find the file %s\", filename);\n        default:\n            io::printfn(\"Could not load %s.\", filename);\n    }\n}\n\n// Note that the above is only illustrating how Optionals may skip\n// call invocation. A more normal implementation would be:\n\nfn void print_file2(String filename)\n{\n    String? file = io::load_file(filename);\n\n    if (catch err = file)\n    {\n        // Print the error\n        io::printfn(\"Failed to load %s: %s\", filename, err);\n        // We return, so that below 'file' will be unwrapped.\n        return;\n    }\n    // No need for a void cast here, 'file' is unwrappeed to 'String'.\n    io::printfn(\"Loaded %s and got:\\n%s\", filename, file);\n}\n```\n\n\n\nRead more about optionals and error handling [here](/language-common/optionals-essential/#what-is-an-optional).\n\n## Contracts\n\nPre- and postconditions are optionally compiled into asserts helping to optimize the code.\n```c3\n<*\n @param foo \"the number of foos\"\n @require foo > 0, foo < 1000\n @return \"number of foos x 10\"\n @ensure return < 10000, return > 0\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n\n<*\n @param array \"the array to test\"\n @param length \"length of the array\"\n @require length > 0\n*>\nfn int getLastElement(int* array, int length)\n{\n    return array[length - 1];\n}\n```\n\nRead more about contracts [here](/language-common/contracts/).\n\n## Struct Methods\n\nIt's possible to namespace functions with a union, struct or enum type to enable \"dot syntax\" calls:\n\n```c3\nstruct Foo\n{\n    int i;\n}\n\nfn void Foo.next(Foo* this)\n{\n    if (this) this.i++;\n}\n\nfn void test()\n{\n    Foo foo = { 2 };\n    foo.next();\n    foo.next();\n    // Prints 4\n    io::printfn(\"%d\", foo.i);\n}\n```\n\n\n## Macros\n\nMacro arguments may be immediately evaluated.\n```c3\nmacro foo(a, b)\n{\n    return a(b);\n}\n\nfn int square(int x)\n{\n    return x * x;\n}\n\nfn int test()\n{\n    int a = 2;\n    int b = 3;\n    return foo(&square, 2) + a + b; // 9\n    // return foo(square, 2) + a + b;\n    // Error the symbol \"square\" cannot be used as an argument.\n}\n```\n\nMacro arguments may have deferred evaluation, which is basically text expansion using `#var` syntax.\n\n```c3\nmacro @foo(#a, b, #c)\n{\n    c = a(b) * b;\n}\n\nmacro @foo2(#a)\n{\n    return a * a;\n}\n\nfn int square(int x)\n{\n    return x * x;\n}\n\nfn int test1()\n{\n    int a = 2;\n    int b = 3;\n    @foo(square, a + 1, b);\n    return b; // 27\n}\n\nfn int test2()\n{\n    return @foo2(1 + 1); // 1 + 1 * 1 + 1 = 3\n}\n```\n\nImprove macro errors with preconditions:\n```c3\n<*\n @param x \"value to square\"\n @require types::is_numeric($typeof(x)) \"cannot multiply\"\n*>\nmacro square(x)\n{\n    return x * x;\n}\n\nfn void test()\n{\n    square(\"hello\"); // Error: cannot multiply \"hello\"\n    int a = 1;\n    square(&a); // Error: cannot multiply '&a'\n}\n```\n\nRead more about macros [here](/generic-programming/macros/).\n\n\n### Compile Time Reflection & Execution\n\nAccess type information and loop over values at compile time:\n\n```c3\nimport std::io;\n\nstruct Foo\n{\n    int a;\n    double b;\n    int* ptr;\n}\n\nmacro print_fields($Type)\n{\n    $foreach $field : $Type.membersof:\n        io::printfn(\"Field %s, offset: %s, size: %s, type: %s\",\n                $field.nameof, $field.offsetof, $field.sizeof, $field.typeid.nameof);\n    $endforeach\n}\n\n\nfn void main()\n{\n    print_fields(Foo);\n}\n```\n\nThis prints on x64:\n\n```text\nField a, offset: 0, size: 4, type: int\nField b, offset: 8, size: 8, type: double\nField ptr, offset: 16, size: 8, type: int*\n```\n\n### Compile Time Execution\n\nMacros with only compile time variables are completely evaluated at compile time:\n\n```c3\nmacro long fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return fib($n - 1) + fib($n - 2);\n    $endif\n}\n\nconst long FIB19 = fib(19);\n// Same as const long FIB19 = 4181;\n```\n:::note\nC3 macros are designed to provide a replacement for C preprocessor macros. They extend such macros by providing compile time evaluation using constant folding, which offers an IDE friendly, limited, compile time execution.\n\nHowever, if you are doing more complex compile time code generation it is recommended to use `$exec` and related techniques to generate code in external scripts instead.\n:::\nRead more about compile time execution [here](/generic-programming/compiletime/).\n\n## Generic Modules\n\nGeneric modules implements a generic system.\n\n```c3\nmodule stac{ Type };\nstruct Stack\n{\n    usz capacity;\n    usz size;\n    Type* elems;\n}\n\n\nfn void Stack.push(Stack* this, Type element)\n{\n    if (this.capacity == this.size)\n    {\n        this.capacity = this.capacity ? this.capacity * 2 : 16;\n        this.elems = realloc(this.elems, Type.sizeof * this.capacity);\n    }\n    this.elems[this.size++] = element;\n}\n\nfn Type Stack.pop(Stack* this)\n{\n    assert(this.size > 0);\n    return this.elems[--this.size];\n}\n\nfn bool Stack.empty(Stack* this)\n{\n    return !this.size;\n}\n```\n\nTesting it out:\n\n```c3\nalias IntStack = Stack{ int };\n\nfn void test()\n{\n    IntStack stack;\n    stack.push(1);\n    stack.push(2);\n    // Prints pop: 2\n    io::printfn(\"pop: %d\", stack.pop());\n    // Prints pop: 1\n    io::printfn(\"pop: %d\", stack.pop());\n\n    Stack{ double } dstack;\n    dstack.push(2.3);\n    dstack.push(3.141);\n    dstack.push(1.1235);\n    // Prints pop: 1.1235\n    io::printfn(\"pop: %f\", dstack.pop());\n}\n```\n\nRead more about generic modules [here](/generic-programming/generics/)\n\n## Dynamic Calls\n\nRuntime dynamic dispatch through interfaces:\n\n```c3\nimport std::io;\n\n// Define a dynamic interface\ninterface MyName\n{\n    fn String myname();\n}\n\nstruct Bob (MyName) { int x; }\n\n// Required implementation as Bob implements MyName\nfn String Bob.myname(Bob*) @dynamic { return \"I am Bob!\"; }\n\n// Ad hoc implementation\nfn String int.myname(int*) @dynamic { return \"I am int!\"; }\n\nfn void whoareyou(any a)\n{\n    MyName b = (MyName)a;\n    if (!&b.myname)\n    {\n        io::printn(\"I don't know who I am.\");\n        return;\n    }\n    io::printn(b.myname());\n}\n\nfn void main()\n{\n    int i = 1;\n    double d = 1.0;\n    Bob bob;\n\n    any a = &i;\n    whoareyou(a);\n    a = &d;\n    whoareyou(a);\n    a = &bob;\n    whoareyou(a);\n}\n```\n\nRead more about dynamic calls [here](/generic-programming/anyinterfaces/).\n";
						const data = {title:"Examples",description:"Examples of C3 code",editUrl:true,head:[],template:"doc",sidebar:{order:35,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Overview/examples.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
