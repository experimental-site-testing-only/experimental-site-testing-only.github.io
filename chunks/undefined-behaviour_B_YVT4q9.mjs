const id = "Language Rules/undefined-behaviour.md";
						const collection = "docs";
						const slug = "language-rules/undefined-behaviour";
						const body = "\nLike C, C3 uses undefined behaviour. In contrast, C3 will *trap* - that is, print an error trace and abort â€“ on undefined behaviour in debug builds. This is similar to using C with a UB sanitizer. It is only during release builds that actual undefined behaviour occurs.\n\nIn C3, undefined behaviour means that the compiler is free to interpret *undefined behaviour as if behaviour cannot occur*.\n\nIn the example below:\n\n```c3\nuint x = foo();\nuint z = 255 / x;\nreturn x != 0;\n```\n\nThe case of `x == 0` would invoke undefined behaviour for `255/x`. For that reason, \nthe compiler may assume that `x != 0` and compile it into the following code: \n\n```c3\nfoo();\nreturn true;\n```\n\nAs a contrast, the safe build will compile code equivalent to the following.\n\n```c3\nuint x = foo();\nif (x == 0) trap(\"Division by zero\")\nreturn true;\n```\n\n## List of undefined behaviours\n\nThe following operations cause undefined behaviour in release builds of C3:\n\n| operation | will trap in safe builds |\n| --------- | :----------------------: |\n| int / 0 | Yes |\n| int % 0 | Yes |\n| reading explicitly uninitialized memory | Possible\\* |\n| array index out of bounds | Yes |\n| dereference `null` | Yes |\n| dereferencing memory not allocated | Possible\\* |\n| dereferencing memory outside of its lifetime | Possible\\* |\n| casting pointer to the incorrect array | Possible\\* |\n| violating pre or post conditions | Yes |\n| violating asserts | Yes |\n| reaching `unreachable()` code | Yes |\n\n\\* \"Possible\" indicates trapping is implementation dependent.\n\n## List of implementation dependent behaviours\n\nSome behaviour is allowed to differ between implementations and platforms.\n\n| operation | will trap in safe builds | permitted behaviour |\n| --------- | :----------------------: | :----------------: |\n| comparing pointers of different provenance | Optional | Any result |\n| subtracting pointers of different provenance | Optional | Any result |\n| shifting by more or equal to the bit width | Yes | Any result |\n| shifting by negative amount | Yes | Any result |\n| conversion floating point <-> integer type is out of range | Optional | Any result |\n| conversion between pointer types produces one with incorrect alignment | Optional | Any result / Error  |\n| calling a function through a function pointer that does not match the function | Optional | Any result / Error |\n| attempt to modify a string literal | Optional | Partial modification / Error |\n| modifying a `const` variable | Optional | Partial modification / Error |\n\n## List of undefined behaviour in C, which is defined in C3\n\n### Signed Integer Overflow\n\nSigned integer is always wrapped using 2s complement.\n\n### Modifying the intermediate results of an expression\n\nBehaves as if the intermediate result was stored in a variable on the stack.\n";
						const data = {title:"Undefined Behaviour",description:"Undefined Behaviour",editUrl:true,head:[],template:"doc",sidebar:{order:212,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Rules/undefined-behaviour.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
