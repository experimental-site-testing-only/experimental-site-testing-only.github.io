const id = "Previous Versions/v0_6_8/Generic Programming/compiletime.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/generic-programming/compiletime";
						const body = "During compilation, constant expressions will automatically be folded. Together with the compile\ntime conditional statements `$if`, `$switch` and the compile time iteration statements `$for` `$foreach`\nit is possible to perform limited compile time execution.\n\n### Compile time values\n\nDuring compilation, global constants are considered compile time values, as are any \nderived constant values, such as type names and sizes, variable alignments etc.\n\nInside of a macro or a function, it is possible to define mutable compile time variables. Such\nlocal variables are prefixed with `$` (e.g. `$foo`). It is also possible to define local *type* variables,\nthat are also prefixed using `$` (e.g. `$MyType` `$ParamType`).\n\nMutable compile time variables are *not* allowed in the global scope.\n\n### `$if` and `$switch`\n\n`$if <const expr>:` takes a compile time constant value and evaluates it to true or false.\n\n```c3\nmacro @foo($x, #y)\n{\n    $if $x > 3:\n        #y += $x * $x;\n    $else\n        #y += $x;\n    $endif\n}\n\nconst int FOO = 10;\n\nfn void test()\n{\n    int a = 5;\n    int b = 4;\n    @foo(1, a); // Allowed, expands to a += 1;\n    // @foo(b, a); // Error: b is not a compile time constant.\n    @foo(FOO, a); // Allowed, expands to a += FOO * FOO;\n}\n```\n\nFor switching between multiple possibilities, use `$switch`.\n\n```c3\nmacro @foo($x, #y)\n{\n    $switch ($x)\n        $case 1: \n            #y += $x * $x;\n        $case 2:\n            #y += $x;\n        $case 3:\n            #y *= $x;\n        $default:\n            #y -= $x;\n    $endswitch\n}\n```\n\nSwitching without argument is also allowed, which works like an if-else chain:\n\n```c3\nmacro @foo($x, #y)\n{\n    $switch \n        $case $x > 10: \n            #y += $x * $x;\n        $case $x < 0:\n            #y += $x;\n        $default:\n            #y -= $x;\n    $endswitch\n}\n```\n\n### Loops using `$foreach` and `$for`\n\n`$for` ... `$endfor` works analogous to `for`, only it is limited to using compile time variables. `$foreach` ... `$endforeach` similarly \nmatches the behaviour of `foreach`.\n\nCompile time looping:\n\n```c3\nmacro foo($a)\n{\n    $for (var $x = 0; $x < $a; $x++)\n        io::printfn(\"%d\", $x);     \n    $endfor\n}\n\nfn void test()\n{\n    foo(2);\n    // Expands to ->\n    // io::printfn(\"%d\", 0);     \n    // io::printfn(\"%d\", 1);         \n}\n```\n\nLooping over enums:\n\n```c3\nmacro foo_enum($SomeEnum)\n{\n    $foreach ($x : $SomeEnum.values)\n        io::printfn(\"%d\", (int)$x);     \n    $endforeach\n}\n\nenum MyEnum\n{\n    A,\n    B,\n}\n\nfn void test()\n{\n    foo_enum(MyEnum);\n    // Expands to ->\n    // io::printfn(\"%d\", (int)MyEnum.A);\n    // io::printfn(\"%d\", (int)MyEnum.B);    \n}\n```\n\n:::note\nThe content of the `$foreach` or `$for` body must be at least a complete statement.\nIt's not possible to compile partial statements.\n:::\n\n### Compile time macro execution\n\nIf a macro only takes compile time parameters, that is only `$`-prefixed parameters, and then does not generate \nany other statements than returns, then the macro will be completely compile time executed.\n\n```c3\nmacro @test($abc)\n{\n    return $abc * 2;\n}\n\nconst int MY_CONST = @test(2); // Will fold to \"4\"\n```\n\nThis constant evaluation allows us to write some limited compile time code. For example, this\nmacro will compute Fibonacci at compile time:\n\n```c3\nmacro long @fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return @fib($n - 1) + @fib($n - 2);\n    $endif\n}\n```\n\nIt is important to remember that if we had replaced `$n` with `n` the compiler would have complained. `n <= 1` \nis not be considered to be a constant expression, even if the actual argument to the macro was a constant.\nThis limitation is deliberate, to offer control over what is compiled out and what isn't.\n\n### Conditional compilation at the top level using `@if`\n\nAt the top level, conditional compilation is controlled using with `@if` attributes on declarations\n\n```c3\nfn void foo_win32() @if(env::WIN32)\n{\n    /* .... */\n}\n\nstruct Foo\n{\n    int a;\n    int b @if(env::NO_LIBC);\n}\n```\n\nThe argument to `@if` must be possible to resolve to a constant at compile time. This means that argument\nmay also be a compile time evaluated macro:\n\n```c3\nmacro bool @foo($x) => $x > 2;\n\nint x @if(@foo(5)); // Will be included\nint y @if(@foo(0)); // Will not be included\n```\n\n#### Evaluation order of top level conditional compilation\n\nConditional compilation at the top level can cause unexpected ordering issues, especially when combined with \n`$defined`. At a high level, there are three phases of evaluation:\n\n1. Non-conditional declarations are registered.\n2. Conditional module sections are either discarded or have all of their non-conditional declarations registered.\n3. Each module in turn will evaluate `@if` attributes for each module section. \n\nThe order of module and module section evaluation in (2) and (3) is not deterministic and any use of `$defined` should not \nrely on this ordering.\n\n## Compile time introspection\n\nAt compile time, full type information is available. This allows for creation of reusable, code generating macros for things\nlike serialization.\n\n```c3    \nusz foo_alignment = Foo.alignof;\nusz foo_member_count = Foo.membersof.len;\nString foo_name = Foo.nameof; \n```\n\nTo read more about all the fields available at compile time, see the page on [reflection](/generic-programming/reflection).\n\n## Compile time functions\n\nA set of compile time functions are available at compile time:\n\n### `$alignof`\n\nGet the alignment of something. See [reflection](/generic-programming/reflection).\n\n### `$append`\n\nAppend a compile time constant to a compile time array or untyped list.\n\n### `$assert`\n\nCheck a condition at compile time.\n\n### `$assignable`\n\nCheck if an expression is assignable to the given type, e.g. `Type x = expr;` would be valid.\n\n### `$defined`\n\nReturns true if a type or identifier is defined. See [reflection](/generic-programming/reflection).\n\n### `$echo`\n\nPrint a message to stdout when compiling the code.\n\n### `$embed`\n\nEmbed binary data from a file. See [expressions](/language-fundamentals/expressions/).\n\n### `$error`\n\nWhen this is compiled, issue a compile time error.\n\n### `$eval`\n\nConverts a compile time string to the corresponding variable or function. See [reflection](/generic-programming/reflection).\n\n### `$evaltype`\n\nConverts a compile time string to the corresponding type. See [reflection](/generic-programming/reflection).\n\n### `$exec`\n\nExecute a script at compile time and include the result in the source code.\n\n### `$extnameof`, `$qnameof` and `$nameof`\n\nGet the external name of a symbol. See [reflection](/generic-programming/reflection).\n\n### `$feature`\n\nCheck if a given feature is enabled.\n\n### `$is_const`\n\nCheck if the expression is constant at compile time.\n\n### `$nameof`\n\nGet the local name of a symbol. See [reflection](/generic-programming/reflection).\n\n### `$offsetof`\n\nGet the offset of a member. See [reflection](/generic-programming/reflection).\n\n### `$qnameof`\n\nGet the qualified name of a symbol. See [reflection](/generic-programming/reflection).\n\n### `$vacount`\n\nReturn the number of macro vaarg arguments\n\n### `$vaconst`\n\nReturn a vaarg as a `$constant` parameter.\n\n### `$vaexpr`\n\nReturn a vaarg as an `#expr` parameter.\n\n### `$vasplat`\n\nExpand the vaargs in an initializer list or function call.\n\n### `$vatype`\n\nGet a vaarg as a `$Type` parameter.\n\n### `$sizeof`\n\nReturn the size of an expression.\n\n### `$stringify`\n\nTurn an expression into a string.\n\n### `$typeof`\n\nGet the type of an expression (without evaluating it).\n\n### `$typefrom`\n\nGet a type from a compile time constant `typeid`.\n";
						const data = {title:"Compile Time Evaluation",description:"Compile time introspection and execution",editUrl:true,head:[],template:"doc",sidebar:{order:84,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
