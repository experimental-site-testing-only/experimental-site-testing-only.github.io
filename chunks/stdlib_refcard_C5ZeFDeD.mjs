const id = "Standard Library/stdlib_refcard.md";
						const collection = "docs";
						const slug = "standard-library/stdlib_refcard";
						const body = "### `libc`\n```c3\ntypedef Errno = inline CInt;\n```\n```c3\nstruct DivResult\n```\n```c3\nstruct LongDivResult\n```\n```c3\nstruct TimeSpec\n```\n```c3\nstruct Timespec\n```\n```c3\nstruct Tm\n```\n```c3\nfn TimeSpec Duration.to_timespec(self) @inline\n```\n```c3\nfn TimeSpec NanoDuration.to_timespec(self) @inline\n```\n```c3\nfn Errno errno()\n```\n```c3\nfn void errno_set(Errno e)\n```\n### `libc @if(!env::LIBC)`\n```c3\nfn void* calloc(usz count, usz size) @weak @extern(\"calloc\") @nostrip\n```\n```c3\nfn CFile fclose(CFile) @weak @extern(\"fclose\") @nostrip\n```\n```c3\nfn int feof(CFile stream) @weak @extern(\"feof\") @nostrip\n```\n```c3\nfn int fflush(CFile stream) @weak @extern(\"fflush\") @nostrip\n```\n```c3\nfn int fgetc(CFile stream) @weak @extern(\"fgetc\") @nostrip\n```\n```c3\nfn char* fgets(ZString str, int n, CFile stream) @weak @extern(\"fgets\") @nostrip\n```\n```c3\nfn CFile fopen(ZString filename, ZString mode) @weak @extern(\"fopen\") @nostrip\n```\n```c3\nfn int fputc(int c, CFile stream) @weak @extern(\"fputc\") @nostrip\n```\n```c3\nfn usz fread(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(\"fread\") @nostrip\n```\n```c3\nfn void* free(void*) @weak @extern(\"free\")\n```\n```c3\nfn CFile freopen(ZString filename, ZString mode, CFile stream) @weak @extern(\"fopen\") @nostrip\n```\n```c3\nfn int fseek(CFile stream, SeekIndex offset, int whence) @weak @extern(\"fseek\") @nostrip\n```\n```c3\nfn usz fwrite(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(\"fwrite\") @nostrip\n```\n```c3\nfn void longjmp(JmpBuf* buffer, CInt value) @weak @extern(\"longjmp\") @nostrip\n```\n```c3\nfn void* malloc(usz size) @weak @extern(\"malloc\") @nostrip\n```\n```c3\nfn void* memcpy(void* dest, void* src, usz n) @weak @extern(\"memcpy\") @nostrip\n```\n```c3\nfn void* memmove(void* dest, void* src, usz n) @weak @extern(\"memmove\") @nostrip\n```\n```c3\nfn void* memset(void* dest, CInt value, usz n) @weak @extern(\"memset\") @nostrip\n```\n```c3\nfn int putc(int c, CFile stream) @weak @extern(\"putc\") @nostrip\n```\n```c3\nfn int putchar(int c) @weak @extern(\"putchar\") @nostrip\n```\n```c3\nfn int puts(ZString str) @weak @extern(\"puts\") @nostrip\n```\n```c3\nfn void* realloc(void* ptr, usz size) @weak @extern(\"realloc\") @nostrip\n```\n```c3\nfn CInt setjmp(JmpBuf* buffer) @weak @extern(\"setjmp\") @nostrip\n```\n### `libc @if(env::DARWIN)`\n```c3\nstruct Stat\n```\n```c3\nmacro CFile stderr()\n```\n```c3\nmacro CFile stdin()\n```\n```c3\nmacro CFile stdout()\n```\n### `libc @if(env::LIBC &amp;&amp; !env::WIN32 &amp;&amp; !env::LINUX &amp;&amp; !env::DARWIN)`\n```c3\nmacro CFile stderr() { return (CFile*)(uptr)STDERR_FD; }\n```\n```c3\nmacro CFile stdin() { return (CFile*)(uptr)STDIN_FD; }\n```\n```c3\nmacro CFile stdout() { return (CFile*)(uptr)STDOUT_FD; }\n```\n### `libc @if(env::LINUX)`\n```c3\nstruct Stat @if(!env::X86_64)\n```\n```c3\nstruct Stat @if(env::X86_64)\n```\n```c3\nmacro usz malloc_size(void* ptr)\n```\n```c3\nmacro CFile stderr()\n```\n```c3\nmacro CFile stdin()\n```\n```c3\nmacro CFile stdout()\n```\n### `libc @if(env::POSIX)`\n```c3\nstruct Sigaction\n```\n```c3\nstruct Stack_t\n```\n### `libc @if(env::WIN32)`\n```c3\nstruct SystemInfo\n```\n```c3\nmacro Tm* gmtime_r(Time_t* timer, Tm* buf)\n```\n```c3\nmacro Tm* localtime_r(Time_t* timer, Tm* buf)\n```\n```c3\nmacro usz malloc_size(void* ptr)\n```\n```c3\nmacro isz read(Fd fd, void* buffer, usz buffer_size)\n```\n```c3\nmacro CInt setjmp(JmpBuf* buffer)\n```\n```c3\nmacro CFile stderr()\n```\n```c3\nmacro CFile stdin()\n```\n```c3\nmacro CFile stdout()\n```\n```c3\nmacro isz write(Fd fd, void* buffer, usz count)\n```\n### `libc::os`\n```c3\nfn int errno() @if(ERRNO_DEFAULT)\n```\n```c3\nmacro int errno() @if(env::DARWIN)\n```\n```c3\nmacro int errno() @if(env::LINUX)\n```\n```c3\nmacro int errno() @if(env::WIN32)\n```\n```c3\nfn void errno_set(int err) @if(ERRNO_DEFAULT)\n```\n```c3\nmacro void errno_set(int err) @if(env::DARWIN)\n```\n```c3\nmacro void errno_set(int err) @if(env::LINUX)\n```\n```c3\nmacro void errno_set(int err) @if(env::WIN32)\n```\n### `std::ascii`\n```c3\nfn char char.from_hex(char c)\n```\n```c3\nfn bool char.in_range(char c, char start, char len)\n```\n```c3\nfn bool char.is_alnum(char c)\n```\n```c3\nfn bool char.is_alpha(char c)\n```\n```c3\nfn bool char.is_bdigit(char c)\n```\n```c3\nfn bool char.is_blank(char c)\n```\n```c3\nfn bool char.is_cntrl(char c)\n```\n```c3\nfn bool char.is_digit(char c)\n```\n```c3\nfn bool char.is_graph(char c)\n```\n```c3\nfn bool char.is_lower(char c)\n```\n```c3\nfn bool char.is_odigit(char c)\n```\n```c3\nfn bool char.is_print(char c)\n```\n```c3\nfn bool char.is_punct(char c)\n```\n```c3\nfn bool char.is_space(char c)\n```\n```c3\nfn bool char.is_upper(char c)\n```\n```c3\nfn bool char.is_xdigit(char c)\n```\n```c3\nfn char char.to_lower(char c)\n```\n```c3\nfn char char.to_upper(char c)\n```\n```c3\nfn bool in_range(char c, char start, char len)\n```\n```c3\nmacro bool in_range_m(c, start, len)\n```\n```c3\nfn bool is_alnum(char c)\n```\n```c3\nmacro bool is_alnum_m(c)\n```\n```c3\nfn bool is_alpha(char c)\n```\n```c3\nmacro bool is_alpha_m(c)\n```\n```c3\nfn bool is_bdigit(char c)\n```\n```c3\nmacro bool is_bdigit_m(c)\n```\n```c3\nfn bool is_blank(char c)\n```\n```c3\nmacro bool is_blank_m(c)\n```\n```c3\nfn bool is_cntrl(char c)\n```\n```c3\nmacro bool is_cntrl_m(c)\n```\n```c3\nfn bool is_digit(char c)\n```\n```c3\nmacro bool is_digit_m(c)\n```\n```c3\nfn bool is_graph(char c)\n```\n```c3\nmacro bool is_graph_m(c)\n```\n```c3\nfn bool is_lower(char c)\n```\n```c3\nmacro bool is_lower_m(c)\n```\n```c3\nfn bool is_odigit(char c)\n```\n```c3\nmacro bool is_odigit_m(c)\n```\n```c3\nfn bool is_print(char c)\n```\n```c3\nmacro bool is_print_m(c)\n```\n```c3\nfn bool is_punct(char c)\n```\n```c3\nmacro bool is_punct_m(c)\n```\n```c3\nfn bool is_space(char c)\n```\n```c3\nmacro bool is_space_m(c)\n```\n```c3\nfn bool is_upper(char c)\n```\n```c3\nmacro bool is_upper_m(c)\n```\n```c3\nfn bool is_xdigit(char c)\n```\n```c3\nmacro bool is_xdigit_m(c)\n```\n```c3\nfn char to_lower(char c)\n```\n```c3\nmacro to_lower_m(c)\n```\n```c3\nfn char to_upper(char c)\n```\n```c3\nmacro to_upper_m(c)\n```\n```c3\nfn bool uint.in_range(uint c, uint start, uint len)\n```\n```c3\nfn bool uint.is_alnum(uint c)\n```\n```c3\nfn bool uint.is_alpha(uint c)\n```\n```c3\nfn bool uint.is_bdigit(uint c)\n```\n```c3\nfn bool uint.is_blank(uint c)\n```\n```c3\nfn bool uint.is_cntrl(uint c)\n```\n```c3\nfn bool uint.is_digit(uint c)\n```\n```c3\nfn bool uint.is_graph(uint c)\n```\n```c3\nfn bool uint.is_lower(uint c)\n```\n```c3\nfn bool uint.is_odigit(uint c)\n```\n```c3\nfn bool uint.is_print(uint c)\n```\n```c3\nfn bool uint.is_punct(uint c)\n```\n```c3\nfn bool uint.is_space(uint c)\n```\n```c3\nfn bool uint.is_upper(uint c)\n```\n```c3\nfn bool uint.is_xdigit(uint c)\n```\n```c3\nfn uint uint.to_lower(uint c)\n```\n```c3\nfn uint uint.to_upper(uint c)\n```\n### `std::atomic`\n```c3\nmacro @__atomic_compare_exchange_ordering_failure(ptr, expected, desired, $success, failure, $alignment)\n```\n```c3\nmacro @__atomic_compare_exchange_ordering_success(ptr, expected, desired, success, failure, $alignment)\n```\n```c3\nfn CInt __atomic_compare_exchange(CInt size, any ptr, any expected, any desired, CInt success, CInt failure) @extern(\"__atomic_compare_exchange\") @export\n```\n```c3\nmacro fetch_add(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_and(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_div(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro fetch_max(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_min(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_mul(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro fetch_or(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_shift_left(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro fetch_shift_right(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro fetch_sub(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro fetch_xor(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n```c3\nmacro flag_clear(ptr, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro flag_set(ptr, AtomicOrdering $ordering = SEQ_CONSISTENT)\n```\n### `std::atomic::types(&lt;Type&gt;)`\n```c3\nstruct Atomic\n```\n```c3\nmacro Type Atomic.add(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.and(&self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))\n```\n```c3\nmacro Type Atomic.div(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.load(&self, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.max(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.min(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.mul(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.or(&self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))\n```\n```c3\nmacro Type Atomic.shift_left(&self, uint amount, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))\n```\n```c3\nmacro Type Atomic.shift_right(&self, uint amount, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))\n```\n```c3\nmacro void Atomic.store(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nmacro Type Atomic.sub(&self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)\n```\n```c3\nfn Type Atomic.xor(&self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))\n```\n### `std::bits`\n```c3\nmacro bswap(i) @builtin\n```\n```c3\nmacro char.clz(self)\n```\n```c3\nmacro char.ctz(self)\n```\n```c3\nmacro char char.fshl(hi, char lo, char shift)\n```\n```c3\nmacro char char.fshr(hi, char lo, char shift)\n```\n```c3\nmacro char.popcount(self)\n```\n```c3\nmacro char char.rotl(self, char shift)\n```\n```c3\nmacro char char.rotr(self, char shift)\n```\n```c3\nmacro char[<*>].clz(self)\n```\n```c3\nmacro char[<*>].ctz(self)\n```\n```c3\nmacro char[<*>] char[<*>].fshl(hi, char[<*>] lo, char[<*>] shift)\n```\n```c3\nmacro char[<*>] char[<*>].fshr(hi, char[<*>] lo, char[<*>] shift)\n```\n```c3\nmacro char[<*>].popcount(self)\n```\n```c3\nmacro char[<*>] char[<*>].rotl(self, char[<*>] shift)\n```\n```c3\nmacro char[<*>] char[<*>].rotr(self, char[<*>] shift)\n```\n```c3\nmacro ichar.clz(self)\n```\n```c3\nmacro ichar.ctz(self)\n```\n```c3\nmacro ichar ichar.fshl(hi, ichar lo, ichar shift)\n```\n```c3\nmacro ichar ichar.fshr(hi, ichar lo, ichar shift)\n```\n```c3\nmacro ichar.popcount(self)\n```\n```c3\nmacro ichar ichar.rotl(self, ichar shift)\n```\n```c3\nmacro ichar ichar.rotr(self, ichar shift)\n```\n```c3\nmacro ichar[<*>].clz(self)\n```\n```c3\nmacro ichar[<*>].ctz(self)\n```\n```c3\nmacro ichar[<*>] ichar[<*>].fshl(hi, ichar[<*>] lo, ichar[<*>] shift)\n```\n```c3\nmacro ichar[<*>] ichar[<*>].fshr(hi, ichar[<*>] lo, ichar[<*>] shift)\n```\n```c3\nmacro ichar[<*>].popcount(self)\n```\n```c3\nmacro ichar[<*>] ichar[<*>].rotl(self, ichar[<*>] shift)\n```\n```c3\nmacro ichar[<*>] ichar[<*>].rotr(self, ichar[<*>] shift)\n```\n```c3\nmacro int.clz(self)\n```\n```c3\nmacro int.ctz(self)\n```\n```c3\nmacro int int.fshl(hi, int lo, int shift)\n```\n```c3\nmacro int int.fshr(hi, int lo, int shift)\n```\n```c3\nmacro int.popcount(self)\n```\n```c3\nmacro int int.rotl(self, int shift)\n```\n```c3\nmacro int int.rotr(self, int shift)\n```\n```c3\nmacro int128.clz(self)\n```\n```c3\nmacro int128.ctz(self)\n```\n```c3\nmacro int128 int128.fshl(hi, int128 lo, int128 shift)\n```\n```c3\nmacro int128 int128.fshr(hi, int128 lo, int128 shift)\n```\n```c3\nmacro int128.popcount(self)\n```\n```c3\nmacro int128 int128.rotl(self, int128 shift)\n```\n```c3\nmacro int128 int128.rotr(self, int128 shift)\n```\n```c3\nmacro int128[<*>].clz(self)\n```\n```c3\nmacro int128[<*>].ctz(self)\n```\n```c3\nmacro int128[<*>] int128[<*>].fshl(hi, int128[<*>] lo, int128[<*>] shift)\n```\n```c3\nmacro int128[<*>] int128[<*>].fshr(hi, int128[<*>] lo, int128[<*>] shift)\n```\n```c3\nmacro int128[<*>].popcount(self)\n```\n```c3\nmacro int128[<*>] int128[<*>].rotl(self, int128[<*>] shift)\n```\n```c3\nmacro int128[<*>] int128[<*>].rotr(self, int128[<*>] shift)\n```\n```c3\nmacro int[<*>].clz(self)\n```\n```c3\nmacro int[<*>].ctz(self)\n```\n```c3\nmacro int[<*>] int[<*>].fshl(hi, int[<*>] lo, int[<*>] shift)\n```\n```c3\nmacro int[<*>] int[<*>].fshr(hi, int[<*>] lo, int[<*>] shift)\n```\n```c3\nmacro int[<*>].popcount(self)\n```\n```c3\nmacro int[<*>] int[<*>].rotl(self, int[<*>] shift)\n```\n```c3\nmacro int[<*>] int[<*>].rotr(self, int[<*>] shift)\n```\n```c3\nmacro long.clz(self)\n```\n```c3\nmacro long.ctz(self)\n```\n```c3\nmacro long long.fshl(hi, long lo, long shift)\n```\n```c3\nmacro long long.fshr(hi, long lo, long shift)\n```\n```c3\nmacro long.popcount(self)\n```\n```c3\nmacro long long.rotl(self, long shift)\n```\n```c3\nmacro long long.rotr(self, long shift)\n```\n```c3\nmacro long[<*>].clz(self)\n```\n```c3\nmacro long[<*>].ctz(self)\n```\n```c3\nmacro long[<*>] long[<*>].fshl(hi, long[<*>] lo, long[<*>] shift)\n```\n```c3\nmacro long[<*>] long[<*>].fshr(hi, long[<*>] lo, long[<*>] shift)\n```\n```c3\nmacro long[<*>].popcount(self)\n```\n```c3\nmacro long[<*>] long[<*>].rotl(self, long[<*>] shift)\n```\n```c3\nmacro long[<*>] long[<*>].rotr(self, long[<*>] shift)\n```\n```c3\nmacro reverse(i)\n```\n```c3\nmacro short.clz(self)\n```\n```c3\nmacro short.ctz(self)\n```\n```c3\nmacro short short.fshl(hi, short lo, short shift)\n```\n```c3\nmacro short short.fshr(hi, short lo, short shift)\n```\n```c3\nmacro short.popcount(self)\n```\n```c3\nmacro short short.rotl(self, short shift)\n```\n```c3\nmacro short short.rotr(self, short shift)\n```\n```c3\nmacro short[<*>].clz(self)\n```\n```c3\nmacro short[<*>].ctz(self)\n```\n```c3\nmacro short[<*>] short[<*>].fshl(hi, short[<*>] lo, short[<*>] shift)\n```\n```c3\nmacro short[<*>] short[<*>].fshr(hi, short[<*>] lo, short[<*>] shift)\n```\n```c3\nmacro short[<*>].popcount(self)\n```\n```c3\nmacro short[<*>] short[<*>].rotl(self, short[<*>] shift)\n```\n```c3\nmacro short[<*>] short[<*>].rotr(self, short[<*>] shift)\n```\n```c3\nmacro uint.clz(self)\n```\n```c3\nmacro uint.ctz(self)\n```\n```c3\nmacro uint uint.fshl(hi, uint lo, uint shift)\n```\n```c3\nmacro uint uint.fshr(hi, uint lo, uint shift)\n```\n```c3\nmacro uint.popcount(self)\n```\n```c3\nmacro uint uint.rotl(self, uint shift)\n```\n```c3\nmacro uint uint.rotr(self, uint shift)\n```\n```c3\nmacro uint128.clz(self)\n```\n```c3\nmacro uint128.ctz(self)\n```\n```c3\nmacro uint128 uint128.fshl(hi, uint128 lo, uint128 shift)\n```\n```c3\nmacro uint128 uint128.fshr(hi, uint128 lo, uint128 shift)\n```\n```c3\nmacro uint128.popcount(self)\n```\n```c3\nmacro uint128 uint128.rotl(self, uint128 shift)\n```\n```c3\nmacro uint128 uint128.rotr(self, uint128 shift)\n```\n```c3\nmacro uint128[<*>].clz(self)\n```\n```c3\nmacro uint128[<*>].ctz(self)\n```\n```c3\nmacro uint128[<*>] uint128[<*>].fshl(hi, uint128[<*>] lo, uint128[<*>] shift)\n```\n```c3\nmacro uint128[<*>] uint128[<*>].fshr(hi, uint128[<*>] lo, uint128[<*>] shift)\n```\n```c3\nmacro uint128[<*>].popcount(self)\n```\n```c3\nmacro uint128[<*>] uint128[<*>].rotl(self, uint128[<*>] shift)\n```\n```c3\nmacro uint128[<*>] uint128[<*>].rotr(self, uint128[<*>] shift)\n```\n```c3\nmacro uint[<*>].clz(self)\n```\n```c3\nmacro uint[<*>].ctz(self)\n```\n```c3\nmacro uint[<*>] uint[<*>].fshl(hi, uint[<*>] lo, uint[<*>] shift)\n```\n```c3\nmacro uint[<*>] uint[<*>].fshr(hi, uint[<*>] lo, uint[<*>] shift)\n```\n```c3\nmacro uint[<*>].popcount(self)\n```\n```c3\nmacro uint[<*>] uint[<*>].rotl(self, uint[<*>] shift)\n```\n```c3\nmacro uint[<*>] uint[<*>].rotr(self, uint[<*>] shift)\n```\n```c3\nmacro ulong.clz(self)\n```\n```c3\nmacro ulong.ctz(self)\n```\n```c3\nmacro ulong ulong.fshl(hi, ulong lo, ulong shift)\n```\n```c3\nmacro ulong ulong.fshr(hi, ulong lo, ulong shift)\n```\n```c3\nmacro ulong.popcount(self)\n```\n```c3\nmacro ulong ulong.rotl(self, ulong shift)\n```\n```c3\nmacro ulong ulong.rotr(self, ulong shift)\n```\n```c3\nmacro ulong[<*>].clz(self)\n```\n```c3\nmacro ulong[<*>].ctz(self)\n```\n```c3\nmacro ulong[<*>] ulong[<*>].fshl(hi, ulong[<*>] lo, ulong[<*>] shift)\n```\n```c3\nmacro ulong[<*>] ulong[<*>].fshr(hi, ulong[<*>] lo, ulong[<*>] shift)\n```\n```c3\nmacro ulong[<*>].popcount(self)\n```\n```c3\nmacro ulong[<*>] ulong[<*>].rotl(self, ulong[<*>] shift)\n```\n```c3\nmacro ulong[<*>] ulong[<*>].rotr(self, ulong[<*>] shift)\n```\n```c3\nmacro ushort.clz(self)\n```\n```c3\nmacro ushort.ctz(self)\n```\n```c3\nmacro ushort ushort.fshl(hi, ushort lo, ushort shift)\n```\n```c3\nmacro ushort ushort.fshr(hi, ushort lo, ushort shift)\n```\n```c3\nmacro ushort.popcount(self)\n```\n```c3\nmacro ushort ushort.rotl(self, ushort shift)\n```\n```c3\nmacro ushort ushort.rotr(self, ushort shift)\n```\n```c3\nmacro ushort[<*>].clz(self)\n```\n```c3\nmacro ushort[<*>].ctz(self)\n```\n```c3\nmacro ushort[<*>] ushort[<*>].fshl(hi, ushort[<*>] lo, ushort[<*>] shift)\n```\n```c3\nmacro ushort[<*>] ushort[<*>].fshr(hi, ushort[<*>] lo, ushort[<*>] shift)\n```\n```c3\nmacro ushort[<*>].popcount(self)\n```\n```c3\nmacro ushort[<*>] ushort[<*>].rotl(self, ushort[<*>] shift)\n```\n```c3\nmacro ushort[<*>] ushort[<*>].rotr(self, ushort[<*>] shift)\n```\n### `std::collections::anylist`\n```c3\nstruct AnyList (Printable)\n```\n```c3\nmacro any AnyList.@item_at(&self, usz index) @operator([])\n```\n```c3\nfn void AnyList.add_all(&self, AnyList* other_list)\n```\n```c3\nfn any[] AnyList.array_view(&self)\n```\n```c3\nfn void AnyList.clear(&self)\n```\n```c3\nmacro AnyList.first(&self, $Type)\n```\n```c3\nfn any? AnyList.first_any(&self) @inline\n```\n```c3\nfn void AnyList.free(&self)\n```\n```c3\nfn void AnyList.free_element(&self, any element) @inline\n```\n```c3\nmacro AnyList.get(&self, usz index, $Type)\n```\n```c3\nfn any AnyList.get_any(&self, usz index) @inline\n```\n```c3\nfn bool AnyList.is_empty(&self) @inline\n```\n```c3\nmacro AnyList.last(&self, $Type)\n```\n```c3\nfn any? AnyList.last_any(&self) @inline\n```\n```c3\nfn usz AnyList.len(&self) @operator(len) @inline\n```\n```c3\nfn AnyList* AnyList.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n```c3\nfn any? AnyList.new_pop(&self, Allocator allocator = allocator::heap())\n```\n```c3\nfn any? AnyList.new_pop_first(&self, Allocator allocator = allocator::heap())\n```\n```c3\nmacro AnyList.pop(&self, $Type)\n```\n```c3\nmacro AnyList.pop_first(&self, $Type)\n```\n```c3\nfn any? AnyList.pop_first_retained(&self)\n```\n```c3\nfn any? AnyList.pop_retained(&self)\n```\n```c3\nmacro void AnyList.push(&self, element)\n```\n```c3\nmacro void AnyList.push_front(&self, type)\n```\n```c3\nfn void AnyList.remove_at(&self, usz index)\n```\n```c3\nfn void AnyList.remove_first(&self)\n```\n```c3\nfn usz AnyList.remove_if(&self, AnyPredicate filter)\n```\n```c3\nfn void AnyList.remove_last(&self)\n```\n```c3\nfn usz AnyList.remove_using_test(&self, AnyTest filter, any context)\n```\n```c3\nfn void AnyList.reserve(&self, usz min_capacity)\n```\n```c3\nfn usz AnyList.retain_if(&self, AnyPredicate selection)\n```\n```c3\nfn usz AnyList.retain_using_test(&self, AnyTest filter, any context)\n```\n```c3\nfn void AnyList.reverse(&self)\n```\n```c3\nmacro void AnyList.set(&self, usz index, value)\n```\n```c3\nfn void AnyList.swap(&self, usz i, usz j)\n```\n```c3\nfn AnyList* AnyList.temp_init(&self, usz initial_capacity = 16)\n```\n```c3\nfn any? AnyList.temp_pop(&self)\n```\n```c3\nfn any? AnyList.temp_pop_first(&self)\n```\n```c3\nfn usz? AnyList.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String AnyList.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String AnyList.to_tstring(&self)\n```\n### `std::collections::bitset(&lt;SIZE&gt;)`\n```c3\nstruct BitSet\n```\n```c3\nfn usz BitSet.cardinality(&self)\n```\n```c3\nfn bool BitSet.get(&self, usz i) @operator([]) @inline\n```\n```c3\nfn usz BitSet.len(&self) @operator(len) @inline\n```\n```c3\nfn void BitSet.set(&self, usz i)\n```\n```c3\nfn void BitSet.set_bool(&self, usz i, bool value) @operator([]=) @inline\n```\n```c3\nfn void BitSet.unset(&self, usz i)\n```\n### `std::collections::enummap(&lt;Enum, ValueType&gt;)`\n```c3\nstruct EnumMap (Printable)\n```\n```c3\nfn ValueType EnumMap.get(&self, Enum key) @operator([]) @inline\n```\n```c3\nfn ValueType* EnumMap.get_ref(&self, Enum key) @operator(&[]) @inline\n```\n```c3\nfn void EnumMap.init(&self, ValueType init_value)\n```\n```c3\nfn usz EnumMap.len(&self) @operator(len) @inline\n```\n```c3\nfn void EnumMap.set(&self, Enum key, ValueType value) @operator([]=) @inline\n```\n```c3\nfn usz? EnumMap.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String EnumMap.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String EnumMap.to_tstring(&self) @dynamic\n```\n### `std::collections::enumset(&lt;Enum&gt;)`\n```c3\ntypedef EnumSet (Printable) = EnumSetType;\n```\n```c3\nfn void EnumSet.add(&self, Enum v)\n```\n```c3\nfn void EnumSet.add_all(&self, EnumSet s)\n```\n```c3\nfn EnumSet EnumSet.and_of(&self, EnumSet s)\n```\n```c3\nfn void EnumSet.clear(&self)\n```\n```c3\nfn EnumSet EnumSet.diff_of(&self, EnumSet s)\n```\n```c3\nfn bool EnumSet.has(&self, Enum v)\n```\n```c3\nfn EnumSet EnumSet.or_of(&self, EnumSet s)\n```\n```c3\nfn bool EnumSet.remove(&self, Enum v)\n```\n```c3\nfn void EnumSet.remove_all(&self, EnumSet s)\n```\n```c3\nfn void EnumSet.retain_all(&self, EnumSet s)\n```\n```c3\nfn usz? EnumSet.to_format(&set, Formatter* formatter) @dynamic\n```\n```c3\nfn String EnumSet.to_new_string(&set, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String EnumSet.to_tstring(&set) @dynamic\n```\n```c3\nfn EnumSet EnumSet.xor_of(&self, EnumSet s)\n```\n### `std::collections::enumset::private`\n```c3\nmacro typeid type_for_enum_elements(usz $elements)\n```\n### `std::collections::growablebitset(&lt;Type&gt;)`\n```c3\nstruct GrowableBitSet\n```\n```c3\nfn usz GrowableBitSet.cardinality(&self)\n```\n```c3\nfn void GrowableBitSet.free(&self)\n```\n```c3\nfn bool GrowableBitSet.get(&self, usz i) @operator([]) @inline\n```\n```c3\nfn usz GrowableBitSet.len(&self) @operator(len)\n```\n```c3\nfn GrowableBitSet* GrowableBitSet.new_init(&self, usz initial_capacity = 1, Allocator allocator = allocator::heap())\n```\n```c3\nfn void GrowableBitSet.set(&self, usz i)\n```\n```c3\nfn void GrowableBitSet.set_bool(&self, usz i, bool value) @operator([]=) @inline\n```\n```c3\nfn GrowableBitSet* GrowableBitSet.temp_init(&self, usz initial_capacity = 1)\n```\n```c3\nfn void GrowableBitSet.unset(&self, usz i)\n```\n### `std::collections::linkedlist(&lt;Type&gt;)`\n```c3\nstruct LinkedList\n```\n```c3\nfn void LinkedList.clear(&self)\n```\n```c3\nfn Type? LinkedList.first(&self)\n```\n```c3\nfn void LinkedList.free(&self)\n```\n```c3\nfn Type LinkedList.get(&self, usz index)\n```\n```c3\nfn void LinkedList.insert_at(&self, usz index, Type element)\n```\n```c3\nfn Type? LinkedList.last(&self)\n```\n```c3\nfn usz LinkedList.len(&self) @inline\n```\n```c3\nfn LinkedList* LinkedList.new_init(&self, Allocator allocator = allocator::heap())\n```\n```c3\nmacro Node* LinkedList.node_at_index(&self, usz index)\n```\n```c3\nfn Type? LinkedList.peek(&self)\n```\n```c3\nfn Type? LinkedList.peek_last(&self)\n```\n```c3\nfn Type? LinkedList.pop(&self)\n```\n```c3\nfn Type? LinkedList.pop_front(&self)\n```\n```c3\nfn void LinkedList.push(&self, Type value)\n```\n```c3\nfn void LinkedList.push_front(&self, Type value)\n```\n```c3\nfn usz LinkedList.remove(&self, Type t) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void LinkedList.remove_at(&self, usz index)\n```\n```c3\nfn void? LinkedList.remove_first(&self) @maydiscard\n```\n```c3\nfn bool LinkedList.remove_first_match(&self, Type t) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void? LinkedList.remove_last(&self) @maydiscard\n```\n```c3\nfn bool LinkedList.remove_last_match(&self, Type t)  @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void LinkedList.set(&self, usz index, Type element)\n```\n```c3\nfn LinkedList* LinkedList.temp_init(&self)\n```\n### `std::collections::list(&lt;Type&gt;)`\n```c3\nstruct List (Printable)\n```\n```c3\nmacro Type List.@item_at(&self, usz index) @operator([])\n```\n```c3\nfn void List.add_all(&self, List* other_list)\n```\n```c3\nfn void List.add_array(&self, Type[] array)\n```\n```c3\nfn Type[] List.array_view(&self)\n```\n```c3\nfn usz List.byte_size(&self) @inline\n```\n```c3\nfn void List.clear(&self)\n```\n```c3\nfn usz List.compact(&self) @if(ELEMENT_IS_POINTER)\n```\n```c3\nfn usz List.compact_count(&self) @if(ELEMENT_IS_POINTER)\n```\n```c3\nfn bool List.contains(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn bool List.equals(&self, List other_list) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn Type? List.first(&self)\n```\n```c3\nfn void List.free(&self)\n```\n```c3\nfn Type List.get(&self, usz index) @inline\n```\n```c3\nfn Type* List.get_ref(&self, usz index) @operator(&[]) @inline\n```\n```c3\nfn usz? List.index_of(&self, Type type) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void List.init_wrapping_array(&self, Type[] types, Allocator allocator = allocator::heap())\n```\n```c3\nfn void List.insert_at(&self, usz index, Type type)\n```\n```c3\nfn bool List.is_empty(&self) @inline\n```\n```c3\nfn Type? List.last(&self)\n```\n```c3\nfn usz List.len(&self) @operator(len) @inline\n```\n```c3\nfn List* List.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n```c3\nfn Type? List.pop(&self)\n```\n```c3\nfn Type? List.pop_first(&self)\n```\n```c3\nfn void List.push(&self, Type element) @inline\n```\n```c3\nfn void List.push_front(&self, Type type) @inline\n```\n```c3\nfn void List.remove_all_from(&self, List* other_list) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn usz List.remove_all_matches(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void List.remove_at(&self, usz index)\n```\n```c3\nfn void? List.remove_first(&self) @maydiscard\n```\n```c3\nfn bool List.remove_first_match(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn usz List.remove_if(&self, ElementPredicate filter)\n```\n```c3\nfn void? List.remove_last(&self) @maydiscard\n```\n```c3\nfn bool List.remove_last_match(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn usz List.remove_using_test(&self, ElementTest filter, any context)\n```\n```c3\nfn void List.reserve(&self, usz min_capacity)\n```\n```c3\nfn usz List.retain_if(&self, ElementPredicate selection)\n```\n```c3\nfn usz List.retain_using_test(&self, ElementTest filter, any context)\n```\n```c3\nfn void List.reverse(&self)\n```\n```c3\nfn usz? List.rindex_of(&self, Type type) @if(ELEMENT_IS_EQUATABLE)\n```\n```c3\nfn void List.set(&self, usz index, Type value) @operator([]=)\n```\n```c3\nfn void List.set_at(&self, usz index, Type type)\n```\n```c3\nfn void List.swap(&self, usz i, usz j)\n```\n```c3\nfn List* List.temp_init(&self, usz initial_capacity = 16)\n```\n```c3\nfn usz? List.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn Type[] List.to_new_array(&self, Allocator allocator = allocator::heap())\n```\n```c3\nfn String List.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn Type[] List.to_tarray(&self)\n```\n```c3\nfn String List.to_tstring(&self)\n```\n### `std::collections::map(&lt;Key, Value&gt;)`\n```c3\nstruct Entry\n```\n```c3\nstruct HashMap\n```\n```c3\nmacro HashMap.@each(map; @body(key, value))\n```\n```c3\nmacro HashMap.@each_entry(map; @body(entry))\n```\n```c3\nmacro Value HashMap.@get_or_set(&map, Key key, Value #expr)\n```\n```c3\nfn void HashMap.clear(&map)\n```\n```c3\nfn void HashMap.free(&map)\n```\n```c3\nfn Value? HashMap.get(&map, Key key) @operator([])\n```\n```c3\nfn Entry*? HashMap.get_entry(&map, Key key)\n```\n```c3\nfn Value*? HashMap.get_ref(&map, Key key)\n```\n```c3\nfn bool HashMap.has_key(&map, Key key)\n```\n```c3\nfn bool HashMap.has_value(&map, Value v) @if(VALUE_IS_EQUATABLE)\n```\n```c3\nfn bool HashMap.is_empty(&map) @inline\n```\n```c3\nfn bool HashMap.is_initialized(&map)\n```\n```c3\nfn Key[] HashMap.key_new_list(&map, Allocator allocator = allocator::heap())\n```\n```c3\nfn Key[] HashMap.key_tlist(&map)\n```\n```c3\nfn usz HashMap.len(&map) @inline\n```\n```c3\nfn HashMap* HashMap.new_init(&self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR, Allocator allocator = allocator::heap())\n```\n```c3\nfn HashMap* HashMap.new_init_from_map(&self, HashMap* other_map, Allocator allocator = allocator::heap())\n```\n```c3\nfn void? HashMap.remove(&map, Key key) @maydiscard\n```\n```c3\nfn bool HashMap.set(&map, Key key, Value value) @operator([]=)\n```\n```c3\nfn HashMap* HashMap.temp_init(&self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR)\n```\n```c3\nfn HashMap* HashMap.temp_init_from_map(&map, HashMap* other_map)\n```\n```c3\nfn Value[] HashMap.value_new_list(&map, Allocator allocator = allocator::heap())\n```\n```c3\nfn Value[] HashMap.value_tlist(&map)\n```\n### `std::collections::maybe(&lt;Type&gt;)`\n```c3\nstruct Maybe\n```\n```c3\nmacro Type? Maybe.get(self)\n```\n```c3\nfn Maybe value(Type val)\n```\n### `std::collections::object`\n```c3\nstruct Object (Printable)\n```\n```c3\nfn void Object.free(&self)\n```\n```c3\nfn Object*? Object.get(&self, String key)\n```\n```c3\nfn Object* Object.get_at(&self, usz index)\n```\n```c3\nfn bool? Object.get_bool(&self, String key)\n```\n```c3\nfn bool? Object.get_bool_at(&self, usz index)\n```\n```c3\nfn char? Object.get_char(&self, String key)\n```\n```c3\nfn char? Object.get_char_at(&self, usz index)\n```\n```c3\nmacro String? Object.get_enum(&self, $EnumType, String key)\n```\n```c3\nmacro String? Object.get_enum_at(&self, $EnumType, usz index)\n```\n```c3\nfn double? Object.get_float(&self, String key)\n```\n```c3\nfn double? Object.get_float_at(&self, usz index)\n```\n```c3\nfn ichar? Object.get_ichar(&self, String key)\n```\n```c3\nfn ichar? Object.get_ichar_at(&self, usz index)\n```\n```c3\nfn int? Object.get_int(&self, String key)\n```\n```c3\nfn int128? Object.get_int128(&self, String key)\n```\n```c3\nfn int128? Object.get_int128_at(&self, usz index)\n```\n```c3\nfn int? Object.get_int_at(&self, usz index)\n```\n```c3\nfn usz Object.get_len(&self)\n```\n```c3\nfn long? Object.get_long(&self, String key)\n```\n```c3\nfn long? Object.get_long_at(&self, usz index)\n```\n```c3\nfn Object* Object.get_or_create_obj(&self, String key)\n```\n```c3\nfn short? Object.get_short(&self, String key)\n```\n```c3\nfn short? Object.get_short_at(&self, usz index)\n```\n```c3\nfn String? Object.get_string(&self, String key)\n```\n```c3\nfn String? Object.get_string_at(&self, usz index)\n```\n```c3\nfn uint? Object.get_uint(&self, String key)\n```\n```c3\nfn uint128? Object.get_uint128(&self, String key)\n```\n```c3\nfn uint128? Object.get_uint128_at(&self, usz index)\n```\n```c3\nfn uint? Object.get_uint_at(&self, usz index)\n```\n```c3\nfn ulong? Object.get_ulong(&self, String key)\n```\n```c3\nfn ulong? Object.get_ulong_at(&self, usz index)\n```\n```c3\nfn short? Object.get_ushort(&self, String key)\n```\n```c3\nfn ushort? Object.get_ushort_at(&self, usz index)\n```\n```c3\nfn bool Object.has_key(&self, String key)\n```\n```c3\nfn bool Object.is_array(&self) @inline\n```\n```c3\nfn bool Object.is_bool(&self) @inline\n```\n```c3\nfn bool Object.is_empty(&self) @inline\n```\n```c3\nfn bool Object.is_float(&self) @inline\n```\n```c3\nfn bool Object.is_indexable(&self)\n```\n```c3\nfn bool Object.is_int(&self) @inline\n```\n```c3\nfn bool Object.is_keyable(&self)\n```\n```c3\nfn bool Object.is_map(&self) @inline\n```\n```c3\nfn bool Object.is_null(&self) @inline\n```\n```c3\nfn bool Object.is_string(&self) @inline\n```\n```c3\nmacro Object* Object.push(&self, value)\n```\n```c3\nfn void Object.push_object(&self, Object* to_append)\n```\n```c3\nmacro Object* Object.set(&self, String key, value)\n```\n```c3\nmacro Object* Object.set_at(&self, usz index, String key, value)\n```\n```c3\nfn void Object.set_object_at(&self, usz index, Object* to_set)\n```\n```c3\nfn usz? Object.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nmacro get_integer_value(Object* value, $Type)\n```\n```c3\nfn Object* new_bool(bool b)\n```\n```c3\nmacro Object* new_enum(e, Allocator allocator)\n```\n```c3\nfn Object* new_float(double f, Allocator allocator)\n```\n```c3\nfn Object* new_int(int128 i, Allocator allocator)\n```\n```c3\nfn Object* new_null()\n```\n```c3\nfn Object* new_obj(Allocator allocator)\n```\n```c3\nfn Object* new_string(String s, Allocator allocator)\n```\n### `std::collections::priorityqueue(&lt;Type&gt;)`\n```c3\ntypedef PriorityQueue = inline PrivatePriorityQueue{ Type, false };\n```\n```c3\ntypedef PriorityQueueMax = inline PrivatePriorityQueue{ Type, true };\n```\n### `std::collections::priorityqueue::private(&lt;Type, MAX&gt;)`\n```c3\nstruct PrivatePriorityQueue (Printable)\n```\n```c3\nfn Type? PrivatePriorityQueue.first(&self)\n```\n```c3\nfn void PrivatePriorityQueue.free(&self)\n```\n```c3\nfn Type PrivatePriorityQueue.get(&self, usz index) @operator([])\n```\n```c3\nfn bool PrivatePriorityQueue.is_empty(&self)\n```\n```c3\nfn usz PrivatePriorityQueue.len(&self) @operator(len)\n```\n```c3\nfn void PrivatePriorityQueue.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap()) @inline\n```\n```c3\nfn Type? PrivatePriorityQueue.pop(&self)\n```\n```c3\nfn void PrivatePriorityQueue.push(&self, Type element)\n```\n```c3\nfn void PrivatePriorityQueue.temp_init(&self, usz initial_capacity = 16) @inline\n```\n```c3\nfn usz? PrivatePriorityQueue.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String PrivatePriorityQueue.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n### `std::collections::range(&lt;Type&gt;)`\n```c3\nstruct ExclusiveRange (Printable)\n```\n```c3\nstruct Range (Printable)\n```\n```c3\nfn bool ExclusiveRange.contains(&self, Type value) @inline\n```\n```c3\nfn Type ExclusiveRange.get(&self, usz index) @operator([])\n```\n```c3\nfn usz ExclusiveRange.len(&self) @operator(len)\n```\n```c3\nfn usz? ExclusiveRange.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String ExclusiveRange.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String ExclusiveRange.to_tstring(&self)\n```\n```c3\nfn bool Range.contains(&self, Type value) @inline\n```\n```c3\nfn Type Range.get(&self, usz index) @operator([])\n```\n```c3\nfn usz Range.len(&self) @operator(len)\n```\n```c3\nfn usz? Range.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String Range.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String Range.to_tstring(&self)\n```\n### `std::collections::ringbuffer(&lt;Type, SIZE&gt;)`\n```c3\nstruct RingBuffer\n```\n```c3\nfn Type RingBuffer.get(&self, usz index) @operator([])\n```\n```c3\nfn void RingBuffer.init(&self) @inline\n```\n```c3\nfn Type? RingBuffer.pop(&self)\n```\n```c3\nfn void RingBuffer.push(&self, Type c)\n```\n```c3\nfn usz RingBuffer.read(&self, usz index, Type[] buffer)\n```\n```c3\nfn void RingBuffer.write(&self, Type[] buffer)\n```\n### `std::collections::triple(&lt;Type1, Type2, Type3&gt;)`\n```c3\nstruct Triple\n```\n### `std::collections::tuple(&lt;Type1, Type2&gt;)`\n```c3\nstruct Tuple\n```\n### `std::core::array`\n```c3\nmacro concat_new(arr1, arr2, Allocator allocator = allocator::heap())\n```\n```c3\nmacro index_of(array, element)\n```\n```c3\nmacro rindex_of(array, element)\n```\n```c3\nmacro slice2d(array, x = 0, xlen = 0, y = 0, ylen = 0)\n```\n```c3\nmacro tconcat(arr1, arr2)\n```\n### `std::core::array::slice(&lt;Type&gt;)`\n```c3\nstruct Slice2d\n```\n```c3\nmacro void Slice2d.@each(&self; @body(usz[<2>], Type))\n```\n```c3\nmacro void Slice2d.@each_ref(&self; @body(usz[<2>], Type*))\n```\n```c3\nfn usz Slice2d.count(&self)\n```\n```c3\nmacro Type[] Slice2d.get(self, usz idy) @operator([])\n```\n```c3\nfn usz Slice2d.len(&self) @operator(len)\n```\n```c3\nfn Slice2d Slice2d.slice(&self, isz x = 0, isz xlen = 0, isz y = 0, isz ylen = 0)\n```\n### `std::core::bitorder`\n```c3\nmacro bool is_array_or_slice_of_char(bytes)\n```\n```c3\nmacro bool is_arrayptr_or_slice_of_char(bytes)\n```\n```c3\nmacro is_bitorder($Type)\n```\n```c3\nmacro read(bytes, $Type)\n```\n```c3\nmacro write(x, bytes, $Type)\n```\n### `std::core::builtin`\n```c3\nenum PrefetchLocality\n```\n```c3\nfault CastResult\n```\n```c3\nfault IteratorResult\n```\n```c3\nfault SearchResult\n```\n```c3\nmacro char[] @as_char_view(&value) @builtin\n```\n```c3\nmacro fault @catch(#expr) @builtin\n```\n```c3\nmacro @expect(#value, expected, $probability = 1.0) @builtin\n```\n```c3\nmacro bool @likely(bool #value, $probability = 1.0) @builtin\n```\n```c3\nmacro bool @ok(#expr) @builtin\n```\n```c3\nmacro @prefetch(void* ptr, PrefetchLocality $locality = VERY_NEAR, bool $write = false) @builtin\n```\n```c3\nmacro void @scope(&variable; @body) @builtin\n```\n```c3\nmacro void @swap(&a, &b) @builtin\n```\n```c3\nmacro bool @unlikely(bool #value, $probability = 1.0) @builtin\n```\n```c3\nmacro uint String.hash(String c)\n```\n```c3\nmacro any.as_inner(&self)\n```\n```c3\nmacro any.retype_to(&self, typeid type)\n```\n```c3\nmacro any_make(void* ptr, typeid type) @builtin\n```\n```c3\nmacro anycast(any v, $Type) @builtin\n```\n```c3\nmacro bitcast(expr, $Type) @builtin\n```\n```c3\nmacro uint bool.hash(bool b)\n```\n```c3\nmacro uint char.hash(char c)\n```\n```c3\nmacro uint char[].hash(char[] c)\n```\n```c3\nmacro int compare_to(a, b) @builtin\n```\n```c3\nfn void default_panic(String message, String file, String function, uint line) @if(!env::NATIVE_STACKTRACE)\n```\n```c3\nfn void default_panic(String message, String file, String function, uint line) @if(env::NATIVE_STACKTRACE)\n```\n```c3\nmacro enum_by_name($Type, String enum_name) @builtin\n```\n```c3\nmacro bool equals(a, b) @builtin\n```\n```c3\nmacro void* get_frameaddress(int n)\n```\n```c3\nmacro void* get_returnaddress(int n)\n```\n```c3\nmacro greater(a, b) @builtin\n```\n```c3\nmacro greater_eq(a, b) @builtin\n```\n```c3\nmacro uint ichar.hash(ichar c)\n```\n```c3\nmacro uint int.hash(int i)\n```\n```c3\nmacro uint int128.hash(int128 i)\n```\n```c3\nmacro less(a, b) @builtin\n```\n```c3\nmacro less_eq(a, b) @builtin\n```\n```c3\nmacro uint long.hash(long i)\n```\n```c3\nmacro max(x, ...) @builtin\n```\n```c3\nmacro min(x, ...) @builtin\n```\n```c3\nfn void panicf(String fmt, String file, String function, uint line, args...)\n```\n```c3\nfn bool print_backtrace(String message, int backtraces_to_ignore) @if(env::NATIVE_STACKTRACE)\n```\n```c3\nmacro uint short.hash(short s)\n```\n```c3\nmacro swizzle(v, ...) @builtin\n```\n```c3\nmacro swizzle2(v, v2, ...) @builtin\n```\n```c3\nmacro uint typeid.hash(typeid t)\n```\n```c3\nmacro uint uint.hash(uint i)\n```\n```c3\nmacro uint uint128.hash(uint128 i)\n```\n```c3\nmacro uint ulong.hash(ulong i)\n```\n```c3\nmacro void unreachable(String string = \"Unreachable statement reached.\", ...) @builtin @noreturn\n```\n```c3\nmacro void unsupported(String string = \"Unsupported function invoked\") @builtin @noreturn\n```\n```c3\nmacro uint ushort.hash(ushort s)\n```\n```c3\nmacro uint void*.hash(void* ptr)\n```\n### `std::core::builtin @if((env::LINUX || env::DARWIN) &amp;&amp; env::COMPILER_SAFE_MODE &amp;&amp; env::DEBUG_SYMBOLS)`\n```c3\nfn void sig_bus_error(CInt i)\n```\n```c3\nfn void sig_panic(String message)\n```\n```c3\nfn void sig_segmentation_fault(CInt i)\n```\n### `std::core::dstring`\n```c3\ntypedef DString (OutStream) = void*;\n```\n```c3\nmacro void DString.append(&self, value)\n```\n```c3\nfn void DString.append_char(&self, char c)\n```\n```c3\nfn void DString.append_char32(&self, Char32 c)\n```\n```c3\nfn void DString.append_chars(&self, String str)\n```\n```c3\nfn void DString.append_repeat(&self, char c, usz times)\n```\n```c3\nfn void DString.append_string(&self, DString str)\n```\n```c3\nfn void DString.append_utf32(&self, Char32[] chars)\n```\n```c3\nfn usz? DString.appendf(&self, String format, args...) @maydiscard\n```\n```c3\nfn usz? DString.appendfn(&self, String format, args...) @maydiscard\n```\n```c3\nfn usz DString.capacity(self)\n```\n```c3\nfn void DString.chop(self, usz new_size)\n```\n```c3\nfn void DString.clear(self)\n```\n```c3\nfn DString DString.copy(self, Allocator allocator = null)\n```\n```c3\nfn String DString.copy_str(self, Allocator allocator = allocator::heap())\n```\n```c3\nfn Char32[] DString.copy_utf32(&self, Allocator allocator = allocator::heap())\n```\n```c3\nfn ZString DString.copy_zstr(self, Allocator allocator = allocator::heap())\n```\n```c3\nfn void DString.delete(&self, usz start, usz len = 1)\n```\n```c3\nfn void DString.delete_range(&self, usz start, usz end)\n```\n```c3\nfn bool DString.equals(self, DString other_string)\n```\n```c3\nfn void DString.free(&self)\n```\n```c3\nfn void DString.insert_at(&self, usz index, String s)\n```\n```c3\nfn usz DString.len(&self) @dynamic\n```\n```c3\nfn bool DString.less(self, DString other_string)\n```\n```c3\nfn DString DString.new_concat(self, DString b, Allocator allocator = allocator::heap())\n```\n```c3\nfn DString DString.new_init(&self, usz capacity = MIN_CAPACITY, Allocator allocator = allocator::heap())\n```\n```c3\nfn usz? DString.read_from_stream(&self, InStream reader)\n```\n```c3\nfn void DString.reserve(&self, usz addition)\n```\n```c3\nfn void DString.set(self, usz index, char c)\n```\n```c3\nfn String DString.str_view(self)\n```\n```c3\nfn DString DString.tcopy(&self)\n```\n```c3\nfn String DString.tcopy_str(self)\n```\n```c3\nfn DString DString.temp_concat(self, DString b)\n```\n```c3\nfn DString DString.temp_init(&self, usz capacity = MIN_CAPACITY)\n```\n```c3\nfn usz? DString.write(&self, char[] buffer) @dynamic\n```\n```c3\nfn void? DString.write_byte(&self, char c) @dynamic\n```\n```c3\nfn ZString DString.zstr_view(&self)\n```\n```c3\nfn DString new(String c = \"\", Allocator allocator = allocator::heap())\n```\n```c3\nfn DString new_join(String[] s, String joiner, Allocator allocator = allocator::heap())\n```\n```c3\nfn DString new_with_capacity(usz capacity, Allocator allocator = allocator::heap())\n```\n```c3\nfn DString tnew(String s = \"\")\n```\n```c3\nfn DString temp_with_capacity(usz capacity)\n```\n### `std::core::env`\n```c3\nenum ArchType\n```\n```c3\nenum CompilerOptLevel\n```\n```c3\nenum MemoryEnvironment\n```\n```c3\nenum OsType\n```\n```c3\nmacro bool os_is_darwin()\n```\n```c3\nmacro bool os_is_posix()\n```\n### `std::core::mem`\n```c3\nenum AtomicOrdering : int\n```\n```c3\nstruct TempState\n```\n```c3\nmacro @atomic_load(&x, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin\n```\n```c3\nmacro void @atomic_store(&x, value, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin\n```\n```c3\nmacro @clone(value) @builtin @nodiscard\n```\n```c3\nmacro @gather_aligned(ptrvec, bool[<*>] mask, passthru, usz $alignment)\n```\n```c3\nmacro @masked_load_aligned(ptr, bool[<*>] mask, passthru, usz $alignment)\n```\n```c3\nmacro @masked_store_aligned(ptr, value, bool[<*>] mask, usz $alignment)\n```\n```c3\nmacro void @pool(TempAllocator* #other_temp = null; @body) @builtin\n```\n```c3\nmacro void @report_heap_allocs_in_scope(;@body())\n```\n```c3\nmacro @scatter_aligned(ptrvec, value, bool[<*>] mask, usz $alignment)\n```\n```c3\nmacro void @scoped(Allocator allocator; @body())\n```\n```c3\nmacro void @stack_mem(usz $size; @body(Allocator mem)) @builtin\n```\n```c3\nmacro void @stack_pool(usz $size; @body) @builtin\n```\n```c3\nmacro @tclone(value) @builtin @nodiscard\n```\n```c3\nmacro @volatile_load(&x) @builtin\n```\n```c3\nmacro @volatile_store(&x, y) @builtin\n```\n```c3\nfn usz aligned_offset(usz offset, usz alignment)\n```\n```c3\nmacro void* aligned_pointer(void* ptr, usz alignment)\n```\n```c3\nmacro alloc($Type) @nodiscard\n```\n```c3\nmacro alloc_aligned($Type) @nodiscard\n```\n```c3\nmacro alloc_array($Type, usz elements) @nodiscard\n```\n```c3\nmacro alloc_array_aligned($Type, usz elements) @nodiscard\n```\n```c3\nfn void* calloc(usz size) @builtin @inline @nodiscard\n```\n```c3\nfn void* calloc_aligned(usz size, usz alignment) @builtin @inline @nodiscard\n```\n```c3\nmacro void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false, bool $inlined = false)\n```\n```c3\nmacro void clear_inline(void* dst, usz $len, usz $dst_align = 0, bool $is_volatile = false)\n```\n```c3\nmacro compare_exchange(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT, bool $volatile = true, bool $weak = false, usz $alignment = 0)\n```\n```c3\nmacro compare_exchange_volatile(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT)\n```\n```c3\nmacro void copy(void* dst, void* src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false, bool $inlined = false)\n```\n```c3\nmacro void copy_inline(void* dst, void* src, usz $len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)\n```\n```c3\nmacro bool equals(a, b, isz len = -1, usz $align = 0)\n```\n```c3\nfn void free(void* ptr) @builtin @inline\n```\n```c3\nfn void free_aligned(void* ptr) @builtin @inline\n```\n```c3\nmacro gather(ptrvec, bool[<*>] mask, passthru)\n```\n```c3\nmacro TrackingEnv* get_tracking_env()\n```\n```c3\nfn void* malloc(usz size) @builtin @inline @nodiscard\n```\n```c3\nmacro masked_load(ptr, bool[<*>] mask, passthru)\n```\n```c3\nmacro masked_store(ptr, value, bool[<*>] mask)\n```\n```c3\nmacro void move(void* dst, void* src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)\n```\n```c3\nmacro new($Type, ...) @nodiscard\n```\n```c3\nmacro new_aligned($Type, ...) @nodiscard\n```\n```c3\nmacro new_array($Type, usz elements) @nodiscard\n```\n```c3\nmacro new_array_aligned($Type, usz elements) @nodiscard\n```\n```c3\nfn bool ptr_is_aligned(void* ptr, usz alignment) @inline\n```\n```c3\nfn void* realloc(void *ptr, usz new_size) @builtin @inline @nodiscard\n```\n```c3\nfn void* realloc_aligned(void *ptr, usz new_size, usz alignment) @builtin @inline @nodiscard\n```\n```c3\nmacro scatter(ptrvec, value, bool[<*>] mask)\n```\n```c3\nmacro void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)\n```\n```c3\nmacro void set_inline(void* dst, char val, usz $len, usz $dst_align = 0, bool $is_volatile = false)\n```\n```c3\nfn void* tcalloc(usz size, usz alignment = 0) @builtin @inline @nodiscard\n```\n```c3\nmacro temp_alloc($Type) @nodiscard\n```\n```c3\nmacro talloc_array($Type, usz elements) @nodiscard\n```\n```c3\nmacro tnew($Type, ...) @nodiscard\n```\n```c3\nmacro temp_array($Type, usz elements) @nodiscard\n```\n```c3\nfn void temp_pop(TempState old_state)\n```\n```c3\nfn TempState temp_push(TempAllocator* other = null)\n```\n```c3\nfn void* tmalloc(usz size, usz alignment = 0) @builtin @inline @nodiscard\n```\n```c3\nfn void* trealloc(void* ptr, usz size, usz alignment = mem::DEFAULT_MEM_ALIGNMENT) @builtin @inline @nodiscard\n```\n```c3\nmacro type_alloc_must_be_aligned($Type)\n```\n### `std::core::mem::allocator`\n```c3\ntypedef LibcAllocator (Allocator) = uptr;\n```\n```c3\nenum AllocInitType\n```\n```c3\nfault AllocationFailure\n```\n```c3\ninterface Allocator\n```\n```c3\nstruct AlignedBlock\n```\n```c3\nstruct Allocation\n```\n```c3\nstruct ArenaAllocator (Allocator)\n```\n```c3\nstruct DynamicArenaAllocator (Allocator)\n```\n```c3\nstruct OnStackAllocator (Allocator)\n```\n```c3\nstruct OnStackAllocatorHeader\n```\n```c3\nstruct SimpleHeapAllocator (Allocator)\n```\n```c3\nstruct TempAllocator (Allocator)\n```\n```c3\nstruct TempAllocatorPage\n```\n```c3\nstruct TrackingAllocator (Allocator)\n```\n```c3\nstruct TrackingEnv\n```\n```c3\nstruct WasmMemory\n```\n```c3\nmacro void*? @aligned_alloc(#alloc_fn, usz bytes, usz alignment)\n```\n```c3\nmacro void? @aligned_free(#free_fn, void* old_pointer)\n```\n```c3\nmacro void*? @aligned_realloc(#calloc_fn, #free_fn, void* old_pointer, usz bytes, usz alignment)\n```\n```c3\nfn void*? ArenaAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void ArenaAllocator.clear(&self)\n```\n```c3\nfn void ArenaAllocator.init(&self, char[] data)\n```\n```c3\nfn usz ArenaAllocator.mark(&self) @dynamic\n```\n```c3\nfn void ArenaAllocator.release(&self, void* ptr, bool) @dynamic\n```\n```c3\nfn void ArenaAllocator.reset(&self, usz mark) @dynamic\n```\n```c3\nfn void*? ArenaAllocator.resize(&self, void *old_pointer, usz size, usz alignment) @dynamic\n```\n```c3\nfn void*? DynamicArenaAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void DynamicArenaAllocator.free(&self)\n```\n```c3\nfn void DynamicArenaAllocator.init(&self, usz page_size, Allocator allocator)\n```\n```c3\nfn void DynamicArenaAllocator.release(&self, void* ptr, bool) @dynamic\n```\n```c3\nfn void DynamicArenaAllocator.reset(&self, usz mark = 0) @dynamic\n```\n```c3\nfn void*? DynamicArenaAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n```c3\nfn void*? OnStackAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void OnStackAllocator.free(&self)\n```\n```c3\nfn void OnStackAllocator.init(&self, char[] data, Allocator allocator)\n```\n```c3\nfn void OnStackAllocator.release(&self, void* old_pointer, bool aligned) @dynamic\n```\n```c3\nfn void*? OnStackAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n```c3\nfn void*? SimpleHeapAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void SimpleHeapAllocator.init(&self, MemoryAllocFn allocator)\n```\n```c3\nfn void SimpleHeapAllocator.release(&self, void* old_pointer, bool aligned) @dynamic\n```\n```c3\nfn void*? SimpleHeapAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n```c3\nfn void*? TempAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn usz TempAllocator.mark(&self) @dynamic\n```\n```c3\nfn void? TempAllocator.print_pages(&self, File* f)\n```\n```c3\nfn void TempAllocator.release(&self, void* old_pointer, bool) @dynamic\n```\n```c3\nfn void TempAllocator.reset(&self, usz mark) @dynamic\n```\n```c3\nfn void*? TempAllocator.resize(&self, void* pointer, usz size, usz alignment) @dynamic\n```\n```c3\nmacro bool TempAllocatorPage.is_aligned(&self)\n```\n```c3\nmacro usz TempAllocatorPage.pagesize(&self)\n```\n```c3\nfn void*? TrackingAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn usz TrackingAllocator.allocated(&self)\n```\n```c3\nfn usz TrackingAllocator.allocation_count(&self)\n```\n```c3\nfn Allocation[] TrackingAllocator.allocations_tlist(&self, Allocator allocator)\n```\n```c3\nfn void TrackingAllocator.clear(&self)\n```\n```c3\nfn void? TrackingAllocator.fprint_report(&self, OutStream out)\n```\n```c3\nfn void TrackingAllocator.free(&self)\n```\n```c3\nfn void TrackingAllocator.init(&self, Allocator allocator)\n```\n```c3\nfn void TrackingAllocator.print_report(&self)\n```\n```c3\nfn void TrackingAllocator.release(&self, void* old_pointer, bool is_aligned) @dynamic\n```\n```c3\nfn void*? TrackingAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n```c3\nfn usz TrackingAllocator.total_allocated(&self)\n```\n```c3\nfn usz TrackingAllocator.total_allocation_count(&self)\n```\n```c3\nfn char[]? WasmMemory.allocate_block(&self, usz bytes)\n```\n```c3\nmacro alloc(Allocator allocator, $Type) @nodiscard\n```\n```c3\nmacro alloc_array(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nmacro alloc_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nmacro alloc_array_try(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nmacro alloc_try(Allocator allocator, $Type) @nodiscard\n```\n```c3\nmacro alloc_with_padding(Allocator allocator, $Type, usz padding) @nodiscard\n```\n```c3\nmacro void* calloc(Allocator allocator, usz size) @nodiscard\n```\n```c3\nmacro void*? calloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard\n```\n```c3\nmacro void*? calloc_try(Allocator allocator, usz size) @nodiscard\n```\n```c3\nmacro clone(Allocator allocator, value) @nodiscard\n```\n```c3\nfn any clone_any(Allocator allocator, any value) @nodiscard\n```\n```c3\nmacro void free(Allocator allocator, void* ptr)\n```\n```c3\nmacro void free_aligned(Allocator allocator, void* ptr)\n```\n```c3\nmacro Allocator heap()\n```\n```c3\nmacro void* malloc(Allocator allocator, usz size) @nodiscard\n```\n```c3\nmacro void*? malloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard\n```\n```c3\nmacro void*? malloc_try(Allocator allocator, usz size) @nodiscard\n```\n```c3\nmacro new(Allocator allocator, $Type, ...) @nodiscard\n```\n```c3\nmacro new_array(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nmacro new_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nmacro new_array_try(Allocator allocator, $Type, usz elements) @nodiscard\n```\n```c3\nfn TempAllocator*? new_temp_allocator(usz size, Allocator allocator)\n```\n```c3\nmacro new_try(Allocator allocator, $Type, ...) @nodiscard\n```\n```c3\nmacro new_with_padding(Allocator allocator, $Type, usz padding) @nodiscard\n```\n```c3\nmacro void* realloc(Allocator allocator, void* ptr, usz new_size) @nodiscard\n```\n```c3\nmacro void*? realloc_aligned(Allocator allocator, void* ptr, usz new_size, usz alignment) @nodiscard\n```\n```c3\nmacro void*? realloc_try(Allocator allocator, void* ptr, usz new_size) @nodiscard\n```\n```c3\nmacro TempAllocator* temp()\n```\n### `std::core::mem::allocator @if(!env::WIN32 &amp;&amp; !env::POSIX)`\n```c3\nfn void*? LibcAllocator.acquire(&self, usz bytes, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void LibcAllocator.release(&self, void* old_ptr, bool aligned) @dynamic\n```\n```c3\nfn void*? LibcAllocator.resize(&self, void* old_ptr, usz new_bytes, usz alignment) @dynamic\n```\n### `std::core::mem::allocator @if(env::POSIX)`\n```c3\nfn void*? LibcAllocator.acquire(&self, usz bytes, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void LibcAllocator.release(&self, void* old_ptr, bool aligned) @dynamic\n```\n```c3\nfn void*? LibcAllocator.resize(&self, void* old_ptr, usz new_bytes, usz alignment) @dynamic\n```\n### `std::core::mem::allocator @if(env::WIN32)`\n```c3\nfn void*? LibcAllocator.acquire(&self, usz bytes, AllocInitType init_type, usz alignment) @dynamic\n```\n```c3\nfn void LibcAllocator.release(&self, void* old_ptr, bool aligned) @dynamic\n```\n```c3\nfn void*? LibcAllocator.resize(&self, void* old_ptr, usz new_bytes, usz alignment) @dynamic\n```\n### `std::core::runtime`\n```c3\nstruct AnyRaw\n```\n```c3\nstruct BenchmarkUnit\n```\n```c3\nstruct SliceRaw\n```\n```c3\nstruct TestContext\n```\n```c3\nstruct TestUnit\n```\n```c3\nfn BenchmarkUnit[] benchmark_collection_create(Allocator allocator = allocator::heap())\n```\n```c3\nfn int cmp_test_unit(TestUnit a, TestUnit b)\n```\n```c3\nfn bool default_benchmark_runner()\n```\n```c3\nfn bool default_test_runner()\n```\n```c3\nfn bool run_benchmarks(BenchmarkUnit[] benchmarks)\n```\n```c3\nfn bool run_tests(TestUnit[] tests)\n```\n```c3\nfn void set_benchmark_max_iterations(uint value) @builtin\n```\n```c3\nfn void set_benchmark_warmup_iterations(uint value) @builtin\n```\n```c3\nfn TestUnit[] test_collection_create(Allocator allocator = allocator::heap())\n```\n```c3\nfn void test_panic(String message, String file, String function, uint line)\n```\n### `std::core::runtime @if(WASM_NOLIBC)`\n```c3\nfn void wasm_initialize() @extern(\"_initialize\") @wasm\n```\n### `std::core::string`\n```c3\ntypedef WString = inline Char16*;\n```\n```c3\ntypedef ZString = inline char*;\n```\n```c3\nfault NumberConversion\n```\n```c3\nfault UnicodeResult\n```\n```c3\nstruct Splitter\n```\n```c3\nfn String? Splitter.next(&self)\n```\n```c3\nfn void Splitter.reset(&self)\n```\n```c3\nfn String String.concat(s1, String s2, Allocator allocator = allocator::heap())\n```\n```c3\nfn bool String.contains(s, String needle)\n```\n```c3\nfn void String.convert_ascii_to_lower(s)\n```\n```c3\nfn void String.convert_ascii_to_upper(s)\n```\n```c3\nfn String String.copy(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn bool String.ends_with(string, String needle)\n```\n```c3\nfn void String.free(&s, Allocator allocator = allocator::heap())\n```\n```c3\nfn usz? String.index_of(s, String needle)\n```\n```c3\nfn usz? String.index_of_char(s, char needle)\n```\n```c3\nfn StringIterator String.iterator(s)\n```\n```c3\nfn String String.new_ascii_to_lower(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn usz? String.rindex_of(s, String needle)\n```\n```c3\nfn usz? String.rindex_of_char(s, char needle)\n```\n```c3\nfn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap())\n```\n```c3\nfn Splitter String.splitter(self, String split)\n```\n```c3\nfn bool String.starts_with(string, String needle)\n```\n```c3\nfn String String.strip(string, String needle)\n```\n```c3\nfn String String.strip_end(string, String needle)\n```\n```c3\nfn String String.tconcat(s1, String s2)\n```\n```c3\nfn String String.tcopy(s)\n```\n```c3\nfn String String.temp_ascii_to_lower(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn String String.temp_ascii_to_upper(s)\n```\n```c3\nfn double? String.to_double(s)\n```\n```c3\nfn float? String.to_float(s)\n```\n```c3\nfn ichar? String.to_ichar(s, int base = 10)\n```\n```c3\nfn int? String.to_int(s, int base = 10)\n```\n```c3\nfn int128? String.to_int128(s, int base = 10)\n```\n```c3\nmacro String.to_integer(string, $Type, int base = 10)\n```\n```c3\nfn long? String.to_long(s, int base = 10)\n```\n```c3\nfn Char16[]? String.to_new_utf16(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn Char32[]? String.to_new_utf32(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn WString? String.to_new_wstring(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn short? String.to_short(s, int base = 10)\n```\n```c3\nfn Char16[]? String.to_temp_utf16(s)\n```\n```c3\nfn Char32[]? String.to_temp_utf32(s)\n```\n```c3\nfn WString? String.to_temp_wstring(s)\n```\n```c3\nfn char? String.to_uchar(s, int base = 10)\n```\n```c3\nfn uint? String.to_uint(s, int base = 10)\n```\n```c3\nfn uint128? String.to_uint128(s, int base = 10)\n```\n```c3\nfn ulong? String.to_ulong(s, int base = 10)\n```\n```c3\nfn ushort? String.to_ushort(s, int base = 10)\n```\n```c3\nfn String String.trim(string, String to_trim = \"\\t\\n\\r \")\n```\n```c3\nfn String[] String.tsplit(s, String needle, usz max = 0)\n```\n```c3\nfn usz String.utf8_codepoints(s)\n```\n```c3\nfn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())\n```\n```c3\nfn ZString String.zstr_tcopy(s)\n```\n```c3\nfn usz ZString.char_len(str)\n```\n```c3\nfn String ZString.copy(z, Allocator allocator = allocator::temp())\n```\n```c3\nfn usz ZString.len(str)\n```\n```c3\nfn String ZString.str_view(str)\n```\n```c3\nfn String ZString.tcopy(z)\n```\n```c3\nmacro bool char_in_set(char c, String set)\n```\n```c3\nmacro double? decfloat(char[] chars, int $bits, int $emin, int sign)\n```\n```c3\nmacro double? hexfloat(char[] chars, int $bits, int $emin, int sign)\n```\n```c3\nfn String join_new(String[] s, String joiner, Allocator allocator = allocator::heap())\n```\n```c3\nmacro String new_format(String fmt, ..., Allocator allocator = allocator::heap())\n```\n```c3\nfn String? new_from_utf16(Char16[] utf16, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? new_from_utf32(Char32[] utf32, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? new_from_wstring(WString wstring, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? temp_from_utf16(Char16[] utf16)\n```\n```c3\nfn String? temp_from_wstring(WString wstring)\n```\n```c3\nmacro String tformat(String fmt, ...)\n```\n### `std::core::string::conv`\n```c3\nfn void? char16_to_utf8_unsafe(Char16 *ptr, usz *available, char** output)\n```\n```c3\nfn void char32_to_utf16_unsafe(Char32 c, Char16** output)\n```\n```c3\nfn usz? char32_to_utf8(Char32 c, char[] output)\n```\n```c3\nfn usz char32_to_utf8_unsafe(Char32 c, char** output)\n```\n```c3\nfn usz utf16len_for_utf32(Char32[] utf32)\n```\n```c3\nfn usz utf16len_for_utf8(String utf8)\n```\n```c3\nfn void? utf16to8_unsafe(Char16[] utf16, char* utf8_buffer)\n```\n```c3\nfn usz? utf32to8(Char32[] utf32, char[] utf8_buffer)\n```\n```c3\nfn void utf32to8_unsafe(Char32[] utf32, char* utf8_buffer)\n```\n```c3\nfn usz utf8_codepoints(String utf8)\n```\n```c3\nfn Char32? utf8_to_char32(char* ptr, usz* size)\n```\n```c3\nfn usz utf8len_for_utf16(Char16[] utf16)\n```\n```c3\nfn usz utf8len_for_utf32(Char32[] utf32)\n```\n```c3\nfn void? utf8to16_unsafe(String utf8, Char16* utf16_buffer)\n```\n```c3\nfn usz? utf8to32(String utf8, Char32[] utf32_buffer)\n```\n```c3\nfn void? utf8to32_unsafe(String utf8, Char32* utf32_buffer)\n```\n### `std::core::string::iterator`\n```c3\nstruct StringIterator\n```\n```c3\nfn Char32? StringIterator.next(&self)\n```\n```c3\nfn void StringIterator.reset(&self)\n```\n### `std::core::types`\n```c3\nenum TypeKind : char\n```\n```c3\nfault ConversionResult\n```\n```c3\nstruct TypeEnum\n```\n```c3\nmacro bool @has_same(#a, #b, ...)\n```\n```c3\nfn bool TypeKind.is_int(kind) @inline\n```\n```c3\nmacro any_to_int(any v, $Type)\n```\n```c3\nmacro bool implements_copy($Type)\n```\n```c3\nmacro TypeKind inner_kind($Type)\n```\n```c3\nmacro bool is_bool($Type)\n```\n```c3\nmacro bool is_comparable_value(value)\n```\n```c3\nmacro bool is_equatable_type($Type)\n```\n```c3\nmacro bool is_equatable_value(value)\n```\n```c3\nmacro bool is_float($Type)\n```\n```c3\nmacro bool is_floatlike($Type)\n```\n```c3\nmacro bool is_int($Type)\n```\n```c3\nmacro bool is_intlike($Type)\n```\n```c3\nmacro bool is_numerical($Type)\n```\n```c3\nmacro bool is_promotable_to_float($Type)\n```\n```c3\nmacro bool is_promotable_to_floatlike($Type)\n```\n```c3\nmacro bool is_same($TypeA, $TypeB)\n```\n```c3\nmacro bool is_same_vector_type($Type1, $Type2)\n```\n```c3\nmacro bool is_slice_convertable($Type)\n```\n```c3\nmacro bool is_subtype_of($Type, $OtherType)\n```\n```c3\nmacro bool is_underlying_int($Type)\n```\n```c3\nmacro bool is_vector($Type)\n```\n```c3\nmacro lower_to_atomic_compatible_type($Type)\n```\n```c3\nmacro bool may_load_atomic($Type)\n```\n```c3\nfn bool typeid.is_subtype_of(self, typeid other)\n```\n### `std::core::values`\n```c3\nmacro bool @assign_to(#value1, #value2)\n```\n```c3\nmacro TypeKind @inner_kind(#value)\n```\n```c3\nmacro bool @is_bool(#value)\n```\n```c3\nmacro bool @is_float(#value)\n```\n```c3\nmacro bool @is_floatlike(#value)\n```\n```c3\nmacro bool @is_int(#value)\n```\n```c3\nmacro bool @is_promotable_to_float(#value)\n```\n```c3\nmacro bool @is_promotable_to_floatlike(#value)\n```\n```c3\nmacro bool @is_same_type(#value1, #value2)\n```\n```c3\nmacro bool @is_same_vector_type(#value1, #value2)\n```\n```c3\nmacro bool @is_vector(#value)\n```\n```c3\nmacro typeid @typeid(#value) @builtin\n```\n```c3\nmacro bool @typeis(#value, $Type) @builtin\n```\n```c3\nmacro TypeKind @typekind(#value) @builtin\n```\n```c3\nmacro promote_int(x)\n```\n### `std::crypto::rc4`\n```c3\nstruct Rc4\n```\n```c3\nfn void Rc4.crypt(&self, char[] in, char[] out)\n```\n```c3\nfn void Rc4.destroy(&self)\n```\n```c3\nfn void Rc4.init(&self, char[] key)\n```\n### `std::encoding::base64`\n```c3\nfault Base64Error\n```\n```c3\nstruct Base64Decoder\n```\n```c3\nstruct Base64Encoder\n```\n```c3\nfn usz? Base64Decoder.decode(&self, char[] src, char[] dst)\n```\n```c3\nfn usz? Base64Decoder.decode_len(&self, usz n)\n```\n```c3\nfn void? Base64Decoder.init(&self, String alphabet, int padding = '=')\n```\n```c3\nfn usz? Base64Encoder.encode(&self, char[] src, char[] dst)\n```\n```c3\nfn usz Base64Encoder.encode_len(&self, usz n)\n```\n```c3\nfn void? Base64Encoder.init(&self, String alphabet, int padding = '=')\n```\n### `std::encoding::csv`\n```c3\nstruct CsvReader\n```\n```c3\nmacro CsvReader.@each_row(self, int rows = int.max; @body(String[] row))\n```\n```c3\nfn void CsvReader.init(&self, InStream stream, String separator = \",\")\n```\n```c3\nfn String[]? CsvReader.read_new_row(self, Allocator allocator = allocator::heap())\n```\n```c3\nfn String[]? CsvReader.read_new_row_with_allocator(self, Allocator allocator = allocator::heap())\n```\n```c3\nfn String[]? CsvReader.read_temp_row(self)\n```\n```c3\nfn void? CsvReader.skip_row(self) @maydiscard\n```\n### `std::encoding::json`\n```c3\nfault JsonParsingError\n```\n```c3\nfn JsonTokenType? lex_string(JsonContext* context)\n```\n```c3\nfn Object*? parse(InStream s, Allocator allocator = allocator::heap())\n```\n### `std::hash::adler32`\n```c3\nstruct Adler32\n```\n```c3\nfn uint Adler32.final(&self)\n```\n```c3\nfn void Adler32.init(&self)\n```\n```c3\nfn void Adler32.update(&self, char[] data)\n```\n```c3\nfn void Adler32.updatec(&self, char c)\n```\n```c3\nfn uint encode(char[] data)\n```\n### `std::hash::crc32`\n```c3\nstruct Crc32\n```\n```c3\nfn uint Crc32.final(&self)\n```\n```c3\nfn void Crc32.init(&self, uint seed = 0)\n```\n```c3\nfn void Crc32.update(&self, char[] data)\n```\n```c3\nfn void Crc32.updatec(&self, char c)\n```\n```c3\nfn uint encode(char[] data)\n```\n### `std::hash::crc64`\n```c3\nstruct Crc64\n```\n```c3\nfn ulong Crc64.final(&self)\n```\n```c3\nfn void Crc64.init(&self, uint seed = 0)\n```\n```c3\nfn void Crc64.update(&self, char[] data)\n```\n```c3\nfn void Crc64.updatec(&self, char c)\n```\n```c3\nfn ulong encode(char[] data)\n```\n### `std::hash::fnv32a`\n```c3\ntypedef Fnv32a = uint;\n```\n```c3\nfn void Fnv32a.init(&self)\n```\n```c3\nfn void Fnv32a.update(&self, char[] data)\n```\n```c3\nmacro void Fnv32a.update_char(&self, char c)\n```\n```c3\nfn uint encode(char[] data)\n```\n### `std::hash::fnv64a`\n```c3\ntypedef Fnv64a = ulong;\n```\n```c3\nfn void Fnv64a.init(&self)\n```\n```c3\nfn void Fnv64a.update(&self, char[] data)\n```\n```c3\nmacro void Fnv64a.update_char(&self, char c)\n```\n```c3\nfn ulong encode(char[] data)\n```\n### `std::hash::sha1`\n```c3\nstruct Sha1\n```\n```c3\nfn char[20] Sha1.final(&self)\n```\n```c3\nfn void Sha1.init(&self)\n```\n```c3\nfn void Sha1.update(&self, char[] data)\n```\n### `std::io`\n```c3\nenum Seek\n```\n```c3\nfault FormattingFault\n```\n```c3\nfault IoError\n```\n```c3\nfault PrintFault\n```\n```c3\ninterface InStream\n```\n```c3\ninterface OutStream\n```\n```c3\ninterface Printable\n```\n```c3\nstruct BitReader\n```\n```c3\nstruct BitWriter\n```\n```c3\nstruct ByteBuffer (InStream, OutStream)\n```\n```c3\nstruct ByteReader (InStream)\n```\n```c3\nstruct ByteWriter (OutStream)\n```\n```c3\nstruct File (InStream, OutStream)\n```\n```c3\nstruct Formatter\n```\n```c3\nstruct LimitReader (InStream)\n```\n```c3\nstruct ReadBuffer (InStream)\n```\n```c3\nstruct Scanner (InStream)\n```\n```c3\nstruct WriteBuffer (OutStream)\n```\n```c3\nmacro bool @is_instream(#expr)\n```\n```c3\nmacro bool @is_outstream(#expr)\n```\n```c3\nmacro void? @pushback_using_seek(&s)\n```\n```c3\nmacro char? @read_byte_using_read(&s)\n```\n```c3\nmacro usz? @read_using_read_byte(&s, char[] buffer)\n```\n```c3\nmacro void? @write_byte_using_write(&s, char c)\n```\n```c3\nmacro usz? @write_using_write_byte(&s, char[] bytes)\n```\n```c3\nfn void BitReader.clear(&self) @inline\n```\n```c3\nfn void BitReader.init(&self, InStream byte_reader)\n```\n```c3\nfn char? BitReader.read_bits(&self, uint nbits)\n```\n```c3\nfn void? BitWriter.flush(&self)\n```\n```c3\nfn void BitWriter.init(&self, OutStream byte_writer)\n```\n```c3\nfn void? BitWriter.write_bits(&self, uint bits, uint nbits)\n```\n```c3\nfn usz? ByteBuffer.available(&self) @inline @dynamic\n```\n```c3\nfn void ByteBuffer.free(&self)\n```\n```c3\nfn void? ByteBuffer.grow(&self, usz n)\n```\n```c3\nfn ByteBuffer*? ByteBuffer.init_with_buffer(&self, char[] buf)\n```\n```c3\nfn ByteBuffer*? ByteBuffer.new_init(&self, usz max_read, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n```c3\nfn void? ByteBuffer.pushback_byte(&self) @dynamic\n```\n```c3\nfn usz? ByteBuffer.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? ByteBuffer.read_byte(&self) @dynamic\n```\n```c3\nfn usz? ByteBuffer.seek(&self, isz offset, Seek seek) @dynamic\n```\n```c3\nmacro ByteBuffer.shrink(&self)\n```\n```c3\nfn ByteBuffer*? ByteBuffer.temp_init(&self, usz max_read, usz initial_capacity = 16)\n```\n```c3\nfn usz? ByteBuffer.write(&self, char[] bytes) @dynamic\n```\n```c3\nfn void? ByteBuffer.write_byte(&self, char c) @dynamic\n```\n```c3\nfn usz? ByteReader.available(&self) @inline @dynamic\n```\n```c3\nfn ByteReader* ByteReader.init(&self, char[] bytes)\n```\n```c3\nfn usz ByteReader.len(&self) @dynamic\n```\n```c3\nfn void? ByteReader.pushback_byte(&self) @dynamic\n```\n```c3\nfn usz? ByteReader.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? ByteReader.read_byte(&self) @dynamic\n```\n```c3\nfn usz? ByteReader.seek(&self, isz offset, Seek seek) @dynamic\n```\n```c3\nfn usz? ByteReader.write_to(&self, OutStream writer) @dynamic\n```\n```c3\nfn void? ByteWriter.destroy(&self) @dynamic\n```\n```c3\nfn void? ByteWriter.ensure_capacity(&self, usz len) @inline\n```\n```c3\nfn ByteWriter* ByteWriter.init_with_buffer(&self, char[] data)\n```\n```c3\nfn ByteWriter* ByteWriter.new_init(&self, Allocator allocator = allocator::heap())\n```\n```c3\nfn usz? ByteWriter.read_from(&self, InStream reader) @dynamic\n```\n```c3\nfn String ByteWriter.str_view(&self) @inline\n```\n```c3\nfn ByteWriter* ByteWriter.temp_init(&self)\n```\n```c3\nfn usz? ByteWriter.write(&self, char[] bytes) @dynamic\n```\n```c3\nfn void? ByteWriter.write_byte(&self, char c) @dynamic\n```\n```c3\nfn void Formatter.init(&self, OutputFn out_fn, void* data = null)\n```\n```c3\nfn usz? Formatter.print(&self, String str)\n```\n```c3\nfn usz? Formatter.print_with_function(&self, Printable arg)\n```\n```c3\nfn usz? Formatter.printf(&self, String format, args...)\n```\n```c3\nfn usz? Formatter.vprintf(&self, String format, any[] anys)\n```\n```c3\nfn usz? LimitReader.available(&self) @inline @dynamic\n```\n```c3\nfn void? LimitReader.close(&self) @dynamic\n```\n```c3\nfn LimitReader* LimitReader.init(&self, InStream wrapped_stream, usz limit)\n```\n```c3\nfn usz? LimitReader.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? LimitReader.read_byte(&self) @dynamic\n```\n```c3\nfn void? ReadBuffer.close(&self) @dynamic\n```\n```c3\nfn ReadBuffer* ReadBuffer.init(&self, InStream wrapped_stream, char[] bytes)\n```\n```c3\nfn usz? ReadBuffer.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? ReadBuffer.read_byte(&self) @dynamic\n```\n```c3\nfn String ReadBuffer.str_view(&self) @inline\n```\n```c3\nfn void? Scanner.close(&self) @dynamic\n```\n```c3\nfn char[] Scanner.flush(&self) @dynamic\n```\n```c3\nfn void Scanner.init(&self, InStream stream, char[] buffer)\n```\n```c3\nfn usz? Scanner.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? Scanner.read_byte(&self) @dynamic\n```\n```c3\nfn char[]? Scanner.scan(&self, String pattern = \"\\n\")\n```\n```c3\nfn void? WriteBuffer.close(&self) @dynamic\n```\n```c3\nfn void? WriteBuffer.flush(&self) @dynamic\n```\n```c3\nfn WriteBuffer* WriteBuffer.init(&self, OutStream wrapped_stream, char[] bytes)\n```\n```c3\nfn String WriteBuffer.str_view(&self) @inline\n```\n```c3\nfn usz? WriteBuffer.write(&self, char[] bytes) @dynamic\n```\n```c3\nfn void? WriteBuffer.write_byte(&self, char c) @dynamic\n```\n```c3\nfn usz? available(InStream s)\n```\n```c3\nfn char[]? bprintf(char[] buffer, String format, args...) @maydiscard\n```\n```c3\nfn usz? copy_to(InStream in, OutStream dst, char[] buffer = {})\n```\n```c3\nmacro void eprint(x)\n```\n```c3\nfn usz? eprintf(String format, args...) @maydiscard\n```\n```c3\nfn usz? eprintfn(String format, args...) @maydiscard\n```\n```c3\nmacro void eprintn(x)\n```\n```c3\nmacro usz? fprint(out, x)\n```\n```c3\nfn usz? fprintf(OutStream out, String format, args...)\n```\n```c3\nfn usz? fprintfn(OutStream out, String format, args...) @maydiscard\n```\n```c3\nmacro usz? fprintn(out, x = \"\")\n```\n```c3\nmacro void print(x)\n```\n```c3\nfn usz? printf(String format, args...) @maydiscard\n```\n```c3\nfn usz? printfn(String format, args...) @maydiscard\n```\n```c3\nmacro void printn(x = \"\")\n```\n```c3\nmacro usz? read_all(stream, char[] buffer)\n```\n```c3\nmacro usz? read_any(stream, any ref)\n```\n```c3\nmacro usz? read_varint(stream, x_ptr)\n```\n```c3\nmacro String? readline(stream = io::stdin(), Allocator allocator = allocator::heap())\n```\n```c3\nmacro String? treadline(stream = io::stdin())\n```\n```c3\nmacro usz? write_all(stream, char[] buffer)\n```\n```c3\nmacro usz? write_any(stream, any ref)\n```\n```c3\nmacro usz? write_varint(stream, x)\n```\n### `std::io @if (env::LIBC)`\n```c3\nfn void putchar(char c) @inline\n```\n```c3\nfn File* stderr()\n```\n```c3\nfn File* stdin()\n```\n```c3\nfn File* stdout()\n```\n### `std::io @if(!env::LIBC)`\n```c3\nfn void putchar(char c) @inline\n```\n```c3\nfn File* stderr()\n```\n```c3\nfn File* stdin()\n```\n```c3\nfn File* stdout()\n```\n### `std::io::file`\n```c3\nfn void? File.close(&self) @inline @dynamic\n```\n```c3\nfn bool File.eof(&self) @inline\n```\n```c3\nfn void? File.flush(&self) @dynamic\n```\n```c3\nfn void? File.memopen(File* file, char[] data, String mode)\n```\n```c3\nfn usz? File.read(&self, char[] buffer) @dynamic\n```\n```c3\nfn char? File.read_byte(&self) @dynamic\n```\n```c3\nfn void? File.reopen(&self, String filename, String mode)\n```\n```c3\nfn usz? File.seek(&self, isz offset, Seek seek_mode = Seek.SET) @dynamic\n```\n```c3\nfn usz? File.write(&self, char[] buffer) @dynamic\n```\n```c3\nfn void? File.write_byte(&self, char c) @dynamic\n```\n```c3\nfn void? delete(String filename)\n```\n```c3\nfn File from_handle(CFile file)\n```\n```c3\nfn usz? get_size(String path)\n```\n```c3\nfn bool is_file(String path)\n```\n```c3\nfn char[]? load_buffer(String filename, char[] buffer)\n```\n```c3\nfn char[]? load_new(String filename, Allocator allocator = allocator::heap())\n```\n```c3\nfn char[]? load_temp(String filename)\n```\n```c3\nfn File? open(String filename, String mode)\n```\n```c3\nfn File? open_path(Path path, String mode)\n```\n### `std::io::os`\n```c3\nmacro String? getcwd(Allocator allocator = allocator::heap())\n```\n```c3\nmacro void? native_chdir(Path path)\n```\n```c3\nfn bool native_file_or_dir_exists(String path)\n```\n```c3\nfn usz? native_file_size(String path) @if(!env::WIN32 && !env::DARWIN)\n```\n```c3\nfn usz? native_file_size(String path) @if(env::DARWIN)\n```\n```c3\nfn usz? native_file_size(String path) @if(env::WIN32)\n```\n```c3\nfn bool native_is_dir(String path)\n```\n```c3\nfn bool native_is_file(String path)\n```\n```c3\nmacro bool? native_mkdir(Path path, MkdirPermissions permissions)\n```\n```c3\nmacro bool? native_rmdir(Path path)\n```\n```c3\nfn void? native_stat(Stat* stat, String path) @if(env::DARWIN || env::LINUX)\n```\n### `std::io::os @if(env::LIBC)`\n```c3\nfn void*? native_fopen(String filename, String mode) @inline\n```\n```c3\nfn usz? native_fread(CFile file, char[] buffer) @inline\n```\n```c3\nfn void*? native_freopen(void* file, String filename, String mode) @inline\n```\n```c3\nfn void? native_fseek(void* file, isz offset, Seek seek_mode) @inline\n```\n```c3\nfn usz? native_ftell(CFile file) @inline\n```\n```c3\nfn usz? native_fwrite(CFile file, char[] buffer) @inline\n```\n```c3\nfn void? native_remove(String filename)\n```\n```c3\nfn Path? native_temp_directory(Allocator allocator = allocator::heap()) @if(!env::WIN32)\n```\n```c3\nfn Path? native_temp_directory(Allocator allocator = allocator::heap()) @if(env::WIN32)\n```\n### `std::io::os @if(env::NO_LIBC)`\n```c3\nfn void*? native_fopen(String filename, String mode) @inline\n```\n```c3\nfn usz? native_fread(CFile file, char[] buffer) @inline\n```\n```c3\nfn void*? native_freopen(void* file, String filename, String mode) @inline\n```\n```c3\nfn void? native_fseek(void* file, isz offset, Seek seek_mode) @inline\n```\n```c3\nfn usz? native_ftell(CFile file) @inline\n```\n```c3\nfn usz? native_fwrite(CFile file, char[] buffer) @inline\n```\n```c3\nfn void? native_remove(String filename) @inline\n```\n```c3\nmacro Path? native_temp_directory(Allocator allocator = allocator::heap())\n```\n### `std::io::os @if(env::POSIX)`\n```c3\nfn PathList? native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\n```\n```c3\nfn void? native_rmtree(Path dir)\n```\n### `std::io::os @if(env::WIN32)`\n```c3\nfn PathList? native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\n```\n```c3\nfn void? native_rmtree(Path path)\n```\n### `std::io::path`\n```c3\nenum MkdirPermissions\n```\n```c3\nenum PathEnv\n```\n```c3\nfault PathResult\n```\n```c3\nstruct Path (Printable)\n```\n```c3\nfn Path? Path.absolute(self, Allocator allocator = allocator::heap())\n```\n```c3\nfn Path? Path.append(self, String filename, Allocator allocator = allocator::heap())\n```\n```c3\nfn ZString Path.as_zstr(self)\n```\n```c3\nfn String Path.basename(self)\n```\n```c3\nfn String Path.dirname(self)\n```\n```c3\nfn bool Path.equals(self, Path p2)\n```\n```c3\nfn String? Path.extension(self)\n```\n```c3\nfn void Path.free(self)\n```\n```c3\nfn bool Path.has_suffix(self, String str)\n```\n```c3\nfn bool? Path.is_absolute(self)\n```\n```c3\nfn Path? Path.parent(self)\n```\n```c3\nfn String Path.root_directory(self)\n```\n```c3\nfn String Path.str_view(self) @inline\n```\n```c3\nfn Path? Path.tappend(self, String filename)\n```\n```c3\nfn usz? Path.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn String Path.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn String Path.volume_name(self)\n```\n```c3\nfn bool? Path.walk(self, PathWalker w, void* data)\n```\n```c3\nfn void? chdir(Path path)\n```\n```c3\nfn void? delete(Path path)\n```\n```c3\nfn bool exists(Path path)\n```\n```c3\nfn usz? file_size(Path path)\n```\n```c3\nfn Path? getcwd(Allocator allocator = allocator::heap())\n```\n```c3\nfn bool is_dir(Path path)\n```\n```c3\nfn bool is_file(Path path)\n```\n```c3\nmacro bool is_posix_separator(char c)\n```\n```c3\nmacro bool is_reserved_path_char(char c, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n```c3\nmacro bool is_reserved_win32_path_char(char c)\n```\n```c3\nmacro bool is_separator(char c, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n```c3\nmacro bool is_win32_separator(char c)\n```\n```c3\nfn PathList? ls(Path dir, bool no_dirs = false, bool no_symlinks = false, String mask = \"\", Allocator allocator = allocator::heap())\n```\n```c3\nfn bool? mkdir(Path path, bool recursive = false, MkdirPermissions permissions = NORMAL)\n```\n```c3\nfn Path? new(String path, Allocator allocator = allocator::heap(), PathEnv path_env = DEFAULT_PATH_ENV)\n```\n```c3\nfn Path? new_posix(String path, Allocator allocator = allocator::heap())\n```\n```c3\nfn Path? new_win32_wstring(WString path, Allocator allocator = allocator::heap())\n```\n```c3\nfn Path? new_windows(String path, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? normalize(String path_str, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n```c3\nfn bool? rmdir(Path path)\n```\n```c3\nfn void? rmtree(Path path)\n```\n```c3\nfn Path? temp_directory(Allocator allocator = allocator::heap())\n```\n```c3\nfn Path? tnew(String path, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n```c3\nfn Path? tgetcwd()\n```\n### `std::math`\n```c3\nenum RoundingMode : int\n```\n```c3\nfault MathError\n```\n```c3\nfault MatrixError\n```\n```c3\nfn int128 __ashlti3(int128 a, uint b) @extern(\"__ashlti3\") @weak @nostrip\n```\n```c3\nfn int128 __ashrti3(int128 a, uint b) @extern(\"__ashrti3\") @weak @nostrip\n```\n```c3\nfn int128 __divti3(int128 a, int128 b) @extern(\"__divti3\") @weak @nostrip\n```\n```c3\nfn int128 __fixdfti(double a) @weak @extern(\"__fixdfti\") @nostrip\n```\n```c3\nfn int128 __fixsfti(float a) @weak @extern(\"__fixsfti\") @nostrip\n```\n```c3\nfn uint128 __fixunsdfti(double a) @weak @extern(\"__fixunsdfti\") @nostrip\n```\n```c3\nfn uint128 __fixunssfti(float a) @weak @extern(\"__fixunssfti\") @nostrip\n```\n```c3\nfn double __floattidf(int128 a) @extern(\"__floattidf\") @weak @nostrip\n```\n```c3\nfn float __floattisf(int128 a) @extern(\"__floattisf\") @weak @nostrip\n```\n```c3\nfn double __floatuntidf(uint128 a) @extern(\"__floatuntidf\") @weak @nostrip\n```\n```c3\nfn float __floatuntisf(uint128 a) @extern(\"__floatuntisf\") @weak @nostrip\n```\n```c3\nfn uint128 __lshrti3(uint128 a, uint b) @extern(\"__lshrti3\") @weak @nostrip\n```\n```c3\nfn int128 __modti3(int128 a, int128 b) @extern(\"__modti3\") @weak @nostrip\n```\n```c3\nfn int128 __multi3(int128 a, int128 b) @extern(\"__multi3\") @weak @nostrip\n```\n```c3\nfn double __roundeven(double d) @extern(\"roundeven\") @weak @nostrip\n```\n```c3\nfn float __roundevenf(float f) @extern(\"roundevenf\") @weak @nostrip\n```\n```c3\nfn uint128 __udivti3(uint128 n, uint128 d) @extern(\"__udivti3\") @weak @nostrip\n```\n```c3\nfn uint128 __umodti3(uint128 n, uint128 d) @extern(\"__umodti3\") @weak @nostrip\n```\n```c3\nfn double _frexp(double x, int* e)\n```\n```c3\nfn float _frexpf(float x, int* e)\n```\n```c3\nmacro abs(x)\n```\n```c3\nmacro acos(x)\n```\n```c3\nmacro acosh(x)\n```\n```c3\nmacro asin(x)\n```\n```c3\nmacro asinh(x)\n```\n```c3\nmacro atan(x)\n```\n```c3\nmacro atan2(x, y)\n```\n```c3\nmacro atanh(x)\n```\n```c3\nmacro bool bool[<*>].and(bool[<*>] x)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_eq(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_ge(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_gt(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_le(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_lt(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool[<*>] bool[<*>].comp_ne(bool[<*>] x, bool[<*>] y)\n```\n```c3\nmacro bool bool[<*>].max(bool[<*>] x)\n```\n```c3\nmacro bool bool[<*>].min(bool[<*>] x)\n```\n```c3\nmacro bool bool[<*>].or(bool[<*>] x)\n```\n```c3\nmacro bool bool[<*>].product(bool[<*>] x)\n```\n```c3\nmacro bool bool[<*>].sum(bool[<*>] x)\n```\n```c3\nmacro bool bool[<*>].xor(bool[<*>] x)\n```\n```c3\nmacro ceil(x)\n```\n```c3\nmacro bool char.is_even(char x)\n```\n```c3\nmacro bool char.is_odd(char x)\n```\n```c3\nmacro char? char.overflow_add(char x, char y)\n```\n```c3\nmacro char? char.overflow_mul(char x, char y)\n```\n```c3\nmacro char? char.overflow_sub(char x, char y)\n```\n```c3\nmacro char char.sat_add(char x, char y)\n```\n```c3\nmacro char char.sat_mul(char x, char y)\n```\n```c3\nmacro char char.sat_shl(char x, char y)\n```\n```c3\nmacro char char.sat_sub(char x, char y)\n```\n```c3\nmacro char char[<*>].and(char[<*>] x)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_eq(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_ge(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_gt(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_le(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_lt(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro bool[<*>] char[<*>].comp_ne(char[<*>] x, char[<*>] y)\n```\n```c3\nmacro char char[<*>].max(char[<*>] x)\n```\n```c3\nmacro char char[<*>].min(char[<*>] x)\n```\n```c3\nmacro char char[<*>].or(char[<*>] x)\n```\n```c3\nmacro char char[<*>].product(char[<*>] x)\n```\n```c3\nmacro char char[<*>].sum(char[<*>] x)\n```\n```c3\nmacro char char[<*>].xor(char[<*>] x)\n```\n```c3\nmacro clamp(x, lower, upper)\n```\n```c3\nmacro copysign(mag, sgn)\n```\n```c3\nmacro cos(x)\n```\n```c3\nmacro cosec(x)\n```\n```c3\nmacro cosech(x)\n```\n```c3\nmacro cosh(x)\n```\n```c3\nmacro cotan(x)\n```\n```c3\nmacro cotanh(x)\n```\n```c3\nmacro deg_to_rad(x)\n```\n```c3\nmacro double double.ceil(double x)\n```\n```c3\nmacro double double.clamp(double x, double lower, double upper)\n```\n```c3\nmacro double double.copysign(double mag, double sgn)\n```\n```c3\nmacro double double.floor(double x)\n```\n```c3\nmacro double double.fma(double a, double b, double c)\n```\n```c3\nmacro uint double.high_word(double d)\n```\n```c3\nmacro uint double.low_word(double d)\n```\n```c3\nmacro double double.muladd(double a, double b, double c)\n```\n```c3\nmacro double double.nearbyint(double x)\n```\n```c3\nmacro double double.pow(double x, exp)\n```\n```c3\nmacro double double.rint(double x)\n```\n```c3\nmacro double double.round(double x)\n```\n```c3\nmacro double double.roundeven(double x)\n```\n```c3\nmacro double double.trunc(double x)\n```\n```c3\nmacro double[<*>] double[<*>].ceil(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].clamp(double[<*>] x, double[<*>] lower, double[<*>] upper)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_eq(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_ge(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_gt(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_le(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_lt(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool[<*>] double[<*>].comp_ne(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro double[<*>] double[<*>].copysign(double[<*>] mag, double[<*>] sgn)\n```\n```c3\nmacro double double[<*>].distance(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro double double[<*>].dot(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro bool double[<*>].equals(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro double[<*>] double[<*>].floor(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].fma(double[<*>] a, double[<*>] b, double[<*>] c)\n```\n```c3\nmacro double double[<*>].length(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].lerp(double[<*>] x, double[<*>] y, double amount)\n```\n```c3\nmacro double double[<*>].max(double[<*>] x)\n```\n```c3\nmacro double double[<*>].min(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].nearbyint(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].normalize(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].pow(double[<*>] x, exp)\n```\n```c3\nmacro double double[<*>].product(double[<*>] x, double start = 1.0)\n```\n```c3\nmacro double[<*>] double[<*>].reflect(double[<*>] x, double[<*>] y)\n```\n```c3\nmacro double[<*>] double[<*>].rint(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].round(double[<*>] x)\n```\n```c3\nmacro double[<*>] double[<*>].roundeven(double[<*>] x)\n```\n```c3\nmacro double double[<*>].sum(double[<*>] x, double start = 0.0)\n```\n```c3\nmacro double[<*>] double[<*>].trunc(double[<*>] x)\n```\n```c3\nmacro exp(x)\n```\n```c3\nmacro exp2(x)\n```\n```c3\nmacro float float.ceil(float x)\n```\n```c3\nmacro float float.clamp(float x, float lower, float upper)\n```\n```c3\nmacro float float.copysign(float mag, float sgn)\n```\n```c3\nmacro float float.floor(float x)\n```\n```c3\nmacro float float.fma(float a, float b, float c)\n```\n```c3\nmacro float float.muladd(float a, float b, float c)\n```\n```c3\nmacro float float.nearbyint(float x)\n```\n```c3\nmacro float float.pow(float x, exp)\n```\n```c3\nmacro float float.rint(float x)\n```\n```c3\nmacro float float.round(float x)\n```\n```c3\nmacro float float.roundeven(float x)\n```\n```c3\nmacro float float.trunc(float x)\n```\n```c3\nmacro uint float.word(float d)\n```\n```c3\nmacro float[<*>] float[<*>].ceil(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].clamp(float[<*>] x, float[<*>] lower, float[<*>] upper)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_eq(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_ge(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_gt(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_le(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_lt(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool[<*>] float[<*>].comp_ne(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro float[<*>] float[<*>].copysign(float[<*>] mag, float[<*>] sgn)\n```\n```c3\nmacro float float[<*>].distance(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro float float[<*>].dot(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro bool float[<*>].equals(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro float[<*>] float[<*>].floor(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].fma(float[<*>] a, float[<*>] b, float[<*>] c)\n```\n```c3\nmacro float float[<*>].length(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].lerp(float[<*>] x, float[<*>] y, float amount)\n```\n```c3\nmacro float float[<*>].max(float[<*>] x)\n```\n```c3\nmacro float float[<*>].min(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].nearbyint(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].normalize(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].pow(float[<*>] x, exp)\n```\n```c3\nmacro float float[<*>].product(float[<*>] x, float start = 1.0)\n```\n```c3\nmacro float[<*>] float[<*>].reflect(float[<*>] x, float[<*>] y)\n```\n```c3\nmacro float[<*>] float[<*>].rint(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].round(float[<*>] x)\n```\n```c3\nmacro float[<*>] float[<*>].roundeven(float[<*>] x)\n```\n```c3\nmacro float float[<*>].sum(float[<*>] x, float start = 0.0)\n```\n```c3\nmacro float[<*>] float[<*>].trunc(float[<*>] x)\n```\n```c3\nmacro floor(x)\n```\n```c3\nmacro fma(a, b, c)\n```\n```c3\nmacro frexp(x, int* e)\n```\n```c3\nmacro hypot(x, y)\n```\n```c3\nmacro bool ichar.is_even(ichar x)\n```\n```c3\nmacro bool ichar.is_odd(ichar x)\n```\n```c3\nmacro ichar? ichar.overflow_add(ichar x, ichar y)\n```\n```c3\nmacro ichar? ichar.overflow_mul(ichar x, ichar y)\n```\n```c3\nmacro ichar? ichar.overflow_sub(ichar x, ichar y)\n```\n```c3\nmacro ichar ichar.sat_add(ichar x, ichar y)\n```\n```c3\nmacro ichar ichar.sat_mul(ichar x, ichar y)\n```\n```c3\nmacro ichar ichar.sat_shl(ichar x, ichar y)\n```\n```c3\nmacro ichar ichar.sat_sub(ichar x, ichar y)\n```\n```c3\nmacro ichar ichar[<*>].and(ichar[<*>] x)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_eq(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_ge(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_gt(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_le(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_lt(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro bool[<*>] ichar[<*>].comp_ne(ichar[<*>] x, ichar[<*>] y)\n```\n```c3\nmacro ichar ichar[<*>].max(ichar[<*>] x)\n```\n```c3\nmacro ichar ichar[<*>].min(ichar[<*>] x)\n```\n```c3\nmacro ichar ichar[<*>].or(ichar[<*>] x)\n```\n```c3\nmacro ichar ichar[<*>].product(ichar[<*>] x)\n```\n```c3\nmacro ichar ichar[<*>].sum(ichar[<*>] x)\n```\n```c3\nmacro ichar ichar[<*>].xor(ichar[<*>] x)\n```\n```c3\nmacro bool int.is_even(int x)\n```\n```c3\nmacro bool int.is_odd(int x)\n```\n```c3\nmacro int? int.overflow_add(int x, int y)\n```\n```c3\nmacro int? int.overflow_mul(int x, int y)\n```\n```c3\nmacro int? int.overflow_sub(int x, int y)\n```\n```c3\nmacro int int.sat_add(int x, int y)\n```\n```c3\nmacro int int.sat_mul(int x, int y)\n```\n```c3\nmacro int int.sat_shl(int x, int y)\n```\n```c3\nmacro int int.sat_sub(int x, int y)\n```\n```c3\nmacro bool int128.is_even(int128 x)\n```\n```c3\nmacro bool int128.is_odd(int128 x)\n```\n```c3\nmacro int128? int128.overflow_add(int128 x, int128 y)\n```\n```c3\nmacro int128? int128.overflow_mul(int128 x, int128 y)\n```\n```c3\nmacro int128? int128.overflow_sub(int128 x, int128 y)\n```\n```c3\nmacro int128 int128.sat_add(int128 x, int128 y)\n```\n```c3\nmacro int128 int128.sat_mul(int128 x, int128 y)\n```\n```c3\nmacro int128 int128.sat_shl(int128 x, int128 y)\n```\n```c3\nmacro int128 int128.sat_sub(int128 x, int128 y)\n```\n```c3\nmacro int128 int128[<*>].and(int128[<*>] x)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_eq(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_ge(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_gt(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_le(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_lt(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro bool[<*>] int128[<*>].comp_ne(int128[<*>] x, int128[<*>] y)\n```\n```c3\nmacro int128 int128[<*>].max(int128[<*>] x)\n```\n```c3\nmacro int128 int128[<*>].min(int128[<*>] x)\n```\n```c3\nmacro int128 int128[<*>].or(int128[<*>] x)\n```\n```c3\nmacro int128 int128[<*>].product(int128[<*>] x)\n```\n```c3\nmacro int128 int128[<*>].sum(int128[<*>] x)\n```\n```c3\nmacro int128 int128[<*>].xor(int128[<*>] x)\n```\n```c3\nmacro int int[<*>].and(int[<*>] x)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_eq(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_ge(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_gt(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_le(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_lt(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro bool[<*>] int[<*>].comp_ne(int[<*>] x, int[<*>] y)\n```\n```c3\nmacro int int[<*>].max(int[<*>] x)\n```\n```c3\nmacro int int[<*>].min(int[<*>] x)\n```\n```c3\nmacro int int[<*>].or(int[<*>] x)\n```\n```c3\nmacro int int[<*>].product(int[<*>] x)\n```\n```c3\nmacro int int[<*>].sum(int[<*>] x)\n```\n```c3\nmacro int int[<*>].xor(int[<*>] x)\n```\n```c3\nmacro bool is_even(x)\n```\n```c3\nmacro bool is_finite(x)\n```\n```c3\nmacro is_inf(x)\n```\n```c3\nmacro is_nan(x)\n```\n```c3\nmacro bool is_odd(x)\n```\n```c3\nmacro bool is_power_of_2(x)\n```\n```c3\nmacro ln(x)\n```\n```c3\nmacro log(x, base)\n```\n```c3\nmacro log10(x)\n```\n```c3\nmacro log2(x)\n```\n```c3\nmacro bool long.is_even(long x)\n```\n```c3\nmacro bool long.is_odd(long x)\n```\n```c3\nmacro long? long.overflow_add(long x, long y)\n```\n```c3\nmacro long? long.overflow_mul(long x, long y)\n```\n```c3\nmacro long? long.overflow_sub(long x, long y)\n```\n```c3\nmacro long long.sat_add(long x, long y)\n```\n```c3\nmacro long long.sat_mul(long x, long y)\n```\n```c3\nmacro long long.sat_shl(long x, long y)\n```\n```c3\nmacro long long.sat_sub(long x, long y)\n```\n```c3\nmacro long long[<*>].and(long[<*>] x)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_eq(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_ge(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_gt(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_le(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_lt(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro bool[<*>] long[<*>].comp_ne(long[<*>] x, long[<*>] y)\n```\n```c3\nmacro long long[<*>].max(long[<*>] x)\n```\n```c3\nmacro long long[<*>].min(long[<*>] x)\n```\n```c3\nmacro long long[<*>].or(long[<*>] x)\n```\n```c3\nmacro long long[<*>].product(long[<*>] x)\n```\n```c3\nmacro long long[<*>].sum(long[<*>] x)\n```\n```c3\nmacro long long[<*>].xor(long[<*>] x)\n```\n```c3\nmacro max(x, y, ...)\n```\n```c3\nmacro min(x, y, ...)\n```\n```c3\nmacro muladd(a, b, c)\n```\n```c3\nmacro nearbyint(x)\n```\n```c3\nmacro next_power_of_2(x)\n```\n```c3\nmacro pow(x, exp)\n```\n```c3\nmacro rint(x)\n```\n```c3\nmacro round(x)\n```\n```c3\nmacro round_to_decimals(x, int decimal_places)\n```\n```c3\nmacro roundeven(x)\n```\n```c3\nmacro double scalbn(double x, int n)\n```\n```c3\nmacro sec(x)\n```\n```c3\nmacro sech(x)\n```\n```c3\nmacro select(bool[<*>] mask, then_value, else_value)\n```\n```c3\nmacro bool short.is_even(short x)\n```\n```c3\nmacro bool short.is_odd(short x)\n```\n```c3\nmacro short? short.overflow_add(short x, short y)\n```\n```c3\nmacro short? short.overflow_mul(short x, short y)\n```\n```c3\nmacro short? short.overflow_sub(short x, short y)\n```\n```c3\nmacro short short.sat_add(short x, short y)\n```\n```c3\nmacro short short.sat_mul(short x, short y)\n```\n```c3\nmacro short short.sat_shl(short x, short y)\n```\n```c3\nmacro short short.sat_sub(short x, short y)\n```\n```c3\nmacro short short[<*>].and(short[<*>] x)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_eq(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_ge(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_gt(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_le(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_lt(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro bool[<*>] short[<*>].comp_ne(short[<*>] x, short[<*>] y)\n```\n```c3\nmacro short short[<*>].max(short[<*>] x)\n```\n```c3\nmacro short short[<*>].min(short[<*>] x)\n```\n```c3\nmacro short short[<*>].or(short[<*>] x)\n```\n```c3\nmacro short short[<*>].product(short[<*>] x)\n```\n```c3\nmacro short short[<*>].sum(short[<*>] x)\n```\n```c3\nmacro short short[<*>].xor(short[<*>] x)\n```\n```c3\nmacro sign(x)\n```\n```c3\nmacro int signbit(x)\n```\n```c3\nmacro sin(x)\n```\n```c3\nmacro sincos(x, y)\n```\n```c3\nmacro sinh(x)\n```\n```c3\nmacro sqr(x)\n```\n```c3\nmacro sqrt(x)\n```\n```c3\nmacro tan(x)\n```\n```c3\nmacro tanh(x)\n```\n```c3\nmacro trunc(x)\n```\n```c3\nmacro bool uint.is_even(uint x)\n```\n```c3\nmacro bool uint.is_odd(uint x)\n```\n```c3\nmacro uint? uint.overflow_add(uint x, uint y)\n```\n```c3\nmacro uint? uint.overflow_mul(uint x, uint y)\n```\n```c3\nmacro uint? uint.overflow_sub(uint x, uint y)\n```\n```c3\nmacro uint uint.sat_add(uint x, uint y)\n```\n```c3\nmacro uint uint.sat_mul(uint x, uint y)\n```\n```c3\nmacro uint uint.sat_shl(uint x, uint y)\n```\n```c3\nmacro uint uint.sat_sub(uint x, uint y)\n```\n```c3\nmacro bool uint128.is_even(uint128 x)\n```\n```c3\nmacro bool uint128.is_odd(uint128 x)\n```\n```c3\nmacro uint128? uint128.overflow_add(uint128 x, uint128 y)\n```\n```c3\nmacro uint128? uint128.overflow_mul(uint128 x, uint128 y)\n```\n```c3\nmacro uint128? uint128.overflow_sub(uint128 x, uint128 y)\n```\n```c3\nmacro uint128 uint128.sat_add(uint128 x, uint128 y)\n```\n```c3\nmacro uint128 uint128.sat_mul(uint128 x, uint128 y)\n```\n```c3\nmacro uint128 uint128.sat_shl(uint128 x, uint128 y)\n```\n```c3\nmacro uint128 uint128.sat_sub(uint128 x, uint128 y)\n```\n```c3\nmacro uint128 uint128[<*>].and(uint128[<*>] x)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_eq(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_ge(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_gt(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_le(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_lt(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro bool[<*>] uint128[<*>].comp_ne(uint128[<*>] x, uint128[<*>] y)\n```\n```c3\nmacro uint128 uint128[<*>].max(uint128[<*>] x)\n```\n```c3\nmacro uint128 uint128[<*>].min(uint128[<*>] x)\n```\n```c3\nmacro uint128 uint128[<*>].or(uint128[<*>] x)\n```\n```c3\nmacro uint128 uint128[<*>].product(uint128[<*>] x)\n```\n```c3\nmacro uint128 uint128[<*>].sum(uint128[<*>] x)\n```\n```c3\nmacro uint128 uint128[<*>].xor(uint128[<*>] x)\n```\n```c3\nmacro uint uint[<*>].and(uint[<*>] x)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_eq(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_ge(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_gt(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_le(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_lt(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro bool[<*>] uint[<*>].comp_ne(uint[<*>] x, uint[<*>] y)\n```\n```c3\nmacro uint uint[<*>].max(uint[<*>] x)\n```\n```c3\nmacro uint uint[<*>].min(uint[<*>] x)\n```\n```c3\nmacro uint uint[<*>].or(uint[<*>] x)\n```\n```c3\nmacro uint uint[<*>].product(uint[<*>] x)\n```\n```c3\nmacro uint uint[<*>].sum(uint[<*>] x)\n```\n```c3\nmacro uint uint[<*>].xor(uint[<*>] x)\n```\n```c3\nmacro bool ulong.is_even(ulong x)\n```\n```c3\nmacro bool ulong.is_odd(ulong x)\n```\n```c3\nmacro ulong? ulong.overflow_add(ulong x, ulong y)\n```\n```c3\nmacro ulong? ulong.overflow_mul(ulong x, ulong y)\n```\n```c3\nmacro ulong? ulong.overflow_sub(ulong x, ulong y)\n```\n```c3\nmacro ulong ulong.sat_add(ulong x, ulong y)\n```\n```c3\nmacro ulong ulong.sat_mul(ulong x, ulong y)\n```\n```c3\nmacro ulong ulong.sat_shl(ulong x, ulong y)\n```\n```c3\nmacro ulong ulong.sat_sub(ulong x, ulong y)\n```\n```c3\nmacro ulong ulong[<*>].and(ulong[<*>] x)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_eq(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_ge(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_gt(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_le(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_lt(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro bool[<*>] ulong[<*>].comp_ne(ulong[<*>] x, ulong[<*>] y)\n```\n```c3\nmacro ulong ulong[<*>].max(ulong[<*>] x)\n```\n```c3\nmacro ulong ulong[<*>].min(ulong[<*>] x)\n```\n```c3\nmacro ulong ulong[<*>].or(ulong[<*>] x)\n```\n```c3\nmacro ulong ulong[<*>].product(ulong[<*>] x)\n```\n```c3\nmacro ulong ulong[<*>].sum(ulong[<*>] x)\n```\n```c3\nmacro ulong ulong[<*>].xor(ulong[<*>] x)\n```\n```c3\nmacro bool ushort.is_even(ushort x)\n```\n```c3\nmacro bool ushort.is_odd(ushort x)\n```\n```c3\nmacro ushort? ushort.overflow_add(ushort x, ushort y)\n```\n```c3\nmacro ushort? ushort.overflow_mul(ushort x, ushort y)\n```\n```c3\nmacro ushort? ushort.overflow_sub(ushort x, ushort y)\n```\n```c3\nmacro ushort ushort.sat_add(ushort x, ushort y)\n```\n```c3\nmacro ushort ushort.sat_mul(ushort x, ushort y)\n```\n```c3\nmacro ushort ushort.sat_shl(ushort x, ushort y)\n```\n```c3\nmacro ushort ushort.sat_sub(ushort x, ushort y)\n```\n```c3\nmacro ushort ushort[<*>].and(ushort[<*>] x)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_eq(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_ge(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_gt(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_le(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_lt(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro bool[<*>] ushort[<*>].comp_ne(ushort[<*>] x, ushort[<*>] y)\n```\n```c3\nmacro ushort ushort[<*>].max(ushort[<*>] x)\n```\n```c3\nmacro ushort ushort[<*>].min(ushort[<*>] x)\n```\n```c3\nmacro ushort ushort[<*>].or(ushort[<*>] x)\n```\n```c3\nmacro ushort ushort[<*>].product(ushort[<*>] x)\n```\n```c3\nmacro ushort ushort[<*>].sum(ushort[<*>] x)\n```\n```c3\nmacro ushort ushort[<*>].xor(ushort[<*>] x)\n```\n### `std::math::complex(&lt;Real&gt;)`\n```c3\nmacro Complex Complex.add(self, Complex b)\n```\n```c3\nmacro Complex Complex.add_each(self, Real b)\n```\n```c3\nmacro Complex Complex.div(self, Complex b)\n```\n```c3\nmacro Complex Complex.mul(self, Complex b)\n```\n```c3\nmacro Complex Complex.scale(self, Real s)\n```\n```c3\nmacro Complex Complex.sub(self, Complex b)\n```\n```c3\nmacro Complex Complex.sub_each(self, Real b)\n```\n### `std::math::easing`\n```c3\nfn float back_in(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n```c3\nfn float back_inout(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n```c3\nfn float back_out(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n```c3\nfn float bounce_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float bounce_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float bounce_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float circ_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float circ_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float circ_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float cubic_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float cubic_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float cubic_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float elastic_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float elastic_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float elastic_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float expo_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float expo_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float expo_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float linear_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float linear_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float linear_none(float t, float b, float c, float d) @inline\n```\n```c3\nfn float linear_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float quad_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float quad_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float quad_out(float t, float b, float c, float d) @inline\n```\n```c3\nfn float sine_in(float t, float b, float c, float d) @inline\n```\n```c3\nfn float sine_inout(float t, float b, float c, float d) @inline\n```\n```c3\nfn float sine_out(float t, float b, float c, float d) @inline\n```\n### `std::math::matrix(&lt;Real&gt;)`\n```c3\nstruct Matrix2x2\n```\n```c3\nstruct Matrix3x3\n```\n```c3\nstruct Matrix4x4\n```\n```c3\nfn Matrix2x2 Matrix2x2.add(&self, Matrix2x2 mat2)\n```\n```c3\nfn Matrix2x2 Matrix2x2.adjoint(&self)\n```\n```c3\nfn Real[<2>] Matrix2x2.apply(&self, Real[<2>] vec)\n```\n```c3\nfn Matrix2x2 Matrix2x2.component_mul(&self, Real s)\n```\n```c3\nfn Real Matrix2x2.determinant(&self)\n```\n```c3\nfn Matrix2x2? Matrix2x2.inverse(&self)\n```\n```c3\nfn Matrix2x2 Matrix2x2.mul(&self, Matrix2x2 b)\n```\n```c3\nfn Matrix2x2 Matrix2x2.sub(&self, Matrix2x2 mat2)\n```\n```c3\nfn Real Matrix2x2.trace(&self)\n```\n```c3\nfn Matrix2x2 Matrix2x2.transpose(&self)\n```\n```c3\nfn Matrix3x3 Matrix3x3.add(&self, Matrix3x3 mat2)\n```\n```c3\nfn Matrix3x3 Matrix3x3.adjoint(&self)\n```\n```c3\nfn Real[<3>] Matrix3x3.apply(&self, Real[<3>] vec)\n```\n```c3\nfn Matrix3x3 Matrix3x3.component_mul(&self, Real s)\n```\n```c3\nfn Real Matrix3x3.determinant(&self)\n```\n```c3\nfn Matrix3x3? Matrix3x3.inverse(&self)\n```\n```c3\nfn Matrix3x3 Matrix3x3.mul(&self, Matrix3x3 b)\n```\n```c3\nfn Matrix3x3 Matrix3x3.rotate(&self, Real r)\n```\n```c3\nfn Matrix3x3 Matrix3x3.scale(&self, Real[<2>] v)\n```\n```c3\nfn Matrix3x3 Matrix3x3.sub(&self, Matrix3x3 mat2)\n```\n```c3\nfn Real Matrix3x3.trace(&self)\n```\n```c3\nfn Matrix3x3 Matrix3x3.translate(&self, Real[<2>] v)\n```\n```c3\nfn Matrix3x3 Matrix3x3.transpose(&self)\n```\n```c3\nfn Matrix4x4 Matrix4x4.add(&self, Matrix4x4 mat2)\n```\n```c3\nfn Matrix4x4 Matrix4x4.adjoint(&self)\n```\n```c3\nfn Real[<4>] Matrix4x4.apply(&self, Real[<4>] vec)\n```\n```c3\nfn Matrix4x4 Matrix4x4.component_mul(&self, Real s)\n```\n```c3\nfn Real Matrix4x4.determinant(&self)\n```\n```c3\nfn Matrix4x4? Matrix4x4.inverse(&self)\n```\n```c3\nfn Matrix4x4 Matrix4x4.mul(Matrix4x4* a, Matrix4x4 b)\n```\n```c3\nfn Matrix4x4 Matrix4x4.rotate_x(&self, Real r)\n```\n```c3\nfn Matrix4x4 Matrix4x4.rotate_y(&self, Real r)\n```\n```c3\nfn Matrix4x4 Matrix4x4.rotate_z(&self, Real r)\n```\n```c3\nfn Matrix4x4 Matrix4x4.scale(&self, Real[<3>] v)\n```\n```c3\nfn Matrix4x4 Matrix4x4.sub(&self, Matrix4x4 mat2)\n```\n```c3\nfn Real Matrix4x4.trace(&self)\n```\n```c3\nfn Matrix4x4 Matrix4x4.translate(&self, Real[<3>] v)\n```\n```c3\nfn Matrix4x4 Matrix4x4.transpose(&self)\n```\n```c3\nfn Matrix4x4 ortho(Real left, Real right, Real top, Real bottom, Real near, Real far)\n```\n```c3\nfn Matrix4x4 perspective(Real fov, Real aspect_ratio, Real near, Real far)\n```\n### `std::math::nolibc`\n```c3\nmacro double __math_oflow(ulong sign)\n```\n```c3\nmacro float __math_oflowf(uint sign)\n```\n```c3\nmacro double __math_uflow(ulong sign)\n```\n```c3\nmacro float __math_uflowf(uint sign)\n```\n```c3\nmacro __math_xflow(sign, v)\n```\n```c3\nmacro force_eval_add(x, v)\n```\n### `std::math::nolibc @if(env::NO_LIBC)`\n```c3\nfn double __cos(double x, double y) @extern(\"__cos\") @weak @nostrip\n```\n```c3\nfn float __cosdf(double x) @extern(\"__cosdf\") @weak @nostrip\n```\n```c3\nfn int __rem_pio2(double x, double *y)\n```\n```c3\nfn int __rem_pio2_large(double* x, double* y, int e0, int nx, int prec)\n```\n```c3\nfn int __rem_pio2f(float x, double *y)\n```\n```c3\nfn double __sin(double x, double y, int iy) @extern(\"__sin\") @weak @nostrip\n```\n```c3\nfn float __sindf(double x) @extern(\"__sindf\") @weak @nostrip\n```\n```c3\nfn double __tan(double x, double y, int odd) @extern(\"__tan\") @weak @nostrip\n```\n```c3\nfn float __tandf(double x, int odd) @extern(\"__tandf\") @weak @nostrip\n```\n```c3\nfn double _atan(double x) @weak @extern(\"atan\") @nostrip\n```\n```c3\nfn double _atan2(double y, double x) @weak @extern(\"atan2\") @nostrip\n```\n```c3\nfn float _atan2f(float y, float x) @weak @extern(\"atan2f\") @nostrip\n```\n```c3\nfn float _atanf(float x) @weak @extern(\"atanf\") @nostrip\n```\n```c3\nfn double _ceil(double x) @weak @extern(\"ceil\") @nostrip\n```\n```c3\nfn float _ceilf(float x) @weak @extern(\"ceilf\") @nostrip\n```\n```c3\nfn double _cos(double x) @weak @nostrip\n```\n```c3\nfn float _cosf(float x) @extern(\"cosf\") @weak @nostrip\n```\n```c3\nfn double _exp2(double x) @extern(\"exp2\") @weak @nostrip\n```\n```c3\nfn float _exp2f(float x) @extern(\"exp2f\") @weak @nostrip\n```\n```c3\nfn double _floor(double x) @weak @extern(\"floor\") @nostrip\n```\n```c3\nfn float _floorf(float x) @weak @extern(\"floorf\") @nostrip\n```\n```c3\nfn double _round(double x) @extern(\"round\") @weak @nostrip\n```\n```c3\nfn float _roundf(float x) @extern(\"roundf\") @weak @nostrip\n```\n```c3\nfn double _scalbn(double x, int n) @weak @extern(\"scalbn\") @nostrip\n```\n```c3\nfn float _sinf(float x) @weak @extern(\"sinf\") @nostrip\n```\n```c3\nfn double _trunc(double x) @weak @extern(\"trunc\") @nostrip\n```\n```c3\nfn float _truncf(float x) @weak @extern(\"truncf\") @nostrip\n```\n```c3\nfn double pow_broken(double x, double y) @extern(\"pow\") @weak @nostrip\n```\n```c3\nfn float powf_broken(float x, float f) @extern(\"powf\") @weak @nostrip\n```\n```c3\nfn double sin(double x) @extern(\"sin\") @weak @nostrip\n```\n```c3\nfn void sincos(double x, double *sin, double *cos) @extern(\"sincos\") @weak @nostrip\n```\n```c3\nfn double sincos_broken(double x) @extern(\"sincos\") @weak @nostrip\n```\n```c3\nfn void sincosf(float x, float *sin, float *cos) @extern(\"sincosf\") @weak @nostrip\n```\n```c3\nfn double tan(double x) @extern(\"tan\") @weak @nostrip\n```\n```c3\nfn float tanf(float x) @extern(\"tanf\") @weak @nostrip\n```\n### `std::math::quaternion(&lt;Real&gt;)`\n```c3\nmacro Quaternion Quaternion.add(Quaternion a, Quaternion b)\n```\n```c3\nmacro Quaternion Quaternion.add_each(Quaternion a, Real b)\n```\n```c3\nfn Quaternion Quaternion.invert(q)\n```\n```c3\nmacro Real Quaternion.length(Quaternion q)\n```\n```c3\nmacro Quaternion Quaternion.lerp(Quaternion q1, Quaternion q2, Real amount)\n```\n```c3\nfn Quaternion Quaternion.mul(a, Quaternion b)\n```\n```c3\nfn Quaternion Quaternion.nlerp(Quaternion q1, Quaternion q2, Real amount)\n```\n```c3\nmacro Quaternion Quaternion.normalize(Quaternion q)\n```\n```c3\nmacro Quaternion Quaternion.scale(Quaternion a, Real s)\n```\n```c3\nfn Quaternion Quaternion.slerp(q1, Quaternion q2, Real amount)\n```\n```c3\nmacro Quaternion Quaternion.sub(Quaternion a, Quaternion b)\n```\n```c3\nmacro Quaternion Quaternion.sub_each(Quaternion a, Real b)\n```\n```c3\nmacro Matrix4 Quaternion.to_matrix(Quaternion* q)\n```\n```c3\nmacro Matrix4f Quaternion.to_matrixf(Quaternion* q)\n```\n### `std::math::random`\n```c3\ntypedef Lcg128Random (Random) = uint128;\n```\n```c3\ntypedef Lcg16Random (Random) = ushort;\n```\n```c3\ntypedef Lcg32Random (Random) = uint;\n```\n```c3\ntypedef Lcg64Random (Random) = ulong;\n```\n```c3\ntypedef Mcg128Random (Random) = uint128;\n```\n```c3\ntypedef Mcg16Random (Random) = ushort;\n```\n```c3\ntypedef Mcg32Random (Random) = uint;\n```\n```c3\ntypedef Mcg64Random (Random) = ulong;\n```\n```c3\ntypedef Pcg128Random (Random) = uint128;\n```\n```c3\ntypedef Pcg16Random (Random) = ushort;\n```\n```c3\ntypedef Pcg32Random (Random) = uint;\n```\n```c3\ntypedef Pcg64Random (Random) = ulong;\n```\n```c3\ntypedef Sfc128Random (Random) = uint128[4];\n```\n```c3\ntypedef Sfc16Random (Random) = ushort[4];\n```\n```c3\ntypedef Sfc32Random (Random) = uint[4];\n```\n```c3\ntypedef Sfc64Random (Random) = ulong[4];\n```\n```c3\ntypedef Sfc8Random (Random) = char[4];\n```\n```c3\ntypedef SimpleRandom (Random) = ulong;\n```\n```c3\ninterface Random\n```\n```c3\nstruct Msws128Random (Random)\n```\n```c3\nstruct Msws16Random (Random)\n```\n```c3\nstruct Msws32Random (Random)\n```\n```c3\nstruct Msws64Random (Random)\n```\n```c3\nstruct Msws8Random (Random)\n```\n```c3\nfn void  Msws16Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Msws32Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Msws64Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Msws8Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Pcg128Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Sfc128Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Sfc16Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Sfc32Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Sfc64Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn void  Sfc8Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char[8 * 4] entropy()\n```\n```c3\nmacro ushort @char_to_short(#function)\n```\n```c3\nmacro ulong @int_to_long(#function)\n```\n```c3\nmacro uint128 @long_to_int128(#function)\n```\n```c3\nmacro @random_value_to_bytes(#function, char[] bytes)\n```\n```c3\nmacro uint @short_to_int(#function)\n```\n```c3\nfn char Lcg128Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Lcg128Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Lcg128Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Lcg128Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Lcg128Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Lcg128Random.next_short(&self) @dynamic\n```\n```c3\nfn void Lcg128Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char Lcg16Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Lcg16Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Lcg16Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Lcg16Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Lcg16Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Lcg16Random.next_short(&self) @dynamic\n```\n```c3\nfn void Lcg16Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Lcg32Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Lcg32Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Lcg32Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Lcg32Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Lcg32Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Lcg32Random.next_short(&self) @dynamic\n```\n```c3\nfn void Lcg32Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Lcg64Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Lcg64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Lcg64Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Lcg64Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Lcg64Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Lcg64Random.next_short(&self) @dynamic\n```\n```c3\nfn void Lcg64Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Mcg128Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Mcg128Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Mcg128Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Mcg128Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Mcg128Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Mcg128Random.next_short(&self) @dynamic\n```\n```c3\nfn void Mcg128Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Mcg16Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Mcg16Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Mcg16Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Mcg16Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Mcg16Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Mcg16Random.next_short(&self) @dynamic\n```\n```c3\nfn void Mcg16Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Mcg32Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Mcg32Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Mcg32Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Mcg32Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Mcg32Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Mcg32Random.next_short(&self) @dynamic\n```\n```c3\nfn void Mcg32Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Mcg64Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Mcg64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Mcg64Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Mcg64Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Mcg64Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Mcg64Random.next_short(&self) @dynamic\n```\n```c3\nfn void Mcg64Random.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nfn char Msws128Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Msws128Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Msws128Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Msws128Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Msws128Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Msws128Random.next_short(&self) @dynamic\n```\n```c3\nfn void Msws128Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char Msws16Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Msws16Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Msws16Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Msws16Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Msws16Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Msws16Random.next_short(&self) @dynamic\n```\n```c3\nfn char Msws32Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Msws32Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Msws32Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Msws32Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Msws32Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Msws32Random.next_short(&self) @dynamic\n```\n```c3\nfn char Msws64Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Msws64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Msws64Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Msws64Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Msws64Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Msws64Random.next_short(&self) @dynamic\n```\n```c3\nfn char Msws8Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Msws8Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Msws8Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Msws8Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Msws8Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Msws8Random.next_short(&self) @dynamic\n```\n```c3\nfn char Pcg128Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Pcg128Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Pcg128Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Pcg128Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Pcg128Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Pcg128Random.next_short(&self) @dynamic\n```\n```c3\nfn char Pcg16Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Pcg16Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Pcg16Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Pcg16Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Pcg16Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Pcg16Random.next_short(&self) @dynamic\n```\n```c3\nfn void Pcg16Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char Pcg32Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Pcg32Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Pcg32Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Pcg32Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Pcg32Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Pcg32Random.next_short(&self) @dynamic\n```\n```c3\nfn void Pcg32Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char Pcg64Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Pcg64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Pcg64Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Pcg64Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Pcg64Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Pcg64Random.next_short(&self) @dynamic\n```\n```c3\nfn void Pcg64Random.set_seed(&self, char[] input) @dynamic\n```\n```c3\nfn char Sfc128Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Sfc128Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Sfc128Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Sfc128Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Sfc128Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Sfc128Random.next_short(&self) @dynamic\n```\n```c3\nfn char Sfc16Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Sfc16Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Sfc16Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Sfc16Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Sfc16Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Sfc16Random.next_short(&seed) @dynamic\n```\n```c3\nfn char Sfc32Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Sfc32Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Sfc32Random.next_int(&sfc) @dynamic\n```\n```c3\nfn uint128 Sfc32Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Sfc32Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Sfc32Random.next_short(&self) @dynamic\n```\n```c3\nfn char Sfc64Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Sfc64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Sfc64Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Sfc64Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Sfc64Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Sfc64Random.next_short(&self) @dynamic\n```\n```c3\nfn char Sfc8Random.next_byte(&self) @dynamic\n```\n```c3\nfn void Sfc8Random.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint Sfc8Random.next_int(&self) @dynamic\n```\n```c3\nfn uint128 Sfc8Random.next_int128(&self) @dynamic\n```\n```c3\nfn ulong Sfc8Random.next_long(&self) @dynamic\n```\n```c3\nfn ushort Sfc8Random.next_short(&self) @dynamic\n```\n```c3\nfn char SimpleRandom.next_byte(&self) @dynamic\n```\n```c3\nfn void SimpleRandom.next_bytes(&self, char[] bytes) @dynamic\n```\n```c3\nfn uint SimpleRandom.next_int(&self) @dynamic\n```\n```c3\nfn uint128 SimpleRandom.next_int128(&self) @dynamic\n```\n```c3\nfn ulong SimpleRandom.next_long(&self) @dynamic\n```\n```c3\nfn ushort SimpleRandom.next_short(&self) @dynamic\n```\n```c3\nfn void SimpleRandom.set_seed(&self, char[] seed) @dynamic\n```\n```c3\nmacro bool is_random(random)\n```\n```c3\nmacro make_seed($Type, char[] input)\n```\n```c3\nmacro int next(random, int max)\n```\n```c3\nmacro void next_bool(random)\n```\n```c3\nmacro double next_double(random)\n```\n```c3\nmacro float next_float(random)\n```\n```c3\nfn int rand(int max) @builtin\n```\n```c3\nmacro void seed(random, seed)\n```\n```c3\nmacro void seed_entropy(random)\n```\n```c3\nfn void seeder(char[] input, char[] out_buffer)\n```\n### `std::math::vector`\n```c3\nmacro Vec2.angle(self, Vec2 v2)\n```\n```c3\nmacro Vec2.clamp_mag(self, double min, double max)\n```\n```c3\nmacro Vec2.distance_sq(self, Vec2 v2)\n```\n```c3\nmacro Vec2.length_sq(self)\n```\n```c3\nmacro Vec2.rotate(self, double angle)\n```\n```c3\nfn Vec2 Vec2.towards(self, Vec2 target, double max_distance)\n```\n```c3\nmacro Vec2.transform(self, Matrix4 mat)\n```\n```c3\nmacro Vec2f.angle(self, Vec2f v2)\n```\n```c3\nmacro Vec2f.clamp_mag(self, float min, float max)\n```\n```c3\nmacro Vec2f.distance_sq(self, Vec2f v2)\n```\n```c3\nmacro Vec2f.length_sq(self)\n```\n```c3\nmacro Vec2f.rotate(self, float angle)\n```\n```c3\nfn Vec2f Vec2f.towards(self, Vec2f target, float max_distance)\n```\n```c3\nmacro Vec2f.transform(self, Matrix4f mat)\n```\n```c3\nfn double Vec3.angle(self, Vec3 v2)\n```\n```c3\nfn Vec3 Vec3.barycenter(self, Vec3 a, Vec3 b, Vec3 c)\n```\n```c3\nmacro Vec3.clamp_mag(self, double min, double max)\n```\n```c3\nfn Vec3 Vec3.cross(self, Vec3 v2)\n```\n```c3\nmacro Vec3.distance_sq(self, Vec3 v2)\n```\n```c3\nmacro Vec3.length_sq(self)\n```\n```c3\nfn Vec3 Vec3.perpendicular(self)\n```\n```c3\nfn Vec3 Vec3.refract(self, Vec3 n, double r)\n```\n```c3\nfn Vec3 Vec3.rotate_axis(self, Vec3 axis, double angle)\n```\n```c3\nfn Vec3 Vec3.rotate_quat(self, Quaternion q)\n```\n```c3\nfn Vec3 Vec3.towards(self, Vec3 target, double max_distance)\n```\n```c3\nfn Vec3 Vec3.transform(self, Matrix4 mat)\n```\n```c3\nfn Vec3 Vec3.unproject(self, Matrix4 projection, Matrix4 view)\n```\n```c3\nfn float Vec3f.angle(self, Vec3f v2)\n```\n```c3\nfn Vec3f Vec3f.barycenter(self, Vec3f a, Vec3f b, Vec3f c)\n```\n```c3\nmacro Vec3f.clamp_mag(self, float min, float max)\n```\n```c3\nfn Vec3f Vec3f.cross(self, Vec3f v2)\n```\n```c3\nmacro Vec3f.distance_sq(self, Vec3f v2)\n```\n```c3\nmacro Vec3f.length_sq(self)\n```\n```c3\nfn Vec3f Vec3f.perpendicular(self)\n```\n```c3\nfn Vec3f Vec3f.refract(self, Vec3f n, float r)\n```\n```c3\nfn Vec3f Vec3f.rotate_axis(self, Vec3f axis, float angle)\n```\n```c3\nfn Vec3f Vec3f.rotate_quat(self, Quaternionf q)\n```\n```c3\nfn Vec3f Vec3f.towards(self, Vec3f target, float max_distance)\n```\n```c3\nfn Vec3f Vec3f.transform(self, Matrix4f mat)\n```\n```c3\nfn Vec3f Vec3f.unproject(self, Matrix4f projection, Matrix4f view)\n```\n```c3\nmacro Vec4.clamp_mag(self, double min, double max)\n```\n```c3\nmacro Vec4.distance_sq(self, Vec4 v2)\n```\n```c3\nmacro Vec4.length_sq(self)\n```\n```c3\nfn Vec4 Vec4.towards(self, Vec4 target, double max_distance)\n```\n```c3\nmacro Vec4f.clamp_mag(self, float min, float max)\n```\n```c3\nmacro Vec4f.distance_sq(self, Vec4f v2)\n```\n```c3\nmacro Vec4f.length_sq(self)\n```\n```c3\nfn Vec4f Vec4f.towards(self, Vec4f target, float max_distance)\n```\n```c3\nfn Matrix4 matrix4_look_at(Vec3 eye, Vec3 target, Vec3 up)\n```\n```c3\nfn Matrix4f matrix4f_look_at(Vec3f eye, Vec3f target, Vec3f up)\n```\n```c3\nfn void ortho_normalize(Vec3f* v1, Vec3f* v2)\n```\n```c3\nfn void ortho_normalized(Vec3* v1, Vec3* v2)\n```\n### `std::net`\n```c3\nenum IpProtocol : char (AIFamily ai_family)\n```\n```c3\nfault NetError\n```\n```c3\nstruct InetAddress (Printable)\n```\n```c3\nfn bool InetAddress.is_any_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_link_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_loopback(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast_global(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast_link_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast_node_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast_org_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_multicast_site_local(InetAddress* addr)\n```\n```c3\nfn bool InetAddress.is_site_local(InetAddress* addr)\n```\n```c3\nfn usz? InetAddress.to_format(InetAddress* addr, Formatter* formatter) @dynamic\n```\n```c3\nfn String InetAddress.to_new_string(InetAddress* addr, Allocator allocator = allocator::heap()) @dynamic\n```\n```c3\nfn AddrInfo*? addrinfo(String host, uint port, AIFamily ai_family, AISockType ai_socktype) @if(os::SUPPORTS_INET)\n```\n```c3\nfn String? int_to_new_ipv4(uint val, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? int_to_temp_ipv4(uint val)\n```\n```c3\nfn InetAddress? ipv4_from_str(String s)\n```\n```c3\nfn uint? ipv4toint(String s)\n```\n```c3\nfn InetAddress? ipv6_from_str(String s)\n```\n### `std::net @if(os::SUPPORTS_INET)`\n```c3\ntypedef PollEvents = ushort;\n```\n```c3\ntypedef PollSubscribes = ushort;\n```\n```c3\nenum SocketOption : char (CInt value)\n```\n```c3\nstruct Poll\n```\n```c3\nstruct Socket (InStream, OutStream)\n```\n```c3\nmacro void @loop_over_ai(AddrInfo* ai; @body(NativeSocket fd, AddrInfo* ai))\n```\n```c3\nfn void? Socket.close(&self) @inline @dynamic\n```\n```c3\nfn void? Socket.destroy(&self) @dynamic\n```\n```c3\nfn bool? Socket.get_broadcast(&self)\n```\n```c3\nfn bool? Socket.get_dontroute(&self)\n```\n```c3\nfn bool? Socket.get_keepalive(&self)\n```\n```c3\nfn bool? Socket.get_oobinline(&self)\n```\n```c3\nfn bool? Socket.get_option(&self, SocketOption option)\n```\n```c3\nfn bool? Socket.get_reuseaddr(&self)\n```\n```c3\nfn usz? Socket.read(&self, char[] bytes) @dynamic\n```\n```c3\nfn char? Socket.read_byte(&self) @dynamic\n```\n```c3\nfn void? Socket.set_broadcast(&self, bool value)\n```\n```c3\nfn void? Socket.set_dontroute(&self, bool value)\n```\n```c3\nfn void? Socket.set_keepalive(&self, bool value)\n```\n```c3\nfn void? Socket.set_oobinline(&self, bool value)\n```\n```c3\nfn void? Socket.set_option(&self, SocketOption option, bool value)\n```\n```c3\nfn void? Socket.set_reuseaddr(&self, bool value)\n```\n```c3\nfn usz? Socket.write(&self, char[] bytes) @dynamic\n```\n```c3\nfn void? Socket.write_byte(&self, char byte) @dynamic\n```\n```c3\nmacro Socket new_socket(fd, ai)\n```\n```c3\nfn ulong? poll(Poll[] polls, Duration timeout)\n```\n```c3\nfn ulong? poll_ms(Poll[] polls, long timeout_ms)\n```\n### `std::net::os`\n```c3\ntypedef AIFamily = CInt;\n```\n```c3\ntypedef AIFlags = CInt;\n```\n```c3\ntypedef AIProtocol = CInt;\n```\n```c3\ntypedef AISockType = CInt;\n```\n```c3\ntypedef SockAddrPtr = void*;\n```\n```c3\nstruct AddrInfo\n```\n### `std::net::os @if(env::POSIX &amp;&amp; SUPPORTS_INET)`\n```c3\ntypedef NativeSocket = inline Fd;\n```\n```c3\nstruct Posix_pollfd\n```\n```c3\nmacro void? NativeSocket.close(self)\n```\n```c3\nmacro bool NativeSocket.is_non_blocking(self)\n```\n```c3\nmacro void? NativeSocket.set_non_blocking(self, bool non_blocking)\n```\n```c3\nfn fault convert_error(Errno error)\n```\n```c3\nfn fault socket_error()\n```\n### `std::net::os @if(env::WIN32)`\n```c3\ntypedef NativeSocket = uptr;\n```\n```c3\nmacro void? NativeSocket.close(self)\n```\n```c3\nfn void? NativeSocket.set_non_blocking(self, bool non_blocking)\n```\n```c3\nfn fault convert_error(WSAError error)\n```\n```c3\nfn fault socket_error()\n```\n### `std::net::tcp @if(os::SUPPORTS_INET)`\n```c3\ntypedef TcpServerSocket = inline Socket;\n```\n```c3\ntypedef TcpSocket = inline Socket;\n```\n```c3\nfn TcpSocket? accept(TcpServerSocket* server_socket)\n```\n```c3\nfn TcpSocket? connect(String host, uint port, Duration timeout = 0, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n```c3\nfn TcpSocket? connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n```c3\nfn TcpSocket? connect_async_to(AddrInfo* ai, SocketOption... options)\n```\n```c3\nfn TcpSocket? connect_to(AddrInfo* ai, SocketOption... options)\n```\n```c3\nfn TcpServerSocket? listen(String host, uint port, uint backlog, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n```c3\nfn TcpServerSocket? listen_to(AddrInfo* ai, uint backlog, SocketOption... options)\n```\n### `std::net::udp @if(os::SUPPORTS_INET)`\n```c3\ntypedef UdpSocket = inline Socket;\n```\n```c3\nfn UdpSocket? connect(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n```c3\nfn UdpSocket? connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n```c3\nfn UdpSocket? connect_async_to(AddrInfo* ai, SocketOption... options)\n```\n```c3\nfn UdpSocket? connect_to(AddrInfo* ai, SocketOption... options)\n```\n### `std::os @if(env::DARWIN)`\n```c3\nfn uint num_cpu()\n```\n### `std::os @if(env::LINUX)`\n```c3\nfn uint num_cpu()\n```\n### `std::os @if(env::WIN32)`\n```c3\nfn uint num_cpu()\n```\n### `std::os::backtrace`\n```c3\nfault BacktraceFault\n```\n```c3\nstruct Backtrace (Printable)\n```\n```c3\nfn void Backtrace.free(&self)\n```\n```c3\nfn bool Backtrace.has_file(&self)\n```\n```c3\nfn Backtrace* Backtrace.init(&self, uptr offset, String function, String object_file, String file = \"\", uint line = 0, Allocator allocator)\n```\n```c3\nfn bool Backtrace.is_unknown(&self)\n```\n```c3\nfn usz? Backtrace.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn void*[] capture_current(void*[] buffer)\n```\n```c3\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator) @if(!env::NATIVE_STACKTRACE)\n```\n### `std::os::darwin @if(env::DARWIN)`\n```c3\nstruct Darwin_Dl_info\n```\n```c3\nstruct Darwin_segment_command_64\n```\n```c3\nfn String? executable_path(Allocator allocator)\n```\n```c3\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n### `std::os::env`\n```c3\nfn bool clear_var(String name)\n```\n```c3\nfn String? executable_path(Allocator allocator = allocator::heap())\n```\n```c3\nfn Path? get_config_dir(Allocator allocator = allocator::heap())\n```\n```c3\nfn String? get_home_dir(Allocator using = allocator::heap())\n```\n```c3\nfn String? get_var(String name, Allocator allocator = allocator::heap())\n```\n```c3\nfn String? get_var_temp(String name)\n```\n```c3\nfn bool set_var(String name, String value, bool overwrite = true)\n```\n### `std::os::linux @if(env::LINUX)`\n```c3\nstruct Elf32_Ehdr\n```\n```c3\nstruct Elf32_Phdr\n```\n```c3\nstruct Elf64_Ehdr\n```\n```c3\nstruct Elf64_Phdr\n```\n```c3\nstruct Linux_Dl_info\n```\n```c3\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n### `std::os::macos::cf @if(env::DARWIN) @link(env::DARWIN, \"CoreFoundation.framework\")`\n```c3\ntypedef CFAllocatorContextRef = void*;\n```\n```c3\ntypedef CFAllocatorRef = void*;\n```\n```c3\ntypedef CFArrayCallBacksRef = void*;\n```\n```c3\ntypedef CFArrayRef = void*;\n```\n```c3\ntypedef CFMutableArrayRef = void*;\n```\n```c3\ntypedef CFTypeRef = void*;\n```\n```c3\nstruct CFRange\n```\n```c3\nmacro void* CFAllocatorRef.alloc(CFAllocatorRef allocator, usz size)\n```\n```c3\nmacro void CFAllocatorRef.dealloc(CFAllocatorRef allocator, void* ptr)\n```\n```c3\nmacro usz CFAllocatorRef.get_preferred_size(CFAllocatorRef allocator, usz req_size)\n```\n```c3\nmacro void CFAllocatorRef.set_default(CFAllocatorRef allocator)\n```\n```c3\nmacro CFAllocatorRef default_allocator()\n```\n### `std::os::macos::objc @if(env::DARWIN) @link(env::DARWIN, \"CoreFoundation.framework\")`\n```c3\ntypedef Class = void*;\n```\n```c3\ntypedef Ivar = void*;\n```\n```c3\ntypedef Method = void*;\n```\n```c3\ntypedef Selector = void*;\n```\n```c3\nfault ObjcFailure\n```\n```c3\nmacro bool Class.equals(Class a, Class b)\n```\n```c3\nmacro Method Class.method(Class cls, Selector name)\n```\n```c3\nmacro ZString Class.name(Class cls)\n```\n```c3\nmacro bool Class.responds_to(Class cls, Selector sel)\n```\n```c3\nmacro Class Class.superclass(Class cls)\n```\n```c3\nmacro bool Selector.equals(Selector a, Selector b)\n```\n```c3\nmacro Class? class_by_name(ZString c)\n```\n```c3\nmacro Class[] class_get_list(Allocator allocator = allocator::heap())\n```\n### `std::os::posix @if(env::POSIX)`\n```c3\ntypedef DIRPtr = void*;\n```\n```c3\ntypedef Pthread_t = void*;\n```\n```c3\nstruct Posix_dirent\n```\n```c3\nstruct Posix_spawn_file_actions_t\n```\n```c3\nstruct Posix_spawnattr_t\n```\n```c3\nfn CInt backtrace(void** buffer, CInt size)\n```\n```c3\nmacro CInt wEXITSTATUS(CInt status)\n```\n```c3\nmacro bool wIFCONTINUED(CInt status)\n```\n```c3\nmacro bool wIFEXITED(CInt status)\n```\n```c3\nmacro bool wIFSIGNALED(CInt status)\n```\n```c3\nmacro bool wIFSTOPPED(CInt status)\n```\n```c3\nmacro CInt wSTOPSIG(CInt status)\n```\n```c3\nmacro CInt wTERMSIG(CInt status)\n```\n```c3\nmacro CInt wWCOREDUMP(CInt status)\n```\n```c3\nmacro CInt w_EXITCODE(CInt ret, CInt sig)\n```\n```c3\nmacro CInt w_STOPCODE(CInt sig)\n```\n### `std::os::process @if(env::WIN32 || env::POSIX)`\n```c3\nfault SubProcessResult\n```\n```c3\nstruct SubProcess\n```\n```c3\nfn bool SubProcess.destroy(&self)\n```\n```c3\nfn bool? SubProcess.is_running(&self)\n```\n```c3\nfn CInt? SubProcess.join(&self) @if(env::POSIX)\n```\n```c3\nfn CInt? SubProcess.join(&self) @if(env::WIN32)\n```\n```c3\nfn usz? SubProcess.read_stderr(&self, char* buffer, usz size)\n```\n```c3\nfn usz? SubProcess.read_stdout(&self, char* buffer, usz size)\n```\n```c3\nfn File SubProcess.stdout(&self)\n```\n```c3\nfn void? SubProcess.terminate(&self)\n```\n```c3\nfn SubProcess? create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::POSIX)\n```\n```c3\nfn SubProcess? create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::WIN32)\n```\n```c3\nfn String? execute_stdout_to_buffer(char[] buffer, String[] command_line, SubProcessOptions options = {}, String[] environment = {})\n```\n### `std::os::win32`\n```c3\ntypedef Win32_CRITICAL_SECTION = ulong[5];\n```\n```c3\nenum Win32_ADDRESS_MODE\n```\n```c3\nenum Win32_SYM_TYPE\n```\n```c3\nstruct Win32_ADDRESS64\n```\n```c3\nstruct Win32_AMD64_CONTEXT @align(16)\n```\n```c3\nstruct Win32_ARM64_NT_CONTEXT @align(16)\n```\n```c3\nstruct Win32_ARM64_NT_NEON128\n```\n```c3\nstruct Win32_FILETIME\n```\n```c3\nstruct Win32_GUID\n```\n```c3\nstruct Win32_IMAGEHLP_LINE64\n```\n```c3\nstruct Win32_IMAGEHLP_MODULE64\n```\n```c3\nstruct Win32_IMAGE_DATA_DIRECTORY\n```\n```c3\nstruct Win32_IMAGE_FILE_HEADER\n```\n```c3\nstruct Win32_IMAGE_NT_HEADERS\n```\n```c3\nstruct Win32_IMAGE_OPTIONAL_HEADER64\n```\n```c3\nstruct Win32_KDHELP64\n```\n```c3\nstruct Win32_M128A @align(16)\n```\n```c3\nstruct Win32_MODLOAD_DATA\n```\n```c3\nstruct Win32_MODULEINFO\n```\n```c3\nstruct Win32_OVERLAPPED\n```\n```c3\nstruct Win32_PROCESS_INFORMATION\n```\n```c3\nstruct Win32_SECURITY_ATTRIBUTES\n```\n```c3\nstruct Win32_STACKFRAME64\n```\n```c3\nstruct Win32_STARTUPINFOEXW\n```\n```c3\nstruct Win32_STARTUPINFOW\n```\n```c3\nstruct Win32_SYMBOL_INFO\n```\n```c3\nstruct Win32_SYSTEM_INFO\n```\n```c3\nstruct Win32_UNICODE_STRING\n```\n```c3\nstruct Win32_XMM_SAVE_AREA32\n```\n### `std::os::win32 @if(env::WIN32)`\n```c3\ntypedef WSAError = int;\n```\n```c3\nenum Win32_GET_FILEEX_INFO_LEVELS\n```\n```c3\nstruct Symbol\n```\n```c3\nstruct Win32_FILE_ATTRIBUTE_DATA\n```\n```c3\nstruct Win32_WIN32_FIND_DATAW\n```\n```c3\nstruct Win32_pollfd\n```\n```c3\nfn Win32_DWORD? load_modules()\n```\n```c3\nfn Backtrace? resolve_backtrace(void* addr, Win32_HANDLE process, Allocator allocator)\n```\n```c3\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n### `std::sort`\n```c3\nmacro bool @is_comparer(#cmp, #list)\n```\n```c3\nmacro usz @len_from_list(&list)\n```\n```c3\nmacro usz binarysearch(list, x, cmp = null) @builtin\n```\n```c3\nmacro quicksort(list, cmp = null) @builtin\n```\n### `std::sort::qs(&lt;Type, Comparer&gt;)`\n```c3\nfn void qsort(Type list, isz low, isz high, Comparer cmp)\n```\n### `std::thread`\n```c3\ntypedef ConditionVariable = NativeConditionVariable;\n```\n```c3\ntypedef Mutex = NativeMutex;\n```\n```c3\ntypedef MutexType = int;\n```\n```c3\ntypedef OnceFlag = NativeOnceFlag;\n```\n```c3\ntypedef RecursiveMutex = inline Mutex;\n```\n```c3\ntypedef Thread = NativeThread;\n```\n```c3\ntypedef TimedMutex = inline Mutex;\n```\n```c3\ntypedef TimedRecursiveMutex = inline Mutex;\n```\n```c3\nfault ThreadFault\n```\n```c3\nmacro void? ConditionVariable.broadcast(&cond)\n```\n```c3\nmacro void? ConditionVariable.destroy(&cond)\n```\n```c3\nmacro void? ConditionVariable.init(&cond)\n```\n```c3\nmacro void? ConditionVariable.signal(&cond)\n```\n```c3\nmacro void? ConditionVariable.wait(&cond, Mutex* mutex)\n```\n```c3\nmacro void? ConditionVariable.wait_timeout(&cond, Mutex* mutex, ulong timeout)\n```\n```c3\nmacro void? Mutex.destroy(&mutex)\n```\n```c3\nmacro void? Mutex.init(&mutex)\n```\n```c3\nmacro void? Mutex.lock(&mutex)\n```\n```c3\nmacro bool Mutex.try_lock(&mutex)\n```\n```c3\nmacro void? Mutex.unlock(&mutex)\n```\n```c3\nmacro void OnceFlag.call(&flag, OnceFn func)\n```\n```c3\nmacro void? RecursiveMutex.init(&mutex)\n```\n```c3\nmacro void? Thread.create(&thread, ThreadFn thread_fn, void* arg)\n```\n```c3\nmacro void? Thread.detach(thread)\n```\n```c3\nmacro bool Thread.equals(thread, Thread other)\n```\n```c3\nmacro int? Thread.join(thread)\n```\n```c3\nmacro void? TimedMutex.init(&mutex)\n```\n```c3\nmacro void? TimedMutex.lock_timeout(&mutex, ulong ms)\n```\n```c3\nmacro void? TimedRecursiveMutex.init(&mutex)\n```\n```c3\nmacro void? TimedRecursiveMutex.lock_timeout(&mutex, ulong ms)\n```\n```c3\nmacro Thread current()\n```\n```c3\nmacro void exit(int result)\n```\n```c3\nmacro void? sleep(Duration d) @maydiscard\n```\n```c3\nmacro void? sleep_ms(ulong ms) @maydiscard\n```\n```c3\nmacro void? sleep_ns(NanoDuration ns) @maydiscard\n```\n```c3\nmacro void yield()\n```\n### `std::thread::cpu @if(env::DARWIN)`\n```c3\nfn uint native_cpu()\n```\n### `std::thread::cpu @if(env::LINUX)`\n```c3\nfn uint native_cpu()\n```\n### `std::thread::cpu @if(env::WIN32)`\n```c3\nfn uint native_cpu()\n```\n### `std::thread::os @if (!env::POSIX &amp;&amp; !env::WIN32)`\n```c3\ntypedef NativeConditionVariable = int;\n```\n```c3\ntypedef NativeMutex = int;\n```\n```c3\ntypedef NativeOnceFlag = int;\n```\n```c3\ntypedef NativeThread = int;\n```\n### `std::thread::os @if(env::LINUX)`\n```c3\ntypedef Pthread_attr_t = ulong[7]; // 24 on 32bit\n```\n```c3\ntypedef Pthread_cond_t = ulong[6];\n```\n```c3\ntypedef Pthread_condattr_t = uint;\n```\n```c3\ntypedef Pthread_key_t = uint;\n```\n```c3\ntypedef Pthread_mutex_t = ulong[5]; // 24 on 32 bit\n```\n```c3\ntypedef Pthread_mutexattr_t = uint;\n```\n```c3\ntypedef Pthread_once_t = int;\n```\n```c3\ntypedef Pthread_rwlock_t = ulong[7]; // 32 on 3bit\n```\n```c3\ntypedef Pthread_rwlockattr_t = uint;\n```\n```c3\ntypedef Pthread_sched_param = uint;\n```\n### `std::thread::os @if(env::POSIX &amp;&amp; !env::LINUX)`\n```c3\ntypedef Pthread_attr_t = ulong[8];\n```\n```c3\ntypedef Pthread_cond_t = ulong[6];\n```\n```c3\ntypedef Pthread_condattr_t = ulong[8];\n```\n```c3\ntypedef Pthread_key_t = ulong;\n```\n```c3\ntypedef Pthread_mutex_t = ulong[8];\n```\n```c3\ntypedef Pthread_mutexattr_t = ulong[2];\n```\n```c3\ntypedef Pthread_once_t = ulong[2];\n```\n```c3\ntypedef Pthread_rwlock_t = ulong[25];\n```\n```c3\ntypedef Pthread_rwlockattr_t = ulong[3];\n```\n```c3\ntypedef Pthread_sched_param = ulong;\n```\n### `std::thread::os @if(env::POSIX)`\n```c3\nstruct NativeMutex\n```\n```c3\nfn void? NativeConditionVariable.broadcast(&cond)\n```\n```c3\nfn void? NativeConditionVariable.destroy(&cond)\n```\n```c3\nfn void? NativeConditionVariable.init(&cond)\n```\n```c3\nfn void? NativeConditionVariable.signal(&cond)\n```\n```c3\nfn void? NativeConditionVariable.wait(&cond, NativeMutex* mtx)\n```\n```c3\nfn void? NativeConditionVariable.wait_timeout(&cond, NativeMutex* mtx, ulong ms)\n```\n```c3\nfn void? NativeMutex.destroy(&self)\n```\n```c3\nfn void? NativeMutex.init(&self, MutexType type)\n```\n```c3\nfn bool NativeMutex.is_initialized(&self)\n```\n```c3\nfn void? NativeMutex.lock(&self)\n```\n```c3\nfn void? NativeMutex.lock_timeout(&self, ulong ms)\n```\n```c3\nfn bool NativeMutex.try_lock(&self)\n```\n```c3\nfn void? NativeMutex.unlock(&self)\n```\n```c3\nfn void NativeOnceFlag.call_once(&flag, OnceFn func)\n```\n```c3\nfn void? NativeThread.create(&thread, ThreadFn thread_fn, void* arg)\n```\n```c3\nfn void? NativeThread.detach(thread)\n```\n```c3\nfn bool NativeThread.equals(thread, NativeThread other)\n```\n```c3\nfn int? NativeThread.join(thread)\n```\n```c3\nfn void? native_sleep_nano(NanoDuration nano)\n```\n```c3\nfn NativeThread native_thread_current()\n```\n```c3\nfn void native_thread_exit(int result)\n```\n```c3\nfn void native_thread_yield()\n```\n### `std::thread::os @if(env::WIN32)`\n```c3\ntypedef NativeThread = inline Win32_HANDLE;\n```\n```c3\nstruct NativeConditionVariable\n```\n```c3\nstruct NativeMutex\n```\n```c3\nstruct NativeOnceFlag\n```\n```c3\nfn void? NativeConditionVariable.broadcast(&cond)\n```\n```c3\nfn void? NativeConditionVariable.destroy(&cond) @maydiscard\n```\n```c3\nfn void? NativeConditionVariable.init(&cond)\n```\n```c3\nfn void? NativeConditionVariable.signal(&cond)\n```\n```c3\nfn void? NativeConditionVariable.wait(&cond, NativeMutex* mtx) @inline\n```\n```c3\nfn void? NativeConditionVariable.wait_timeout(&cond, NativeMutex* mtx, uint time) @inline\n```\n```c3\nfn void? NativeMutex.destroy(&mtx)\n```\n```c3\nfn void? NativeMutex.init(&mtx, MutexType type)\n```\n```c3\nfn void? NativeMutex.lock(&mtx)\n```\n```c3\nfn void? NativeMutex.lock_timeout(&mtx, usz ms)\n```\n```c3\nfn bool NativeMutex.try_lock(&mtx)\n```\n```c3\nfn void? NativeMutex.unlock(&mtx)\n```\n```c3\nfn void NativeOnceFlag.call_once(&flag, OnceFn func)\n```\n```c3\nfn void? NativeThread.create(&thread, ThreadFn func, void* args)\n```\n```c3\nfn void? NativeThread.detach(thread) @inline\n```\n```c3\nfn bool NativeThread.equals(thread, NativeThread other)\n```\n```c3\nfn int? NativeThread.join(thread)\n```\n```c3\nfn void? native_sleep_nano(NanoDuration ns)\n```\n```c3\nfn NativeThread native_thread_current()\n```\n```c3\nfn void native_thread_exit(int result) @inline\n```\n```c3\nfn void native_thread_yield()\n```\n### `std::thread::pool(&lt;SIZE&gt;)`\n```c3\nstruct QueueItem\n```\n```c3\nstruct ThreadPool\n```\n```c3\nfn void? ThreadPool.destroy(&self)\n```\n```c3\nfn void? ThreadPool.init(&self)\n```\n```c3\nfn void? ThreadPool.push(&self, ThreadFn func, void* arg)\n```\n```c3\nfn void? ThreadPool.stop_and_destroy(&self)\n```\n### `std::time`\n```c3\ntypedef Clock = ulong;\n```\n```c3\ntypedef Duration = long;\n```\n```c3\ntypedef NanoDuration (Printable) = long;\n```\n```c3\ntypedef Time = long;\n```\n```c3\nenum Month : char\n```\n```c3\nenum Weekday : char\n```\n```c3\nstruct DateTime\n```\n```c3\nstruct TzDateTime\n```\n```c3\nfn long Duration.to_ms(td)\n```\n```c3\nfn NanoDuration Duration.to_nano(td)\n```\n```c3\nfn Duration NanoDuration.to_duration(nd)\n```\n```c3\nfn usz? NanoDuration.to_format(&self, Formatter* formatter) @dynamic\n```\n```c3\nfn long NanoDuration.to_ms(nd)\n```\n```c3\nfn double NanoDuration.to_sec(nd)\n```\n```c3\nfn Time Time.add_days(time, long days)\n```\n```c3\nfn Time Time.add_duration(time, Duration duration)\n```\n```c3\nfn Time Time.add_hours(time, long hours)\n```\n```c3\nfn Time Time.add_minutes(time, long minutes)\n```\n```c3\nfn Time Time.add_seconds(time, long seconds)\n```\n```c3\nfn Time Time.add_weeks(time, long weeks)\n```\n```c3\nfn double Time.diff_days(time, Time other)\n```\n```c3\nfn double Time.diff_hour(time, Time other)\n```\n```c3\nfn double Time.diff_min(time, Time other)\n```\n```c3\nfn double Time.diff_sec(time, Time other)\n```\n```c3\nfn Duration Time.diff_us(time, Time other)\n```\n```c3\nfn double Time.diff_weeks(time, Time other)\n```\n```c3\nfn double Time.to_seconds(time)\n```\n```c3\nfn Duration from_float(double s) @inline\n```\n```c3\nfn Duration hour(long l) @inline\n```\n```c3\nfn Duration min(long l) @inline\n```\n```c3\nfn Duration ms(long l) @inline\n```\n```c3\nfn Time now()\n```\n```c3\nfn Duration sec(long l) @inline\n```\n### `std::time::clock`\n```c3\nfn NanoDuration Clock.mark(&self)\n```\n```c3\nfn NanoDuration Clock.to_now(self)\n```\n```c3\nfn Clock now()\n```\n### `std::time::datetime @if(env::LIBC)`\n```c3\nfn DateTime DateTime.add_days(&self, int days)\n```\n```c3\nfn DateTime DateTime.add_hours(&self, int hours)\n```\n```c3\nfn DateTime DateTime.add_minutes(&self, int minutes)\n```\n```c3\nfn DateTime DateTime.add_months(&self, int months)\n```\n```c3\nfn DateTime DateTime.add_seconds(&self, int seconds)\n```\n```c3\nfn DateTime DateTime.add_weeks(&self, int weeks)\n```\n```c3\nfn DateTime DateTime.add_years(&self, int years)\n```\n```c3\nfn bool DateTime.after(&self, DateTime compare) @inline\n```\n```c3\nfn bool DateTime.before(&self, DateTime compare) @inline\n```\n```c3\nfn int DateTime.compare_to(&self, DateTime compare)\n```\n```c3\nfn double DateTime.diff_sec(self, DateTime from)\n```\n```c3\nfn Duration DateTime.diff_us(self, DateTime from)\n```\n```c3\nfn int DateTime.diff_years(&self, DateTime from)\n```\n```c3\nfn void DateTime.set_date(&self, int year, Month month = JANUARY, int day = 1, int hour = 0, int min = 0, int sec = 0, int us = 0)\n```\n```c3\nfn void DateTime.set_time(&self, Time time)\n```\n```c3\nfn TzDateTime DateTime.to_local(&self)\n```\n```c3\nfn Time DateTime.to_time(&self) @inline\n```\n```c3\nfn DateTime from_date(int year, Month month = JANUARY, int day = 1, int hour = 0, int min = 0, int sec = 0, int us = 0)\n```\n```c3\nfn DateTime from_time(Time time)\n```\n```c3\nfn DateTime now()\n```\n### `std::time::os @if(env::DARWIN)`\n```c3\nstruct Darwin_mach_timebase_info\n```\n```c3\nfn Clock native_clock()\n```\n### `std::time::os @if(env::POSIX)`\n```c3\nfn Clock native_clock() @if(!env::DARWIN)\n```\n```c3\nfn Time native_timestamp()\n```\n### `std::time::os @if(env::WIN32)`\n```c3\nfn Clock native_clock()\n```\n```c3\nfn Time native_timestamp()\n```\n";
						const data = {title:"Standard Library Reference",description:"Standard Library Reference",editUrl:true,head:[],template:"doc",sidebar:{order:141,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Standard Library/stdlib_refcard.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
