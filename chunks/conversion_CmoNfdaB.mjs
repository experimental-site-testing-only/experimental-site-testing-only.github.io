import { c as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_afRpe8AA.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<h2 id=\"conversion-rules-for-c3\">Conversion Rules For C3</h2>\n<p>C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3:</p>\n<ul>\n<li><code dir=\"auto\">float</code> to <code dir=\"auto\">int</code> conversions require a cast.</li>\n<li><code dir=\"auto\">int</code> to <code dir=\"auto\">float</code> conversions <em>do not</em> require a cast.</li>\n<li><code dir=\"auto\">bool</code> to <code dir=\"auto\">float</code> converts to <code dir=\"auto\">0.0</code> or <code dir=\"auto\">1.0</code></li>\n<li>Widening <code dir=\"auto\">float</code> conversions are only conditionally allowed<sup>*</sup>.</li>\n<li>Narrowing conversions require a cast<sup>*</sup>.</li>\n<li>Widening <code dir=\"auto\">int</code> conversions are only conditionally allowed<sup>*</sup>.</li>\n<li>Signed &#x3C;-> unsigned conversions of the same type <em>do not</em> require a cast.</li>\n<li>In conditionals <code dir=\"auto\">float</code> to <code dir=\"auto\">bool</code> <em>do not</em> require a cast, any non zero <code dir=\"auto\">float</code> value considered true.</li>\n<li>Implicit conversion to <code dir=\"auto\">bool</code> only occurs in conditionals or when the value is enclosed in <code dir=\"auto\">()</code> e.g. <code dir=\"auto\">bool x = (1.0)</code> or <code dir=\"auto\">if (1.0) { ... }</code></li>\n</ul>\n<p>C3 uses two’s complement arithmetic for all integer math.</p>\n<aside aria-label=\"Note\" class=\"starlight-aside starlight-aside--note\"><p class=\"starlight-aside__title\" aria-hidden=\"true\"><svg viewBox=\"0 0 24 24\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"starlight-aside__icon\"><path d=\"M12 11C11.7348 11 11.4804 11.1054 11.2929 11.2929C11.1054 11.4804 11 11.7348 11 12V16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17C12.2652 17 12.5196 16.8946 12.7071 16.7071C12.8946 16.5196 13 16.2652 13 16V12C13 11.7348 12.8946 11.4804 12.7071 11.2929C12.5196 11.1054 12.2652 11 12 11ZM12.38 7.08C12.1365 6.97998 11.8635 6.97998 11.62 7.08C11.4973 7.12759 11.3851 7.19896 11.29 7.29C11.2017 7.3872 11.1306 7.49882 11.08 7.62C11.024 7.73868 10.9966 7.86882 11 8C10.9992 8.13161 11.0245 8.26207 11.0742 8.38391C11.124 8.50574 11.1973 8.61656 11.29 8.71C11.3872 8.79833 11.4988 8.86936 11.62 8.92C11.7715 8.98224 11.936 9.00632 12.099 8.99011C12.2619 8.97391 12.4184 8.91792 12.5547 8.82707C12.691 8.73622 12.8029 8.61328 12.8805 8.46907C12.9582 8.32486 12.9992 8.16378 13 8C12.9963 7.73523 12.8927 7.48163 12.71 7.29C12.6149 7.19896 12.5028 7.12759 12.38 7.08ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7363 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C20 14.1217 19.1572 16.1566 17.6569 17.6569C16.1566 19.1571 14.1217 20 12 20Z\"></path></svg>Note</p><section class=\"starlight-aside__content\"><p>These abbreviations are used in the text below:</p><ul>\n<li>“lhs” meaning “left hand side”.</li>\n<li>“rhs” meaning “right hand side”.</li>\n</ul></section></aside>\n<h3 id=\"target-type\">Target type</h3>\n<p>The left hand side of an assignment, or the parameter type in a call is known as the <em>target type</em> the target type is used for implicit widening and inferring struct initialization.</p>\n<h3 id=\"common-arithmetic-promotion\">Common arithmetic promotion</h3>\n<p>Like C, C3 uses implicit arithmetic promotion of integer and floating point variables before arithmetic operations:</p>\n<ol>\n<li>For any floating point type with a bitwidth smaller than 32 bits, widen to <code dir=\"auto\">float</code>. E.g. <code dir=\"auto\">f16 -> float</code></li>\n<li>For an integer type smaller than the <em>minimum arithmetic width</em> promote the value to a same signed integer of the <em>minimum arithmetic width</em> (this usually corresponds to a c int/uint). E.g. <code dir=\"auto\">ushort -> uint</code></li>\n</ol>\n<h3 id=\"implicit-narrowing\">Implicit narrowing</h3>\n<p>An expression with an integer type, may implicitly narrow to smaller integer type, and similarly a float type may implicitly narrow to less wide floating point type is determined from the following algorithm.</p>\n<ol>\n<li>Shifts and assign look at the lhs expression.</li>\n<li><code dir=\"auto\">++</code>, <code dir=\"auto\">--</code>, <code dir=\"auto\">~</code>, <code dir=\"auto\">-</code>, <code dir=\"auto\">!!</code>, <code dir=\"auto\">!</code> - check the inner type.</li>\n<li><code dir=\"auto\">+</code>, <code dir=\"auto\">-</code>, <code dir=\"auto\">*</code>, <code dir=\"auto\">/</code>, <code dir=\"auto\">%</code>, <code dir=\"auto\">^</code>, <code dir=\"auto\">|</code>, <code dir=\"auto\">&#x26;</code>, <code dir=\"auto\">??</code>, <code dir=\"auto\">?:</code> - check both lhs and rhs.</li>\n<li>Narrowing <code dir=\"auto\">int</code>/<code dir=\"auto\">float</code> cast, assume the type is the narrowed type.</li>\n<li>Widening <code dir=\"auto\">int</code>/<code dir=\"auto\">float</code> cast, look at the inner expression, ignoring the cast.</li>\n<li>In the case of any other cast, assume it is opaque and the type is that of the cast.</li>\n<li>In the case of an integer literal, instead of looking at the type, check that the integer would fit the type to narrow to.</li>\n<li>For <code dir=\"auto\">.len</code> access, allow narrowing to C int width.</li>\n<li>For all other expressions, check against the size of the type.</li>\n</ol>\n<p>As rough guide: if all the sub expressions originally are small enough it’s ok to implicitly convert the result.</p>\n<p>Examples:</p>\n<div class=\"expressive-code\"><link rel=\"stylesheet\" href=\"/_astro/ec.j8ofn.css\"><script type=\"module\" src=\"/_astro/ec.8zarh.js\"></script><figure class=\"frame not-content\"><figcaption class=\"header\"></figcaption><pre data-language=\"c3\"><code><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">float16 h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#F78C6C;--1:#AA0982\">12.0</span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">float</span><span style=\"--0:#D6DEEB;--1:#403F53\"> f </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#F78C6C;--1:#AA0982\">13.0</span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">double</span><span style=\"--0:#D6DEEB;--1:#403F53\"> d </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#F78C6C;--1:#AA0982\">22.0</span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\">\n</div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">char</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#F78C6C;--1:#AA0982\">1</span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">short</span><span style=\"--0:#D6DEEB;--1:#403F53\"> y </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#C792EA;--1:#8D46B4\">-</span><span style=\"--0:#F78C6C;--1:#AA0982\">3</span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\"> z </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--1:#AA0982\"><span style=\"--0:#FFEB95\">0x</span><span style=\"--0:#F78C6C\">FFFFF</span></span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">ulong w </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#C792EA;--1:#8D46B4\">-</span><span style=\"--1:#AA0982\"><span style=\"--0:#FFEB95\">0x</span><span style=\"--0:#F78C6C\">FFFFFFF</span></span><span style=\"--0:#D6DEEB;--1:#403F53\">;</span></div></div><div class=\"ec-line\"><div class=\"code\">\n</div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">x </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x;</span><span style=\"--0:#809191;--1:#5E6578\"> // => calculated as x = (char)((int)x + (int)x);</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">x </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> y </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x;</span><span style=\"--0:#809191;--1:#5E6578\"> // => Error, narrowing not allowed as y > char</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x </span><span style=\"--0:#C792EA;--1:#8D46B4\">*</span><span style=\"--0:#D6DEEB;--1:#403F53\"> h;</span><span style=\"--0:#809191;--1:#5E6578\"> // => calculated as h = (float16)((float)x * (float)h);</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#D6DEEB;--1:#403F53\">h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> f </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> x;</span><span style=\"--0:#809191;--1:#5E6578\"> // => Error, narrowing not allowed since f > f16</span></div></div></code></pre><div class=\"copy\"><button title=\"Copy to clipboard\" data-copied=\"Copied!\" data-code=\"float16 h = 12.0;float f = 13.0;double d = 22.0;char x = 1;short y = -3;int z = 0xFFFFF;ulong w = -0xFFFFFFF;x = x + x; // => calculated as x = (char)((int)x + (int)x);x = y + x; // => Error, narrowing not allowed as y > charh = x * h; // => calculated as h = (float16)((float)x * (float)h);h = f + x; // => Error, narrowing not allowed since f > f16\"><div></div></button></div></figure></div>\n<h3 id=\"implicit-widening\">Implicit widening</h3>\n<p>Unlike C, implicit widening will only happen on “simple expressions”:\nif the expression is a primary expression, or a unary operation on a primary expression.</p>\n<p>For assignment, special rules hold. For an assignment to a binary expression, <em>if</em> its two subexpressions are “simple expressions” and the binary expression is <code dir=\"auto\">+</code>, <code dir=\"auto\">-</code>, <code dir=\"auto\">/</code>, <code dir=\"auto\">*</code>, allow an implicit promotion of the two sub expressions.</p>\n<div class=\"expressive-code\"><figure class=\"frame not-content\"><figcaption class=\"header\"></figcaption><pre data-language=\"c3\"><code><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\"> a </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> ...</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">short</span><span style=\"--0:#D6DEEB;--1:#403F53\"> b </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> ...</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">char</span><span style=\"--0:#D6DEEB;--1:#403F53\"> c </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> ...</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> d </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> a;</span><span style=\"--0:#809191;--1:#5E6578\"> // Valid - simple expression.</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\"> e </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\">)(d </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> b));</span><span style=\"--0:#809191;--1:#5E6578\"> // Error</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\"> f </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">int</span><span style=\"--0:#D6DEEB;--1:#403F53\">)(d </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> </span><span style=\"--0:#C792EA;--1:#8D46B4\">~</span><span style=\"--0:#D6DEEB;--1:#403F53\">b);</span><span style=\"--0:#809191;--1:#5E6578\"> // Valid</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> g </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> b;</span><span style=\"--0:#809191;--1:#5E6578\"> // Valid</span></div></div></code></pre><div class=\"copy\"><button title=\"Copy to clipboard\" data-copied=\"Copied!\" data-code=\"int a = ...short b = ...char c = ...long d = a; // Valid - simple expression.int e = (int)(d + (a + b)); // Errorint f = (int)(d + ~b); // Validlong g = a + b; // Valid\"><div></div></button></div></figure></div>\n<p>As a rule of thumb, if there are more than one possible conversion an explicit cast is needed.</p>\n<p>Example:</p>\n<div class=\"expressive-code\"><figure class=\"frame not-content\"><figcaption class=\"header\"></figcaption><pre data-language=\"c3\"><code><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (b </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> c);</span></div></div><div class=\"ec-line\"><div class=\"code\">\n</div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#809191;--1:#5E6578\">// Possible intention 1</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)(a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (b </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> c));</span></div></div><div class=\"ec-line\"><div class=\"code\">\n</div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#809191;--1:#5E6578\">// Possible intention 2</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)(b </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> c);</span></div></div><div class=\"ec-line\"><div class=\"code\">\n</div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#809191;--1:#5E6578\">// Possible intention 3</span></div></div><div class=\"ec-line\"><div class=\"code\"><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\"> h </span><span style=\"--0:#C792EA;--1:#8D46B4\">=</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)a </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> ((</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)b </span><span style=\"--0:#C792EA;--1:#8D46B4\">+</span><span style=\"--0:#D6DEEB;--1:#403F53\"> (</span><span style=\"--0:#C792EA;--1:#8D46B4\">long</span><span style=\"--0:#D6DEEB;--1:#403F53\">)c);</span></div></div></code></pre><div class=\"copy\"><button title=\"Copy to clipboard\" data-copied=\"Copied!\" data-code=\"long h = a + (b + c);// Possible intention 1long h = (long)(a + (b + c));// Possible intention 2long h = (long)a + (long)(b + c);// Possible intention 3long h = (long)a + ((long)b + (long)c);\"><div></div></button></div></figure></div>\n<h3 id=\"maximum-type\">Maximum type</h3>\n<p>The <em>maximum type</em> is a concept used when unifying two or more types. The algorithm follows:</p>\n<ol>\n<li>First perform implicit promotion.</li>\n<li>If both types are the same, the maximum type is this type.</li>\n<li>If one type is a floating point type, and the other is an integer type,\nthe maximum type is the floating point type. E.g. <code dir=\"auto\">int + float -> float</code>.</li>\n<li>If both types are floating point types, the maximum type is the widest floating point type. E.g. <code dir=\"auto\">float + double -> double</code>.</li>\n<li>If both types are integer types with the same signedness, the\nmaximum type is the widest integer type of the two. E.g. <code dir=\"auto\">uint + ulong -> ulong</code>.</li>\n<li>If both types are integer types with different signedness, the\nmaximum type is a signed integer with the same bit width as the maximum integer type. <code dir=\"auto\">ulong + int -> long</code></li>\n<li>If at least one side is a struct or a pointer to a struct with an\n<code dir=\"auto\">inline</code> directive on a member, check recursively check if the type of\nthe inline member can be used to find a maximum type (see below under sub struct conversions)</li>\n<li>All other cases are errors.</li>\n</ol>\n<h3 id=\"substruct-conversions\">Substruct conversions</h3>\n<p>Substructs may be used in place of its parent structs in many cases. The rule is as follows:</p>\n<ol>\n<li>A substruct pointer may implicitly convert to a parent struct.</li>\n<li>A substruct <em>value</em> may be implicitly assigned to a variable with the parent struct type,\nThis will <em>truncate</em> the value, copying only the parent part of the substruct. However, a\nsubstruct value cannot be assigned its parent struct.</li>\n<li>Substruct slices and arrays <em>can not</em> be cast (implicitly or explicitly) to an array of the parent struct type.</li>\n</ol>\n<h3 id=\"pointer-conversions\">Pointer conversions</h3>\n<p>Pointer conversion between types usually need explicit casts.\nThe exception is <code dir=\"auto\">void*</code> which any type may implicitly convert <em>to</em> or <em>from</em>.\nConversion rules from and to arrays are detailed under <a href=\"/language-common/arrays/\">arrays</a></p>\n<h3 id=\"vector-conversions\">Vector conversions</h3>\n<p>Conversion between underlying vector types need explicit conversions. They work\nas regular conversions with one notable exception: converting a <code dir=\"auto\">true</code> boolean\nvector value into an int will yield a value with all bits set. So <code dir=\"auto\">bool[&#x3C;2>] { true, false }</code>\nconverted to for example <code dir=\"auto\">char[&#x3C;2>]</code> will yield <code dir=\"auto\">{ 255, 0 }</code>.</p>\n<p>Vectors can also be cast to the corresponding array type, for example: <code dir=\"auto\">char[&#x3C;2>]</code> &#x3C;=> <code dir=\"auto\">char[2]</code>.</p>\n<h2 id=\"binary-conversions\">Binary conversions</h2>\n<h4 id=\"1-multiplication-division-remainder-subtraction--addition-with-both-operands-being-numbers\">1. Multiplication, division, remainder, subtraction / addition with both operands being numbers</h4>\n<p>These operations are only valid for integer and float types.</p>\n<ol>\n<li>Resolve the operands.</li>\n<li>Find the <a href=\"#maximum-type\">maximum type</a> of the two operands.</li>\n<li>Promote both operands to the resulting type if both are simple expressions</li>\n<li>The resulting type of the expression is the <a href=\"#maximum-type\">maximum type</a>.</li>\n</ol>\n<h4 id=\"2-addition-with-left-side-being-a-pointer\">2. Addition with left side being a pointer</h4>\n<ol>\n<li>Resolve the operands.</li>\n<li>If the rhs is not an integer, this is an error.</li>\n<li>If the rhs has a bit width that exceeds isz, this is an error.</li>\n<li>The result of the expression is the lhs type.</li>\n</ol>\n<h4 id=\"3-subtraction-with-lhs-pointer-and-rhs-integer\">3. Subtraction with lhs pointer and rhs integer</h4>\n<ol>\n<li>Resolve the operands.</li>\n<li>If the right hand type has a bit width that exceeds isz, this is an error.</li>\n<li>The result of the expression is the left hand type.</li>\n</ol>\n<h4 id=\"4-subtraction-with-both-sides-pointers\">4. Subtraction with both sides pointers</h4>\n<ol>\n<li>Resolve the operands.</li>\n<li>If the either side is a <code dir=\"auto\">void*</code>, it is cast to the other type.</li>\n<li>If the types of the sides are different, this is an error.</li>\n<li>The result of the expression is isz.</li>\n<li>If this result exceeds the target width, this is an error.</li>\n</ol>\n<h4 id=\"6-bit-operations--\">6. Bit operations <code dir=\"auto\">^</code> <code dir=\"auto\">&#x26;</code> <code dir=\"auto\">|</code></h4>\n<p>These operations are only valid for integers and booleans.</p>\n<ol>\n<li>Resolve the operands.</li>\n<li>Find the <a href=\"#maximum-type\">maximum type</a> of the two operands.</li>\n<li>Promote both operands to the <a href=\"#maximum-type\">maximum type</a> if they are simple expressions.</li>\n<li>The result of the expression is the <a href=\"#maximum-type\">maximum type</a>.</li>\n</ol>\n<h4 id=\"6-shift-operations-\">6. Shift operations <code dir=\"auto\">&#x3C;&#x3C;</code> <code dir=\"auto\">>></code></h4>\n<p>These operations are only valid for integers.</p>\n<ol>\n<li>Resolve the operands.</li>\n<li>In safe mode, insert a trap to ensure that rhs >= 0 and rhs &#x3C; bit width of the left hand side.</li>\n<li>The result of the expression is the lhs type.</li>\n</ol>\n<h4 id=\"7-assignment-operations---------\">7. Assignment operations <code dir=\"auto\">+=</code> <code dir=\"auto\">-=</code> <code dir=\"auto\">*=</code> <code dir=\"auto\">*=</code> <code dir=\"auto\">/=</code> <code dir=\"auto\">%=</code> <code dir=\"auto\">^=</code> <code dir=\"auto\">|=</code> <code dir=\"auto\">&#x26;=</code></h4>\n<ol>\n<li>Resolve the lhs.</li>\n<li>Resolve the right operand as an assignment rhs.</li>\n<li>The result of the expression is the lhs type.</li>\n</ol>\n<h4 id=\"8-assignment-shift-\">8. Assignment shift <code dir=\"auto\">>>=</code> <code dir=\"auto\">&#x3C;&#x3C;=</code></h4>\n<ol>\n<li>Resolve both operands</li>\n<li>In safe mode, insert a trap to ensure that rhs >= 0 and rhs &#x3C; bit width of the left hand side.</li>\n<li>The result of the expression is the lhs type.</li>\n</ol>\n<h4 id=\"9--and\">9. <code dir=\"auto\">&#x26;&#x26;</code> and <code dir=\"auto\">||</code></h4>\n<ol>\n<li>Resolve both operands.</li>\n<li>Insert bool cast of both operands.</li>\n<li>The type is bool.</li>\n</ol>\n<h4 id=\"10---\">10. <code dir=\"auto\">&#x3C;=</code> <code dir=\"auto\">==</code> <code dir=\"auto\">>=</code> <code dir=\"auto\">!=</code></h4>\n<ol>\n<li>Resolve the operands, left to right.</li>\n<li>Find the <a href=\"#maximum-type\">maximum type</a> of the two operands.</li>\n<li>Promote both operands to the <a href=\"#maximum-type\">maximum type</a>.</li>\n<li>The type is bool.</li>\n</ol>\n<h2 id=\"unary-conversions\">Unary conversions</h2>\n<h4 id=\"1-bit-negate\">1. Bit negate</h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>If the inner type is not an integer this is an error.</li>\n<li>The type is the inner type.</li>\n</ol>\n<h4 id=\"2-boolean-not\">2. Boolean not</h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>The type is bool.</li>\n</ol>\n<h4 id=\"3-negation\">3. Negation</h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>If the type inner type is not a number this is an error.</li>\n<li>If the inner type is an unsigned integer, cast it to the same signed type.</li>\n<li>The type is the type of the result from (3)</li>\n</ol>\n<h4 id=\"4--and\">4. <code dir=\"auto\">&#x26;</code> and <code dir=\"auto\">&#x26;&#x26;</code></h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>The type is a pointer to the type of the inner operand.</li>\n</ol>\n<h4 id=\"5\">5. <code dir=\"auto\">*</code></h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>If the operand is not a pointer, or is a <code dir=\"auto\">void* </code> pointer, this is an error.</li>\n<li>The type is the pointee of the inner operand’s type.</li>\n</ol>\n<p>Dereferencing 0 is implementation defined.</p>\n<h4 id=\"6--and--\">6. <code dir=\"auto\">++</code> and <code dir=\"auto\">--</code></h4>\n<ol>\n<li>Resolve the inner operand.</li>\n<li>If the type is not a number, this is an error.</li>\n<li>The type is the same as the inner operand.</li>\n</ol>\n<h2 id=\"base-expressions\">Base expressions</h2>\n<h4 id=\"1-typed-identifiers\">1. Typed identifiers</h4>\n<ol>\n<li>The type is that of the declaration.</li>\n<li>If the width of the type is less than that of the target type, widen to the target type.</li>\n<li>If the width of the type is greater than that of the target type, it is an error.</li>\n</ol>\n<h4 id=\"2-constants-and-literals\">2. Constants and literals</h4>\n<ol>\n<li>If the constant is an integer, it is assumed to be the <em>arithmetic promotion width</em> and signed.\nIf the suffix <code dir=\"auto\">u</code> is added, it is assumed to be an unsigned number. If a suffix <code dir=\"auto\">ixx</code> or <code dir=\"auto\">uxx</code>\nis given then it is considered a an integer of that type width and signedness. It cannot be implicitly narrowed.</li>\n<li>If the constant is a floating point value, it is assumed to be a <code dir=\"auto\">double</code> unless suffixed\nwith <code dir=\"auto\">f</code> which is then assumed to be a <code dir=\"auto\">float</code>. If a bit width is given after <code dir=\"auto\">f</code>,\nit is instead a floating point type of that width.</li>\n</ol>";

				const frontmatter = {"title":"Conversions and Promotions","description":"Conversions and Promotions","sidebar":{"order":210}};
				const file = "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Rules/conversion.md";
				const url = undefined;
				function rawContent() {
					return "\n## Conversion Rules For C3\nC3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3:\n\n- `float` to `int` conversions require a cast.\n- `int` to `float` conversions *do not* require a cast.\n- `bool` to `float` converts to `0.0` or `1.0`\n- Widening `float` conversions are only conditionally allowed<sup>*</sup>.\n- Narrowing conversions require a cast<sup>*</sup>.\n- Widening `int` conversions are only conditionally allowed<sup>*</sup>.\n- Signed <-> unsigned conversions of the same type *do not* require a cast.\n- In conditionals `float` to `bool` *do not* require a cast, any non zero `float` value considered true.\n- Implicit conversion to `bool` only occurs in conditionals or when the value is enclosed in `()` e.g. `bool x = (1.0)` or `if (1.0) { ... }`\n\nC3 uses two's complement arithmetic for all integer math.\n\n:::note \nThese abbreviations are used in the text below:\n- \"lhs\" meaning \"left hand side\".\n- \"rhs\" meaning \"right hand side\".\n:::\n\n### Target type\n\nThe left hand side of an assignment, or the parameter type in a call is known as the *target type* the target type is used for implicit widening and inferring struct initialization.\n\n### Common arithmetic promotion\n\nLike C, C3 uses implicit arithmetic promotion of integer and floating point variables before arithmetic operations:\n\n1. For any floating point type with a bitwidth smaller than 32 bits, widen to `float`. E.g. `f16 -> float`\n2. For an integer type smaller than the *minimum arithmetic width* promote the value to a same signed integer of the *minimum arithmetic width* (this usually corresponds to a c int/uint). E.g. `ushort -> uint`\n\n### Implicit narrowing\n\nAn expression with an integer type, may implicitly narrow to smaller integer type, and similarly a float type may implicitly narrow to less wide floating point type is determined from the following algorithm.\n\n1. Shifts and assign look at the lhs expression.\n2. `++`, `--`, `~`, `-`, `!!`, `!` - check the inner type.\n3. `+`, `-`, `*`, `/`, `%`, `^`, `|`, `&`, `??`, `?:` - check both lhs and rhs.\n4. Narrowing `int`/`float` cast, assume the type is the narrowed type.\n5. Widening `int`/`float` cast, look at the inner expression, ignoring the cast.\n6. In the case of any other cast, assume it is opaque and the type is that of the cast.\n7. In the case of an integer literal, instead of looking at the type, check that the integer would fit the type to narrow to.\n8. For `.len` access, allow narrowing to C int width.\n9. For all other expressions, check against the size of the type.\n\nAs rough guide: if all the sub expressions originally are small enough it's ok to implicitly convert the result.\n\nExamples:\n```c3\nfloat16 h = 12.0;\nfloat f = 13.0;\ndouble d = 22.0;\n\nchar x = 1;\nshort y = -3;\nint z = 0xFFFFF;\nulong w = -0xFFFFFFF;\n\nx = x + x; // => calculated as x = (char)((int)x + (int)x);\nx = y + x; // => Error, narrowing not allowed as y > char\nh = x * h; // => calculated as h = (float16)((float)x * (float)h);\nh = f + x; // => Error, narrowing not allowed since f > f16\n```\n\n### Implicit widening\n\nUnlike C, implicit widening will only happen on \"simple expressions\":\nif the expression is a primary expression, or a unary operation on a primary expression.\n\nFor assignment, special rules hold. For an assignment to a binary expression, *if* its two subexpressions are \"simple expressions\" and the binary expression is `+`, `-`, `/`, `*`, allow an implicit promotion of the two sub expressions.\n\n```c3\nint a = ...\nshort b = ...\nchar c = ...\nlong d = a; // Valid - simple expression.\nint e = (int)(d + (a + b)); // Error\nint f = (int)(d + ~b); // Valid\nlong g = a + b; // Valid\n```\n\nAs a rule of thumb, if there are more than one possible conversion an explicit cast is needed.\n\nExample:\n\n```c3\nlong h = a + (b + c);\n\n// Possible intention 1\nlong h = (long)(a + (b + c));\n\n// Possible intention 2\nlong h = (long)a + (long)(b + c);\n\n// Possible intention 3\nlong h = (long)a + ((long)b + (long)c);\n```\n\n### Maximum type\n\nThe *maximum type* is a concept used when unifying two or more types. The algorithm follows:\n\n1. First perform implicit promotion.\n2. If both types are the same, the maximum type is this type. \n3. If one type is a floating point type, and the other is an integer type, \nthe maximum type is the floating point type. E.g. `int + float -> float`.\n4. If both types are floating point types, the maximum type is the widest floating point type. E.g. `float + double -> double`.\n5. If both types are integer types with the same signedness, the \nmaximum type is the widest integer type of the two. E.g. `uint + ulong -> ulong`.\n6. If both types are integer types with different signedness, the \nmaximum type is a signed integer with the same bit width as the maximum integer type. `ulong + int -> long`\n7. If at least one side is a struct or a pointer to a struct with an \n`inline` directive on a member, check recursively check if the type of \nthe inline member can be used to find a maximum type (see below under sub struct conversions)\n8. All other cases are errors.\n \n### Substruct conversions\n\nSubstructs may be used in place of its parent structs in many cases. The rule is as follows:\n\n1. A substruct pointer may implicitly convert to a parent struct.\n2. A substruct *value* may be implicitly assigned to a variable with the parent struct type, \nThis will *truncate* the value, copying only the parent part of the substruct. However, a \nsubstruct value cannot be assigned its parent struct.\n3. Substruct slices and arrays *can not* be cast (implicitly or explicitly) to an array of the parent struct type.\n\n### Pointer conversions\n\nPointer conversion between types usually need explicit casts. \nThe exception is `void*` which any type may implicitly convert *to* or *from*. \nConversion rules from and to arrays are detailed under [arrays](/language-common/arrays/)\n\n### Vector conversions\n\nConversion between underlying vector types need explicit conversions. They work\nas regular conversions with one notable exception: converting a `true` boolean\nvector value into an int will yield a value with all bits set. So `bool[<2>] { true, false }`\nconverted to for example `char[<2>]` will yield `{ 255, 0 }`.\n\nVectors can also be cast to the corresponding array type, for example: `char[<2>]` <=> `char[2]`.\n\n## Binary conversions\n\n#### 1. Multiplication, division, remainder, subtraction / addition with both operands being numbers\n\nThese operations are only valid for integer and float types.\n\n1. Resolve the operands.\n2. Find the [maximum type](#maximum-type) of the two operands.\n3. Promote both operands to the resulting type if both are simple expressions\n4. The resulting type of the expression is the [maximum type](#maximum-type).\n\n#### 2. Addition with left side being a pointer\n\n1. Resolve the operands.\n2. If the rhs is not an integer, this is an error.   \n3. If the rhs has a bit width that exceeds isz, this is an error.\n4. The result of the expression is the lhs type.\n\n#### 3. Subtraction with lhs pointer and rhs integer \n\n1. Resolve the operands.\n2. If the right hand type has a bit width that exceeds isz, this is an error.\n3. The result of the expression is the left hand type.\n\n#### 4. Subtraction with both sides pointers\n\n1. Resolve the operands.\n2. If the either side is a `void*`, it is cast to the other type.\n3. If the types of the sides are different, this is an error.   \n4. The result of the expression is isz.\n5. If this result exceeds the target width, this is an error.\n\n#### 6. Bit operations `^` `&` `|`\n\nThese operations are only valid for integers and booleans.\n\n1. Resolve the operands.\n2. Find the [maximum type](#maximum-type) of the two operands.\n3. Promote both operands to the [maximum type](#maximum-type) if they are simple expressions.\n4. The result of the expression is the [maximum type](#maximum-type).\n\n#### 6. Shift operations `<<` `>>` \n\nThese operations are only valid for integers.\n\n1. Resolve the operands.\n2. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side.\n3. The result of the expression is the lhs type.\n\n#### 7. Assignment operations `+=` `-=` `*=` `*=` `/=` `%=` `^=` `|=` `&=`\n\n1. Resolve the lhs.\n2. Resolve the right operand as an assignment rhs.\n3. The result of the expression is the lhs type.\n\n#### 8. Assignment shift `>>=` `<<=`\n\n1. Resolve both operands\n2. In safe mode, insert a trap to ensure that rhs >= 0 and rhs < bit width of the left hand side.\n3. The result of the expression is the lhs type.\n\n#### 9. `&&` and `||`\n\n1. Resolve both operands.\n2. Insert bool cast of both operands.\n3. The type is bool.\n\n#### 10. `<=` `==` `>=` `!=`\n\n1. Resolve the operands, left to right.\n2. Find the [maximum type](#maximum-type) of the two operands.\n3. Promote both operands to the [maximum type](#maximum-type).\n4. The type is bool.\n\n## Unary conversions\n\n#### 1. Bit negate\n\n1. Resolve the inner operand.\n2. If the inner type is not an integer this is an error.   \n2. The type is the inner type.\n\n#### 2. Boolean not\n\n1. Resolve the inner operand.\n2. The type is bool.\n\n#### 3. Negation\n\n1. Resolve the inner operand.\n2. If the type inner type is not a number this is an error.\n3. If the inner type is an unsigned integer, cast it to the same signed type.\n4. The type is the type of the result from (3)\n\n#### 4. `&` and `&&`\n\n1. Resolve the inner operand.\n2. The type is a pointer to the type of the inner operand.\n\n#### 5. `*`\n\n1. Resolve the inner operand.\n2. If the operand is not a pointer, or is a `void* ` pointer, this is an error.\n3. The type is the pointee of the inner operand's type.\n\nDereferencing 0 is implementation defined.\n\n#### 6. `++` and `--`\n\n1. Resolve the inner operand.\n2. If the type is not a number, this is an error.\n3. The type is the same as the inner operand.\n\n## Base expressions\n\n#### 1. Typed identifiers\n\n1. The type is that of the declaration.\n2. If the width of the type is less than that of the target type, widen to the target type.\n3. If the width of the type is greater than that of the target type, it is an error.\n\n#### 2. Constants and literals\n\n1. If the constant is an integer, it is assumed to be the *arithmetic promotion width* and signed. \nIf the suffix `u` is added, it is assumed to be an unsigned number. If a suffix `ixx` or `uxx` \nis given then it is considered a an integer of that type width and signedness. It cannot be implicitly narrowed. \n2. If the constant is a floating point value, it is assumed to be a `double` unless suffixed\n with `f` which is then assumed to be a `float`. If a bit width is given after `f`, \n it is instead a floating point type of that width.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"conversion-rules-for-c3","text":"Conversion Rules For C3"},{"depth":3,"slug":"target-type","text":"Target type"},{"depth":3,"slug":"common-arithmetic-promotion","text":"Common arithmetic promotion"},{"depth":3,"slug":"implicit-narrowing","text":"Implicit narrowing"},{"depth":3,"slug":"implicit-widening","text":"Implicit widening"},{"depth":3,"slug":"maximum-type","text":"Maximum type"},{"depth":3,"slug":"substruct-conversions","text":"Substruct conversions"},{"depth":3,"slug":"pointer-conversions","text":"Pointer conversions"},{"depth":3,"slug":"vector-conversions","text":"Vector conversions"},{"depth":2,"slug":"binary-conversions","text":"Binary conversions"},{"depth":4,"slug":"1-multiplication-division-remainder-subtraction--addition-with-both-operands-being-numbers","text":"1. Multiplication, division, remainder, subtraction / addition with both operands being numbers"},{"depth":4,"slug":"2-addition-with-left-side-being-a-pointer","text":"2. Addition with left side being a pointer"},{"depth":4,"slug":"3-subtraction-with-lhs-pointer-and-rhs-integer","text":"3. Subtraction with lhs pointer and rhs integer"},{"depth":4,"slug":"4-subtraction-with-both-sides-pointers","text":"4. Subtraction with both sides pointers"},{"depth":4,"slug":"6-bit-operations--","text":"6. Bit operations ^ & |"},{"depth":4,"slug":"6-shift-operations-","text":"6. Shift operations << >>"},{"depth":4,"slug":"7-assignment-operations---------","text":"7. Assignment operations += -= *= *= /= %= ^= |= &="},{"depth":4,"slug":"8-assignment-shift-","text":"8. Assignment shift >>= <<="},{"depth":4,"slug":"9--and","text":"9. && and ||"},{"depth":4,"slug":"10---","text":"10. <= == >= !="},{"depth":2,"slug":"unary-conversions","text":"Unary conversions"},{"depth":4,"slug":"1-bit-negate","text":"1. Bit negate"},{"depth":4,"slug":"2-boolean-not","text":"2. Boolean not"},{"depth":4,"slug":"3-negation","text":"3. Negation"},{"depth":4,"slug":"4--and","text":"4. & and &&"},{"depth":4,"slug":"5","text":"5. *"},{"depth":4,"slug":"6--and--","text":"6. ++ and --"},{"depth":2,"slug":"base-expressions","text":"Base expressions"},{"depth":4,"slug":"1-typed-identifiers","text":"1. Typed identifiers"},{"depth":4,"slug":"2-constants-and-literals","text":"2. Constants and literals"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
