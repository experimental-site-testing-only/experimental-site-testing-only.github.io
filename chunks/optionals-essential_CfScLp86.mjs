const id = "Language Common/optionals-essential.md";
						const collection = "docs";
						const slug = "language-common/optionals-essential";
						const body = "\nIn this section we will go over the *essential* information about Optionals and safe methods for working with them, for example\n [`if (catch optional_value)`](#checking-if-an-optional-is-empty)\n and the [Rethrow operator `!`](#using-the-rethrow-operator--to-unwrap-an-optional-value).\n\nIn the [advanced section](/language-common/optionals-advanced/) there are other *nice to have* features.\nLike an alternative to safely unwrap a result from an Optionals using\n[`if (try optional_value)`](/language-common/optionals-advanced/#run-code-if-the-optional-has-a-result)\nand an unsafe method to [force unwrap `!!`](/language-common/optionals-advanced/#force-unwrapping-expressions)\na result from an Optional, return [default values for optionals `??`](/language-common/optionals-advanced/#return-a-default-value-if-optional-is-empty) if they are empty and other more specialised concepts.\n\n## What is an Optional?\n\nOptionals are a safer alternative to returning `-1` or `null` from\na function, when a valid value can't be returned. An Optional\nhas either a *result* or is *empty*. When an Optional\nis empty it has an `Excuse` explaining what happened.\n\n- For example trying to open a missing file returns the `Excuse` of `io::FILE_NOT_FOUND`.\n- Optionals are declared by adding `?` after the type.\n- An `Excuse` is of type `fault`.\n```c3\nint? a = 1; // Set the Optional to a result\n```\nThe Optional Excuse is set with `?` after the value.\n```c3\n// Set the Optional to empty with a specific Excuse.\nint? b = io::FILE_NOT_FOUND?;\n```\n\nfaults are declared without namespacing, so for example `io::FILE_NOT_FOUND` is `io::FILE_NOT_FOUND`.\nOther than that semantics is unchanged.\n\n## üéÅ Unwrapping an Optional\n:::note\n\nUnwrapping an Optional is safe because it checks it has a\nresult present before trying to use it.\n\nAfter unwrapping, the variable then behaves like a normal variable, a non-Optional.\n:::\n\n## Checking if an Optional is empty\n\n```c3\nimport std::io;\n\nfn void? test()\n{\n    // Return an Excuse by adding '?' after the fault.\n    return io::FILE_NOT_FOUND?;\n}\n\nfn void main(String[] args)\n{\n    // If the Optional is empty, assign the\n    // Excuse to a variable:\n    if (catch excuse = test())\n    {\n        io::printfn(\"test() gave an Excuse: %s\", excuse);\n    }\n}\n```\n\n### Automatically unwrapping an Optional result\n\nIf we escape the current scope from an `if (catch my_var)` using a `return`, `break`, `continue`\nor [Rethrow](#using-the-rethrow-operator--to-unwrap-an-optional-value) `!`,\nthen the variable is automatically [unwrapped](#-unwrapping-an-optional) to a non-Optional:\n```c3\nfn void? test()\n{\n    int? foo = unreliable_function();\n    if (catch excuse = foo)\n    {\n        // Return the excuse with `?` operator\n        return excuse?;\n    }\n    // Because the compiler knows 'foo' cannot\n    // be empty here, it is unwrapped to non-Optional\n    // 'int foo' in this scope:\n    io::printfn(\"foo: %s\", foo); // 7\n}\n```\n### Using the Rethrow operator `!` to unwrap an Optional value\n\n- The Rethrow operator `!` will return from the function with the `Excuse` if the Optional result is empty.\n- The resulting value will be [unwrapped](#-unwrapping-an-optional) to a non-Optional.\n\n```c3\nimport std::io;\n\n// Function returning an Optional\nfn int? maybe_func() { /* ... */ }\n\nfn void? test()\n{\n    // ‚ùå This will be a compile error\n    // maybe_function() returns an Optional\n    // and 'bar' is not declared Optional:\n    // int bar = maybe_function();\n\n    int bar = maybe_function()!;\n    // ‚úÖ The above is equivalent to:\n    // int? temp = maybe_function();\n    // if (catch excuse = temp) return excuse?\n\n    // Now temp is unwrapped to a non-Optional\n    int bar = temp; // ‚úÖ This is OK\n}\n```\n\n## ‚ö†Ô∏è Optionals affect types and control flow\n\n### Optionals in expressions produce Optionals\nUse an Optional anywhere in an expression the resulting\nexpression will be an Optional too.\n```c3\nimport std::io;\n\nfn void main(String[] args)\n{\n    // Returns Optional with result of type `int` or an Excuse\n    int? first_optional = 7;\n\n    // This is Optional too:\n    int? second_optional = first_optional + 1;\n}\n```\n\n### Optionals affect function return types\n\n```c3\nimport std::io;\n\nfn int test(int input)\n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int? optional_argument = 7;\n\n    // `optional_argument` makes returned `returned_optional`\n    // Optional too:\n    int? returned_optional = test(optional_argument);\n}\n```\n\n### Functions conditionally run when called with Optional arguments\n\nWhen calling a function with an Optionals as arguments,\nthe result will be the first Excuse found looking left-to-right.\nThe function is only executed if all Optional arguments\nhave a result.\n\n```c3\nimport std::io;\n\nfn int test(int input, int input2)\n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int? first_optional = io::FILE_NOT_FOUND?;\n    int? second_optional = 7;\n\n    // Return first excuse we find\n    int? third_optional = test(first_optional, second_optional);\n    if (catch excuse = third_optional)\n    {\n        // excuse == io::FILE_NOT_FOUND\n        io::printfn(\"third_optional's Excuse: %s\", excuse);\n    }\n}\n```\n\n## Interfacing with C\n\nFor C the interface to C3:\n- The `Excuse` in the Optional of type `fault` is returned as the regular return.\n- The result in the Optional is passed by reference.\n\nFor example:\n\n\n```c3\n// C3 code:\nfn int? get_value();\n```\n\n```c\n// Corresponding C code:\nc3fault_t get_value(int *value_ref);\n```\nThe `c3fault_t` is guaranteed to be a pointer sized value.\n";
						const data = {title:"Essential Error Handling",description:"Essential Error Handling",editUrl:true,head:[],template:"doc",sidebar:{order:64,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Common/optionals-essential.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
