const id = "Previous Versions/v0_6_8/Implementation Details/grammar.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/implementation-details/grammar";
						const body = "\n## Keywords\n\nThe following are reserved keywords used by C3:\n\n```\nvoid        bool        char        double\nfloat       float16     int128      ichar\nint         iptr        isz         long\nshort       uint128     uint        ulong\nuptr        ushort      usz         float128\nany         anyfault    typeid      assert\nasm         bitstruct   break       case\ncatch       const       continue    def\ndefault     defer       distinct    do\nelse        enum        extern      false\nfault       for         foreach     foreach_r\nfn          tlocal      if          inline\nimport      macro       module      nextcase\nnull        return      static      struct\nswitch      true        try         union\nvar         while\n```\n\n```\n$alignof    $assert     $case       $default    \n$defined    $echo       $embed      $exec\n$else       $endfor     $endforeach $endif      \n$endswitch  $eval       $evaltype   $error      \n$extnameof  $for        $foreach    $if         \n$include    $nameof     $offsetof   $qnameof    \n$sizeof     $stringify  $switch     $typefrom   \n$typeof     $vacount    $vatype     $vaconst    \n$varef      $vaarg      $vaexpr     $vasplat\n```\n\nThe following attributes are built in:\n```\n@align        @benchmark  @bigendian  @builtin\n@cdecl        @deprecated @dynamic    @export\n@extern       @extname    @inline     @interface\n@littleendian @local      @maydiscard @naked\n@nodiscard    @noinit     @noinline   @noreturn\n@nostrip      @obfuscate  @operator   @overlap\n@packed       @priority   @private    @public\n@pure         @reflect    @section    @stdcall\n@test         @unused     @used       @veccall\n@wasm         @weak       @winmain\n```\n\nThe following constants are defined:\n```\n$$BENCHMARK_FNS  $$BENCHMARK_NAMES $$DATE\n$$FILE           $$FILEPATH        $$FUNC\n$$FUNCTION       $$LINE            $$LINE_RAW\n$$MODULE         $$TEST_FNS        $$TEST_NAMES\n$$TIME\n```\n\n## Yacc grammar\n\n```c\n%{\n\n#include <stdio.h>\n#define YYERROR_VERBOSE\nint yydebug = 1;\nextern char yytext[];\nextern int column;\nint yylex(void);\nvoid yyerror(char *s);\n%}\n\n%token IDENT HASH_IDENT CT_IDENT CONST_IDENT\n%token TYPE_IDENT CT_TYPE_IDENT\n%token AT_TYPE_IDENT AT_IDENT CT_INCLUDE\n%token STRING_LITERAL INTEGER\n%token INC_OP DEC_OP SHL_OP SHR_OP LE_OP GE_OP EQ_OP NE_OP\n%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN\n%token SUB_ASSIGN SHL_ASSIGN SHR_ASSIGN AND_ASSIGN\n%token XOR_ASSIGN OR_ASSIGN VAR NUL ELVIS NEXTCASE ANYFAULT\n%token MODULE IMPORT DEF EXTERN\n%token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOID USZ ISZ UPTR IPTR ANY\n%token ICHAR USHORT UINT ULONG BOOL INT128 UINT128 FLOAT16 FLOAT128 BFLOAT16\n%token TYPEID BITSTRUCT STATIC BANGBANG AT_CONST_IDENT HASH_TYPE_IDENT\n%token STRUCT UNION ENUM ELLIPSIS DOTDOT BYTES\n\n%token CT_ERROR\n%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR CONTINUE BREAK RETURN FOREACH_R FOREACH\n%token FN FAULT MACRO CT_IF CT_ENDIF CT_ELSE CT_SWITCH CT_CASE CT_DEFAULT CT_FOR CT_FOREACH CT_ENDFOREACH\n%token CT_ENDFOR CT_ENDSWITCH BUILTIN IMPLIES INITIALIZE FINALIZE CT_ECHO CT_ASSERT CT_EVALTYPE CT_VATYPE\n%token TRY CATCH SCOPE DEFER LVEC RVEC OPTELSE CT_TYPEFROM CT_TYPEOF TLOCAL\n%token CT_VASPLAT INLINE DISTINCT CT_VACONST CT_NAMEOF CT_VAREF CT_VACOUNT CT_VAARG\n%token CT_SIZEOF CT_STRINGIFY CT_QNAMEOF CT_OFFSETOF CT_VAEXPR\n%token CT_EXTNAMEOF CT_EVAL CT_DEFINED CT_CHECKS CT_ALIGNOF ASSERT\n%token ASM CHAR_LITERAL REAL TRUE FALSE CT_CONST_IDENT\n%token LBRAPIPE RBRAPIPE HASH_CONST_IDENT\n\n%start translation_unit\n%%\n\npath\n    \t: IDENT SCOPE\n    \t| path IDENT SCOPE\n    \t;\n\npath_const\n\t: path CONST_IDENT\n\t| CONST_IDENT\n\t;\n\npath_ident\n\t: path IDENT\n\t| IDENT\n\t;\n\npath_at_ident\n\t: path AT_IDENT\n\t| AT_IDENT\n\t;\n\nident_expr\n\t: CONST_IDENT\n\t| IDENT\n\t| AT_IDENT\n\t;\n\nlocal_ident_expr\n\t: CT_IDENT\n        | HASH_IDENT\n\t;\n\nct_call\n\t: CT_ALIGNOF\n\t| CT_DEFINED\n\t| CT_EXTNAMEOF\n\t| CT_NAMEOF\n\t| CT_OFFSETOF\n\t| CT_QNAMEOF\n\t;\n\nct_analyse\n\t: CT_EVAL\n\t| CT_SIZEOF\n\t| CT_STRINGIFY\n\t;\n\nct_arg\n\t: CT_VACONST\n        | CT_VAARG\n        | CT_VAREF\n        | CT_VAEXPR\n\t;\n\nflat_path\n\t: primary_expr param_path\n\t| type\n\t| primary_expr\n\t;\n\nmaybe_optional_type\n\t: optional_type\n\t| empty\n\t;\n\nstring_expr\n\t: STRING_LITERAL\n\t| string_expr STRING_LITERAL\n\t;\n\nbytes_expr\n\t: BYTES\n\t| bytes_expr BYTES\n\t;\n\nexpr_block\n\t: LBRAPIPE opt_stmt_list RBRAPIPE\n\t;\n\nbase_expr\n\t: string_expr\n\t| INTEGER\n\t| bytes_expr\n\t| NUL\n\t| BUILTIN CONST_IDENT\n\t| BUILTIN IDENT\n\t| CHAR_LITERAL\n\t| REAL\n\t| TRUE\n\t| FALSE\n\t| path ident_expr\n\t| ident_expr\n\t| local_ident_expr\n\t| type initializer_list\n\t| type '.' access_ident\n\t| type '.' CONST_IDENT\n\t| '(' expr ')'\n\t| expr_block\n\t| ct_call '(' flat_path ')'\n\t| ct_arg '(' expr ')'\n\t| ct_analyse '(' expr ')'\n\t| CT_VACOUNT\n\t| CT_CHECKS '(' expression_list ')'\n\t| lambda_decl compound_statement\n\t;\n\nprimary_expr\n\t: base_expr\n\t| initializer_list\n\t;\n\nrange_loc\n\t: expr\n\t| '^' expr\n\t;\n\nrange_expr\n\t: range_loc DOTDOT range_loc\n\t| range_loc DOTDOT\n\t| DOTDOT range_loc\n\t| range_loc ':' range_loc\n\t| ':' range_loc\n\t| range_loc ':'\n\t| DOTDOT\n\t;\n\n\ncall_inline_attributes\n\t: AT_IDENT\n\t| call_inline_attributes AT_IDENT\n\t;\n\ncall_invocation\n\t: '(' call_arg_list ')'\n\t| '(' call_arg_list ')' call_inline_attributes\n\t;\n\naccess_ident\n\t: IDENT\n\t| AT_IDENT\n\t| HASH_IDENT\n\t| CT_EVAL '(' expr ')'\n\t| TYPEID\n\t;\n\ncall_trailing\n\t: '[' range_loc ']'\n\t| '[' range_expr ']'\n\t| call_invocation\n\t| call_invocation compound_statement\n\t| '.' access_ident\n\t| INC_OP\n\t| DEC_OP\n\t| '!'\n\t| BANGBANG\n\t;\n\ncall_stmt_expr\n\t: base_expr\n\t| call_stmt_expr call_trailing\n\t;\n\ncall_expr\n\t: primary_expr\n\t| call_expr call_trailing\n\t;\n\nunary_expr\n\t: call_expr\n\t| unary_op unary_expr\n\t;\n\nunary_stmt_expr\n\t: call_stmt_expr\n\t| unary_op unary_expr\n\t;\n\nunary_op\n\t: '&'\n\t| AND_OP\n\t| '*'\n\t| '+'\n\t| '-'\n\t| '~'\n\t| '!'\n\t| INC_OP\n\t| DEC_OP\n\t| '(' type ')'\n\t;\n\nmult_op\n\t: '*'\n\t| '/'\n\t| '%'\n    \t;\n\nmult_expr\n\t: unary_expr\n\t| mult_expr mult_op unary_expr\n\t;\n\nmult_stmt_expr\n\t: unary_stmt_expr\n\t| mult_stmt_expr mult_op unary_expr\n\t;\n\nshift_op\n\t: SHL_OP\n\t| SHR_OP\n\t;\n\nshift_expr\n\t: mult_expr\n\t| shift_expr shift_op mult_expr\n\t;\n\nshift_stmt_expr\n\t: mult_stmt_expr\n\t| shift_stmt_expr shift_op mult_expr\n\t;\n\n\nbit_op\n    \t: '&'\n    \t| '^'\n    \t| '|'\n    \t;\n\nbit_expr\n\t: shift_expr\n\t| bit_expr bit_op shift_expr\n\t;\n\nbit_stmt_expr\n\t: shift_stmt_expr\n\t| bit_stmt_expr bit_op shift_expr\n\t;\n\nadditive_op\n\t: '+'\n\t| '-'\n    \t;\n\nadditive_expr\n\t: bit_expr\n\t| additive_expr additive_op bit_expr\n\t;\n\nadditive_stmt_expr\n\t: bit_stmt_expr\n\t| additive_stmt_expr additive_op bit_expr\n\t;\n\nrelational_op\n\t: '<'\n\t| '>'\n\t| LE_OP\n\t| GE_OP\n\t| EQ_OP\n\t| NE_OP\n\t;\n\nrelational_expr\n\t: additive_expr\n\t| relational_expr relational_op additive_expr\n\t;\n\nrelational_stmt_expr\n\t: additive_stmt_expr\n\t| relational_stmt_expr relational_op additive_expr\n\t;\n\nrel_or_lambda_expr\n\t: relational_expr\n\t| lambda_decl IMPLIES relational_expr\n\t;\n\nand_expr\n\t: relational_expr\n\t| and_expr AND_OP relational_expr\n\t;\n\nand_stmt_expr\n\t: relational_stmt_expr\n\t| and_stmt_expr AND_OP relational_expr\n\t;\n\nor_expr\n\t: and_expr\n\t| or_expr OR_OP and_expr\n\t;\n\nor_stmt_expr\n\t: and_stmt_expr\n\t| or_stmt_expr OR_OP and_expr\n\t;\n\nor_expr_with_suffix\n\t: or_expr\n\t| or_expr '?'\n\t| or_expr '?' '!'\n\t;\n\nor_stmt_expr_with_suffix\n\t: or_stmt_expr\n\t| or_stmt_expr '?'\n\t| or_stmt_expr '?' '!'\n\t;\n\nternary_expr\n\t: or_expr_with_suffix\n\t| or_expr '?' expr ':' ternary_expr\n\t| or_expr_with_suffix ELVIS ternary_expr\n\t| or_expr_with_suffix OPTELSE ternary_expr\n\t| lambda_decl implies_body\n\t;\n\nternary_stmt_expr\n\t: or_stmt_expr_with_suffix\n\t| or_stmt_expr '?' expr ':' ternary_expr\n\t| or_stmt_expr_with_suffix ELVIS ternary_expr\n\t| or_stmt_expr_with_suffix OPTELSE ternary_expr\n\t| lambda_decl implies_body\n\t;\n\nassignment_op\n\t: '='\n\t| ADD_ASSIGN\n\t| SUB_ASSIGN\n\t| MUL_ASSIGN\n\t| DIV_ASSIGN\n\t| MOD_ASSIGN\n\t| SHL_ASSIGN\n\t| SHR_ASSIGN\n\t| AND_ASSIGN\n\t| XOR_ASSIGN\n\t| OR_ASSIGN\n\t;\n\nempty\n\t:\n\t;\n\nassignment_expr\n    \t: ternary_expr\n    \t| CT_TYPE_IDENT '=' type\n    \t| unary_expr assignment_op assignment_expr\n    \t;\nassignment_stmt_expr\n    \t: ternary_stmt_expr\n    \t| CT_TYPE_IDENT '=' type\n    \t| unary_stmt_expr assignment_op assignment_expr\n    \t;\n\nimplies_body\n\t: IMPLIES expr\n\t;\n\nlambda_decl\n\t: FN maybe_optional_type fn_parameter_list opt_attributes\n\t;\n\nexpr_no_list\n\t: assignment_stmt_expr\n\t;\n\nexpr\n\t: assignment_expr\n\t;\n\n\nconstant_expr\n\t: ternary_expr\n\t;\n\nparam_path_element\n\t: '[' expr ']'\n\t| '[' expr DOTDOT expr ']'\n\t| '.' IDENT\n\t;\n\nparam_path\n\t: param_path_element\n\t| param_path param_path_element\n\t;\n\narg\t: param_path '=' expr\n\t| type\n\t| param_path '=' type\n\t| expr\n\t| CT_VASPLAT '(' range_expr ')'\n\t| CT_VASPLAT '(' ')'\n\t| ELLIPSIS expr\n\t;\n\narg_list\n\t: arg\n\t| arg_list ',' arg\n\t;\n\ncall_arg_list\n\t: arg_list\n\t| arg_list ';'\n\t| arg_list ';' parameters\n\t| ';'\n\t| ';' parameters\n\t| empty\n\t;\n\nopt_arg_list_trailing\n\t: arg_list\n\t| arg_list ','\n\t| empty\n\t;\n\nenum_constants\n    : enum_constant\n    | enum_constants ',' enum_constant\n    ;\n\nenum_list\n\t: enum_constants\n\t| enum_constants ','\n\t;\n\nenum_constant\n\t: CONST_IDENT\n\t| CONST_IDENT '(' arg_list ')'\n\t| CONST_IDENT '(' arg_list ',' ')'\n\t;\n\nidentifier_list\n\t: IDENT\n\t| identifier_list ',' IDENT\n\t;\n\nenum_param_decl\n\t: type\n\t| type IDENT\n\t| type IDENT '=' expr\n\t;\n\nbase_type\n    : VOID\n    | BOOL\n    | CHAR\n    | ICHAR\n    | SHORT\n    | USHORT\n    | INT\n    | UINT\n    | LONG\n    | ULONG\n    | INT128\n    | UINT128\n    | FLOAT\n    | DOUBLE\n    | FLOAT16\n    | BFLOAT16\n    | FLOAT128\n    | IPTR\n    | UPTR\n    | ISZ\n    | USZ\n    | ANYFAULT\n    | ANY\n    | TYPEID\n    | TYPE_IDENT\n    | path TYPE_IDENT\n    | CT_TYPE_IDENT\n    | CT_TYPEOF '(' expr ')'\n    | CT_TYPEFROM '(' constant_expr ')'\n    | CT_VATYPE '(' constant_expr ')'\n    | CT_EVALTYPE '(' constant_expr ')'\n    ;\n\ntype\n    : base_type\n    | type '*'\n    | type '[' constant_expr ']'\n    | type '[' ']'\n    | type '[' '*' ']'\n    | type LVEC constant_expr RVEC\n    | type LVEC '*' RVEC\n    ;\n\noptional_type\n    : type\n    | type '!'\n    ;\n\nlocal_decl_after_type\n\t: CT_IDENT\n\t| CT_IDENT '=' constant_expr\n\t| IDENT opt_attributes\n\t| IDENT opt_attributes '=' expr\n\t;\n\nlocal_decl_storage\n\t: STATIC\n\t| TLOCAL\n\t;\n\ndecl_or_expr\n\t: var_decl\n\t| optional_type local_decl_after_type\n\t| expr\n\t;\n\nvar_decl\n\t: VAR IDENT '=' expr\n\t| VAR CT_IDENT '=' expr\n\t| VAR CT_IDENT\n\t| VAR CT_TYPE_IDENT '=' type\n\t| VAR CT_TYPE_IDENT\n\t;\n\ninitializer_list\n\t: '{' opt_arg_list_trailing '}'\n\t;\n\nct_case_stmt\n    \t: CT_CASE constant_expr ':' opt_stmt_list\n    \t| CT_CASE type ':' opt_stmt_list\n    \t| CT_DEFAULT ':' opt_stmt_list\n    \t;\n\nct_switch_body\n\t: ct_case_stmt\n    \t| ct_switch_body ct_case_stmt\n    \t;\n\nct_for_stmt\n    \t: CT_FOR '(' for_cond ')' opt_stmt_list CT_ENDFOR\n\t;\n\nct_foreach_stmt\n\t: CT_FOREACH '(' CT_IDENT ':' expr ')' opt_stmt_list CT_ENDFOREACH\n\t| CT_FOREACH '(' CT_IDENT ',' CT_IDENT ':' expr ')' opt_stmt_list CT_ENDFOREACH\n\t;\nct_switch\n    \t: CT_SWITCH '(' constant_expr ')'\n    \t| CT_SWITCH '(' type ')'\n    \t| CT_SWITCH\n   \t;\n\nct_switch_stmt\n\t: ct_switch ct_switch_body CT_ENDSWITCH\n\t;\n\nvar_stmt\n\t: var_decl ';'\n\ndecl_stmt_after_type\n\t: local_decl_after_type\n\t| decl_stmt_after_type ',' local_decl_after_type\n\t;\n\ndeclaration_stmt\n\t: const_declaration\n\t| local_decl_storage optional_type decl_stmt_after_type ';'\n\t| optional_type decl_stmt_after_type ';'\n\t;\n\nreturn_stmt\n\t: RETURN expr ';'\n\t| RETURN ';'\n\t;\n\ncatch_unwrap_list\n\t: relational_expr\n\t| catch_unwrap_list ',' relational_expr\n\t;\n\ncatch_unwrap\n\t: CATCH catch_unwrap_list\n\t| CATCH IDENT '=' catch_unwrap_list\n\t| CATCH type IDENT '=' catch_unwrap_list\n\t;\n\ntry_unwrap\n\t: TRY rel_or_lambda_expr\n\t| TRY IDENT '=' rel_or_lambda_expr\n\t| TRY type IDENT '=' rel_or_lambda_expr\n\t;\n\ntry_unwrap_chain\n\t: try_unwrap\n\t| try_unwrap_chain AND_OP try_unwrap\n\t| try_unwrap_chain AND_OP rel_or_lambda_expr\n\t;\n\ndefault_stmt\n\t: DEFAULT ':' opt_stmt_list\n\t;\n\ncase_stmt\n\t: CASE expr ':' opt_stmt_list\n\t| CASE expr DOTDOT expr ':' opt_stmt_list\n\t| CASE type ':' opt_stmt_list\n\t;\n\nswitch_body\n\t: case_stmt\n\t| default_stmt\n\t| switch_body case_stmt\n\t| switch_body default_stmt\n\t;\n\ncond_repeat\n\t: decl_or_expr\n\t| cond_repeat ',' decl_or_expr\n\t;\n\ncond\n\t: try_unwrap_chain\n\t| catch_unwrap\n\t| cond_repeat\n\t| cond_repeat ',' try_unwrap_chain\n\t| cond_repeat ',' catch_unwrap\n\t;\n\nelse_part\n\t: ELSE if_stmt\n\t| ELSE compound_statement\n\t;\n\nif_stmt\n\t: IF optional_label paren_cond '{' switch_body '}'\n\t| IF optional_label paren_cond '{' switch_body '}' else_part\n\t| IF optional_label paren_cond statement\n\t| IF optional_label paren_cond compound_statement else_part\n\t;\n\nexpr_list_eos\n\t: expression_list ';'\n\t| ';'\n\t;\n\ncond_eos\n\t: cond ';'\n\t| ';'\n\t;\n\nfor_cond\n\t: expr_list_eos cond_eos expression_list\n\t| expr_list_eos cond_eos\n\t;\n\nfor_stmt\n\t: FOR optional_label '(' for_cond ')' statement\n\t;\n\nparen_cond\n\t: '(' cond ')'\n\t;\n\nwhile_stmt\n\t: WHILE optional_label paren_cond statement\n\t;\n\ndo_stmt\n\t: DO optional_label compound_statement WHILE '(' expr ')' ';'\n\t| DO optional_label compound_statement ';'\n\t;\n\noptional_label_target\n\t: CONST_IDENT\n\t| empty\n\t;\n\ncontinue_stmt\n\t: CONTINUE optional_label_target ';'\n\t;\n\nbreak_stmt\n\t: BREAK optional_label_target ';'\n\t;\n\nnextcase_stmt\n\t: NEXTCASE CONST_IDENT ':' expr ';'\n\t| NEXTCASE expr ';'\n\t| NEXTCASE CONST_IDENT ':' type ';'\n\t| NEXTCASE type ';'\n\t| NEXTCASE ';'\n\t;\n\nforeach_var\n\t: optional_type '&' IDENT\n\t| optional_type IDENT\n\t| '&' IDENT\n\t| IDENT\n\t;\n\nforeach_vars\n\t: foreach_var\n\t| foreach_var ',' foreach_var\n\t;\n\nforeach_stmt\n\t: FOREACH optional_label '(' foreach_vars ':' expr ')' statement\n\t: FOREACH_R optional_label '(' foreach_vars ':' expr ')' statement\n\t;\n\ndefer_stmt\n\t: DEFER statement\n\t| DEFER TRY statement\n\t| DEFER CATCH statement\n\t;\n\nct_if_stmt\n\t: CT_IF constant_expr ':' opt_stmt_list CT_ENDIF\n\t| CT_IF constant_expr ':' opt_stmt_list CT_ELSE opt_stmt_list CT_ENDIF\n\t;\n\nassert_expr\n\t: try_unwrap_chain\n\t| expr\n\t;\n\nassert_stmt\n\t: ASSERT '(' assert_expr ')' ';'\n\t| ASSERT '(' assert_expr ',' expr ')' ';'\n\t;\n\nasm_stmts\n\t: asm_stmt\n\t| asm_stmts asm_stmt\n\t;\n\nasm_instr\n\t: INT\n\t| IDENT\n\t| INT '.' IDENT\n\t| IDENT '.' IDENT\n\t;\n\nasm_addr\n\t: asm_expr\n\t| asm_expr additive_op asm_expr\n\t| asm_expr additive_op asm_expr '*' INTEGER\n\t| asm_expr additive_op asm_expr '*' INTEGER additive_op INTEGER\n\t| asm_expr additive_op asm_expr shift_op INTEGER\n\t| asm_expr additive_op asm_expr additive_op INTEGER\n\t;\n\nasm_expr\n\t: CT_IDENT\n\t| CT_CONST_IDENT\n\t| IDENT\n\t| '&' IDENT\n\t| CONST_IDENT\n\t| REAL\n\t| INTEGER\n\t| '(' expr ')'\n\t| '[' asm_addr ']'\n\nasm_exprs\n\t: asm_expr\n\t| asm_exprs ',' asm_expr\n\t;\n\nasm_stmt\n\t: asm_instr asm_exprs ';'\n\t| asm_instr ';'\n\t;\n\nasm_block_stmt\n\t: ASM '(' expr ')'\n\t| ASM '{' asm_stmts '}'\n\t| ASM '{' '}'\n\t;\n\n\n/* Order here matches compiler */\nstatement\n\t: compound_statement\n\t| var_stmt\n\t| declaration_stmt\n\t| return_stmt\n\t| if_stmt\n\t| while_stmt\n\t| defer_stmt\n\t| switch_stmt\n\t| do_stmt\n\t| for_stmt\n\t| foreach_stmt\n\t| continue_stmt\n\t| break_stmt\n\t| nextcase_stmt\n\t| asm_block_stmt\n        | ct_echo_stmt\n\t| ct_assert_stmt\n        | ct_if_stmt\n        | ct_switch_stmt\n        | ct_foreach_stmt\n        | ct_for_stmt\n    \t| expr_no_list ';'\n        | assert_stmt\n        | ';'\n\t;\n\ncompound_statement\n\t: '{' opt_stmt_list '}'\n\t;\n\nstatement_list\n\t: statement\n\t| statement_list statement\n\t;\n\nopt_stmt_list\n\t: statement_list\n\t| empty\n\t;\n\nswitch_stmt\n\t: SWITCH optional_label '{' switch_body '}'\n\t| SWITCH optional_label '{' '}'\n\t| SWITCH optional_label paren_cond '{' switch_body '}'\n\t| SWITCH optional_label paren_cond '{' '}'\n\t;\n\nexpression_list\n    \t: decl_or_expr\n    \t| expression_list ',' decl_or_expr\n    \t;\n\noptional_label\n\t: CONST_IDENT ':'\n\t| empty\n\t;\n\nct_assert_stmt\n\t: CT_ASSERT constant_expr ':' constant_expr ';'\n\t| CT_ASSERT constant_expr ';'\n\t| CT_ERROR constant_expr ';'\n\t;\n\nct_include_stmt\n\t: CT_INCLUDE string_expr ';'\n\t;\n\nct_echo_stmt\n\t: CT_ECHO constant_expr ';'\n\nbitstruct_declaration\n\t: BITSTRUCT TYPE_IDENT ':' type opt_attributes bitstruct_body\n\nbitstruct_body\n\t: '{' '}'\n\t| '{' bitstruct_defs '}'\n\t| '{' bitstruct_simple_defs '}'\n\t;\n\nbitstruct_defs\n\t: bitstruct_def\n\t| bitstruct_defs bitstruct_def\n\t;\n\nbitstruct_simple_defs\n\t: base_type IDENT ';'\n\t| bitstruct_simple_defs base_type IDENT ';'\n\t;\n\nbitstruct_def\n\t: base_type IDENT ':' constant_expr DOTDOT constant_expr ';'\n\t| base_type IDENT ':' constant_expr ';'\n\t;\n\nstatic_declaration\n\t: STATIC INITIALIZE opt_attributes compound_statement\n\t| STATIC FINALIZE opt_attributes compound_statement\n\t;\n\nattribute_name\n\t: AT_IDENT\n\t| AT_TYPE_IDENT\n\t| path AT_TYPE_IDENT\n\t;\n\nattribute_operator_expr\n\t: '&' '[' ']'\n\t| '[' ']' '='\n\t| '[' ']'\n\t;\n\nattr_param\n\t: attribute_operator_expr\n\t| constant_expr\n\t;\n\nattribute_param_list\n\t: attr_param\n\t| attribute_param_list ',' attr_param\n\t;\n\nattribute\n    : attribute_name\n    | attribute_name '(' attribute_param_list ')'\n    ;\n\nattribute_list\n\t: attribute\n\t| attribute_list attribute\n\t;\n\nopt_attributes\n   \t: attribute_list\n    \t| empty\n    \t;\n\ntrailing_block_param\n\t: AT_IDENT\n\t| AT_IDENT '(' ')'\n\t| AT_IDENT '(' parameters ')'\n\t;\n\nmacro_params\n\t: parameters\n\t| parameters ';' trailing_block_param\n\t| ';' trailing_block_param\n\t| empty\n\t;\n\nmacro_func_body\n\t: implies_body ';'\n\t| compound_statement\n\t;\n\nmacro_declaration\n    \t: MACRO macro_header '(' macro_params ')' opt_attributes macro_func_body\n\t;\n\nstruct_or_union\n\t: STRUCT\n\t| UNION\n\t;\n\nstruct_declaration\n\t: struct_or_union TYPE_IDENT opt_attributes struct_body\n    \t;\n\nstruct_body\n    \t: '{' struct_declaration_list '}'\n\t;\n\nstruct_declaration_list\n\t: struct_member_decl\n    \t| struct_declaration_list struct_member_decl\n    \t;\n\nenum_params\n\t: enum_param_decl\n\t| enum_params ',' enum_param_decl\n\t;\n\nenum_param_list\n\t: '(' enum_params ')'\n\t| '(' ')'\n\t| empty\n\t;\n\nstruct_member_decl\n    \t: type identifier_list opt_attributes ';'\n    \t| struct_or_union IDENT opt_attributes struct_body\n    \t| struct_or_union opt_attributes struct_body\n    \t| BITSTRUCT ':' type opt_attributes bitstruct_body\n    \t| BITSTRUCT IDENT ':' type opt_attributes bitstruct_body\n    \t| INLINE type IDENT opt_attributes ';'\n    \t| INLINE type opt_attributes ';'\n\t;\n\n\nenum_spec\n\t: ':' type enum_param_list\n\t| empty\n\t;\n\nenum_declaration\n\t: ENUM TYPE_IDENT enum_spec opt_attributes '{' enum_list '}'\n\t;\n\nfaults\n    : CONST_IDENT\n    | faults ',' CONST_IDENT\n    ;\n\nfault_declaration\n    \t: FAULT TYPE_IDENT opt_attributes '{' faults '}'\n    \t| FAULT TYPE_IDENT opt_attributes '{' faults ',' '}'\n    \t;\n\nfunc_macro_name\n\t: IDENT\n\t| AT_IDENT\n\t;\n\nfunc_header\n\t: optional_type type '.' func_macro_name\n\t| optional_type func_macro_name\n\t;\n\n\nmacro_header\n\t: func_header\n\t| type '.' func_macro_name\n\t| func_macro_name\n\t;\n\nfn_parameter_list\n\t: '(' parameters ')'\n\t| '(' ')'\n\t;\n\nparameters\n\t: parameter '=' expr\n\t| parameter\n\t| parameters ',' parameter\n\t| parameters ',' parameter '=' expr\n\t;\n\nparameter\n\t: type IDENT opt_attributes\n\t| type ELLIPSIS IDENT opt_attributes\n\t| type ELLIPSIS CT_IDENT\n\t| type CT_IDENT\n        | type ELLIPSIS opt_attributes\n\t| type HASH_IDENT opt_attributes\n\t| type '&' IDENT opt_attributes\n\t| type opt_attributes\n\t| '&' IDENT opt_attributes\n\t| HASH_IDENT opt_attributes\n\t| ELLIPSIS\n\t| IDENT opt_attributes\n\t| IDENT ELLIPSIS opt_attributes\n\t| CT_IDENT\n\t| CT_IDENT ELLIPSIS\n\t;\n\nfunc_definition\n\t: FN func_header fn_parameter_list opt_attributes ';'\n\t| FN func_header fn_parameter_list opt_attributes macro_func_body\n\t;\n\nconst_declaration\n\t: CONST CONST_IDENT opt_attributes '=' expr ';'\n\t| CONST type CONST_IDENT opt_attributes '=' expr ';'\n\t;\n\nfunc_typedef\n    : FN optional_type fn_parameter_list\n    ;\n\nopt_distinct_inline\n\t: DISTINCT\n\t| DISTINCT INLINE\n\t| INLINE DISTINCT\n\t| INLINE\n\t| empty\n\t;\n\ngeneric_parameters\n\t: bit_expr\n\t| type\n\t| generic_parameters ',' bit_expr\n\t| generic_parameters ',' type\n\t;\n\ntypedef_type\n\t: func_typedef\n\t| type opt_generic_parameters\n\t;\n\n\n\nmulti_declaration\n\t: ',' IDENT\n\t| multi_declaration ',' IDENT\n\t;\n\nglobal_storage\n\t: TLOCAL\n\t| empty\n\t;\n\nglobal_declaration\n    : global_storage optional_type IDENT opt_attributes ';'\n    | global_storage optional_type IDENT multi_declaration opt_attributes ';'\n    | global_storage optional_type IDENT opt_attributes '=' expr ';'\n    ;\n\nopt_tl_stmts\n\t: top_level_statements\n\t| empty\n\t;\n\ntl_ct_case\n\t: CT_CASE constant_expr ':' opt_tl_stmts\n\t| CT_CASE type ':' opt_tl_stmts\n    \t| CT_DEFAULT ':' opt_tl_stmts\n    \t;\n\ntl_ct_switch_body\n    \t: tl_ct_case\n    \t| tl_ct_switch_body tl_ct_case\n    \t;\n\ndefine_attribute\n\t: AT_TYPE_IDENT '(' parameters ')' opt_attributes '=' '{' opt_attributes '}'\n\t| AT_TYPE_IDENT opt_attributes '=' '{' opt_attributes '}'\n\t;\n\nopt_generic_parameters\n\t: '<' generic_parameters '>'\n\t| empty\n\t;\n\n\n\ndefine_ident\n\t: IDENT '=' path_ident opt_generic_parameters\n\t| CONST_IDENT '=' path_const opt_generic_parameters\n\t| AT_IDENT '=' path_at_ident opt_generic_parameters\n        ;\n\ndefine_declaration\n\t: DEF define_ident ';'\n\t| DEF define_attribute ';'\n\t| DEF TYPE_IDENT opt_attributes '=' opt_distinct_inline typedef_type ';'\n\t;\n\ntl_ct_if\n\t: CT_IF constant_expr ':' opt_tl_stmts CT_ENDIF\n\t| CT_IF constant_expr ':' opt_tl_stmts CT_ELSE opt_tl_stmts CT_ENDIF\n\t;\n\ntl_ct_switch\n\t: ct_switch tl_ct_switch_body CT_ENDSWITCH\n\t;\n\nmodule_param\n    \t: CONST_IDENT\n    \t| TYPE_IDENT\n    \t;\n\nmodule_params\n\t: module_param\n    \t| module_params ',' module_param\n    \t;\n\nmodule\n\t: MODULE path_ident opt_attributes ';'\n\t| MODULE path_ident '<' module_params '>' opt_attributes ';'\n\t;\n\nimport_paths\n\t: path_ident\n\t| path_ident ',' path_ident\n\t;\n\nimport_decl\n    \t: IMPORT import_paths opt_attributes ';'\n    \t;\n\ntranslation_unit\n    : top_level_statements\n    | empty\n    ;\n\ntop_level_statements\n    : top_level\n    | top_level_statements top_level\n    ;\n\nopt_extern\n\t: EXTERN\n\t| empty\n\t;\n\ntop_level\n\t: module\n\t| import_decl\n\t| opt_extern func_definition\n\t| opt_extern const_declaration\n\t| opt_extern global_declaration\n\t| ct_assert_stmt\n\t| ct_echo_stmt\n\t| ct_include_stmt\n\t| tl_ct_if\n\t| tl_ct_switch\n\t| struct_declaration\n\t| fault_declaration\n\t| enum_declaration\n\t| macro_declaration\n\t| define_declaration\n\t| static_declaration\n\t| bitstruct_declaration\n\t;\n\n\n%%\n\nvoid yyerror(char *s)\n{\n\tfflush(stdout);\n\tprintf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s);\n}\n\nint main(int argc, char *argv[])\n{\n\tyyparse();\n\treturn 0;\n}\n```";
						const data = {title:"Grammar",description:"Grammar",editUrl:true,head:[],template:"doc",sidebar:{order:999,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
