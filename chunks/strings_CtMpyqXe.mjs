const id = "Language Common/strings.md";
						const collection = "docs";
						const slug = "language-common/strings";
						const body = "In C3, multiple string types are available, each suited to different use cases.\n\n### `String`\n\n```c3\n\ntypedef String = inline char[];\n\n```\n\\\n`String`s are usually the typical type to use, they can be sliced , compared etc ... \\\nIt is possible to access the length of a `String` instance through the  ` .len  `  operator.\n\n\n### `ZString`\n\n```c3\n\ntypedef ZString = inline char*;\n```\n\n\n`ZString` is used when working with C code, which expects null-terminated C-style strings of type `char*`.\nIt is a `typedef` so converting to a `ZString` requires an explicit cast. This helps to remind the user to check there is appropriate `\\0` termination of the string data.\n\nThe [`ZString` methods](#zstring-member-functions) are outlined below.\n\n:::caution\nEnsure the terminal `\\0` when converting from `String` to `ZString`.\n:::\n\n#### `WString`\n\n```c3\n\ntypedef WString = inline Char16*;\n```\n\n\\\nThe `WString` type is similar to `ZString` but uses `Char16*`, typically for UTF-16 encoded strings. This type is useful for applications where 16-bit character encoding is required.\n\n#### `DString`\n\n```c3\n\ntypedef DString (OutStream) = void*;\n```\n\n\\\n`DString` is a dynamic string builder that supports various string operations at runtime, allowing for flexible manipulation without the need for manual memory allocation.\n\n## Member functions:\n\n### `String` Member Functions\n\n```c3\nfn Char16[]? String.to_new_utf16(s, Allocator allocator = allocator::heap())\n```\n\n```c3\nfn Char16[]? String.to_temp_utf16(s);\n```\n\n```c3\nfn WString? String.to_wstring(s, Allocator allocator)\n```\n\n```c3 implementation\nfn String String.free(&s, Allocator allocator = allocator::heap())\n```\n\n```c3 implementation\nfn String String.tcopy(s) => s.copy(allocator::temp()) @inline;\n```\n\n```c3 implementation\nfn String String.copy(s, Allocator allocator = allocator::heap())\n```\n\n```c3 implementation\nfn String String.strip_end(string, String needle);\n```\n\n```c3 implementation\nfn String String.strip(string, String needle);\n```\n\n```c3 implementation\nfn String String.trim(string, String to_trim);\n```\n\n```c3 implementation\nfn bool String.contains(string, String needle);\n```\n\n```c3 implementation\nfn bool String.starts_with(string, String needle);\n```\n\n```c3 implementation\nfn bool String.ends_with(string, String needle);\n```\n```c3 implementation\nfn usz? String.index_of_char(s, char needle);\n```\n\n```c3 implementation\nfn usz? String.index_of_char_from(s, char needle, usz start_index);\n```\n\n```c3 implementation\nfn usz? String.index_of(s, String needle)\n```\n\n```c3\nfn usz? String.rindex_of(s, String needle)\n```\n\n```c3 implementation\nfn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap());\n```\n\n```c3 implementation\nfn String String.new_split(s, String needle, usz max = 0) => s.split(needle, max, allocator::heap()) @inline;\n```\n\n```c3 implementation\n// temporary String split\nfn String String.tsplit(s, String needle, usz max = 0) => s.split(needle, max, allocator::temp());\n```\n\n```c3 implementation\nfn String String.tconcat(s1, String s2);\n```\n\n```c3 implementation\nfn String String.tconcat(s1, String s2) => s1.concat(s2, allocator::temp());\n```\n```c3 implementation\nfn WString? String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n```c3 implementation\nfn WString? String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n```c3 implementation\nfn int128? String.to_int128(s, int base = 10) => s.to_integer(int128, base);\n```\n```c3 implementation\nfn long? String.to_long(s, int base = 10) => s.to_integer(long, base);\n```\n```c3 implementation\nfn int? String.to_int(s, int base = 10) => s.to_integer(int, base);\n```\n```c3 implementation\nfn short? String.to_short(s, int base = 10) => s.to_integer(short, base);\n```\n```c3 implementation\nfn ichar? String.to_ichar(s, int base = 10) => s.to_integer(ichar, base);\n```\n```c3 implementation\nfn uint128? String.to_uint128(s, int base = 10) => s.to_integer(uint128, base);\n```\n```c3 implementation\nfn ulong? String.to_ulong(s, int base = 10) => s.to_integer(ulong, base);\n```\n```c3 implementation\nfn uint? String.to_uint(s, int base = 10) => s.to_integer(uint, base);\n```\n```c3 implementation\nfn ushort? String.to_ushort(s, int base = 10) => s.to_integer(ushort, base);\n```\n```c3 implementation\nfn char? String.to_uchar(s, int base = 10) => s.to_integer(char, base);\n```\n```c3 implementation\nfn double? String.to_double(s) => s.to_real(double);\n```\n```c3 implementation\nfn float? String.to_float(s) => s.to_real(float);\n```\n```c3 implementation\nfn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap());\n```\n\n```c3 implementation\nfn Char16[]? String.to_new_utf16(s, Allocator allocator = allocator::heap());\n```\n\n```c3 implementation\nfn Char16[]? String.to_temp_utf16(s);\n```\n\n```c3 implementation\nfn Char32[]? String.to_utf32(s, Allocator allocator);\n```\n\n```c3 implementation\nfn Char32[]? String.to_new_utf32(s) => s.to_utf32(allocator::heap()) @inline;\n```\n\n```c3 implementation\nfn Char32[]? String.to_temp_utf32(s) => s.to_utf32(allocator::temp()) @inline;\n```\n\n```c3 implementation\nfn WString? String.to_wstring(s, Allocator allocator);\n```\n\n```c3\nfn WString? String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n```c3\nfn WString? String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n```c3\nfn StringIterator String.iterator(s);\n```\n\n### `ZString` Member Functions\n\n```c3 implementation\nfn String ZString.str_view(str);\n```\n\n```c3 implementation\nfn usz ZString.char_len(str);\n```\n\n```c3 implementation\nfn usz ZString.len(str);\n\n```\n```c3 implementation\nfn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())\n```\n```c3 implementation\nfn ZString String.zstr_tcopy(s) => s.zstr_copy(allocator::temp()) @inline;\n```\n";
						const data = {title:"Strings",description:"Strings",editUrl:true,head:[],template:"doc",sidebar:{order:62,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Common/strings.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
