const id = "Generic Programming/macros.md";
						const collection = "docs";
						const slug = "generic-programming/macros";
						const body = "The macro capabilities of C3 reaches across several constructs: macros (prefixed with `@` at invocation), [generic functions, generic modules](/generic-programming/generics/), and [compile time variables](/generic-programming/compiletime/#compile-time-values) (prefixed with `$`), macro compile time execution (using `$if`, `$for`, `$foreach`, `$switch`) and attributes.\n\n## A quick comparison of C and C3 macros\n\n### Conditional compilation\n\n```c\n// C Macro\n#if defined(x) && Y > 3\nint z;\n#endif\n``` \n\n```c3\n// C3 Macro\n$if $defined(x) && Y > 3:\n    int z;\n$endif\n\n// or\nint z @if($defined(x) && Y > 3);\n```\n    \n\n### Macros\n```c\n// C Macro\n#define M(x) ((x) + 2)\n#define UInt32 unsigned int\n\n// Use:\nint y = M(foo() + 2);\nUInt32 b = y;\n```\n\n```c3\n// C3 Macro\nmacro m(x)\n{\n    return x + 2;\n}\ndef UInt32 = uint;\n\n// Use:\nint y = m(foo() + 2);\nUInt32 b = y;\n```\n\n### Dynamic scoping\n```c\n// C Macro\n#define Z() ptr->x->y->z\nint x = Z();\n```\n\n```c3\n// C3 Macro\n... currently no corresponding functionality ...\n```\n\n### Reference arguments\n\nUse `&` in front of a parameter to capture the variable and pass it by reference without having to explicitly use `&` and pass a pointer. \n(Note that in C++ this is allowed for normal functions, whereas for C3 it is only permitted with macros. Also, \nin C3 the captured argument isn't automatically dereferenced)\n\n```c\n// C Macro\n#define M(x, y) x = 2 * (y);\n...\nM(x, 3);\n```\n\n```c3\n// C3 Macro\nmacro @m(&x, y)\n{\n    *x = 2 * y;\n}\n...\n@m(x, 3);\n```\n\n### First class types\n\n```c\n// C Macro\n#define SIZE(T) (sizeof(T) + sizeof(int))\n```\n\n```c3\n// C3 Macro\nmacro size($Type)\n{\n    return $Type.sizeof + int.sizeof;\n}\n```\n\n### Trailing blocks for macros\n\n```\n// C Macro\n#define FOR_EACH(x, list) \\\nfor (x = (list); x; x = x->next)\n\n// Use:\nFoo *it;\nFOR_EACH(it, list) \n{\n    if (!process(it)) return;\n}\n```\n    \n```c3 \n// C3 Macro\nmacro @for_each(list; @body(it))\n{\n    for ($typeof(list) x = list; x; x = x.next)\n    {\n        @body(x);\n    }    \n}\n\n// Use:\n@for_each(list; Foo* x)\n{\n    if (!process(x)) return;\n}\n```\n\n### First class names\n\n```c\n// C Macro\n#define offsetof(T, field) (size_t)(&((T*)0)->field)\n```  \n\n```c3\n// C3 Macro\nmacro usz @offset($Type, #field)\n{\n    $Type* t = null;\n    return (usz)(uptr)&t.#field;\n}\n```\n\n### Declaration attributes\n\n```c\n// C Macro\n#define PURE_INLINE __attribute__((pure)) __attribute__((always_inline))\nint foo(int x) PURE_INLINE { ... }\n```\n\n```c3\n// C3 Macro\ndef @NoDiscardInline = { @nodiscard @inline };\nfn int foo(int) @NoDiscardInline { ... }\n```\n\n### Declaration macros\n```c\n// C Macro\n#define DECLARE_LIST(name) List name = { .head = NULL };\n// Use:\nDECLARE_LIST(hello)\n```  \n\n```c3\n// C3 Macro\n... currently no corresponding functionality ...\n```\n### Stringification\n\n```c\n// C Macro\n#define CHECK(x) do { if (!x) abort(#x); } while(0)\n``` \n\n```c3\n// C3 Macro\nmacro @check(#expr)\n{\n    if (!#expr) abort($stringify(#expr));\n}\n```\n\n## Top level evaluation\n\nScript languages, and also upcoming languages like *Jai*, \nusually have unbounded top level evaluation. \nThe flexibility of this style of meta programming has a trade-off in making the code more challenging to understand. \n\nIn C3, top level compile time evaluation is limited to `@if` attributes to conditionally enable or \ndisable declarations. This makes the code easier to read, but at the cost of expressive power.\n\n## Macro declarations\n\nA macro is defined using `macro <name>(<parameters>)`. All user defined macros use the @ symbol if they use the `&` or `#` parameters.\n\nThe parameters have different sigils: `$` means compile time evaluated (constant expression or type). `#` indicates an expression that is not yet evaluated, but is bound to where it was defined. Finally `&` is used to *implicitly* pass a parameter by reference.\n`@` is required on macros that use `#` and `&` parameters.\n\nA basic swap:\n\n```c3\n<*\n @checked $assignable(*a, $typeof(*b)) && $assignable(*b, $typeof(*a))\n*>\nmacro void @swap(&a, &b)\n{\n    $typeof(*a) temp = *a;\n    *a = *b;\n    *b = temp;\n}\n```\n\nThis expands on usage like this:\n\n```c3\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    @swap(a, b);\n}\n// Equivalent to:\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    {\n        int __temp = a;\n        a = b;\n        b = __temp;\n    }\n}\n```\n\nNote the necessary `&`. Here is an incorrect swap and what it would expand to:\n\n```c3\nmacro void badswap(a, b)\n{\n    $typeof(a) temp = a;\n    a = b;\n    b = temp;\n}\n\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    badswap(a, b);\n}\n// Equivalent to:\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    {\n        int __a = a;\n        int __b = b;\n        int __temp = __a;\n        __a = __b;\n        __b = __temp;\n    }\n}\n```\n\n## Macro methods\n\nSimilar to regular *methods* a macro may also be associated with a particular type:\n\n```c3\nstruct Foo { ... }\n\nmacro Foo.generate(&self) { ... }\nFoo f;\nf.generate();\n```\n\nSee the chapter on [functions](/language-fundamentals/functions/) for more details.\n\n## Capturing a trailing block\n\nIt is often useful for a macro to take a trailing compound statement as an argument. In C++ this pattern is usually expressed with a lambda, but in C3 this is completely inlined.\n\nTo accept a trailing block, `; @name(param1, ...)` is placed after declaring the regular macro parameters.\n\nHere's an example to illustrate its use:\n\n```c3\n<*\n A macro looping through a list of values, executing the body once\n every pass.\n\n @require $defined(a.len) && $defined(a[0])\n*>\nmacro @foreach(a; @body(index, value))\n{\n    for (int i = 0; i < a.len; i++)\n    {\n        @body(i, a[i]);\n    }\n}\n\nfn void test()\n{\n    double[] a = { 1.0, 2.0, 3.0 };\n    @foreach(a; int index, double value)\n    {\n        io::printfn(\"a[%d] = %f\", index, value);\n    };\n}\n\n// Expands to code similar to:\nfn void test()\n{\n    int[] a = { 1, 2, 3 };\n    {\n        int[] __a = a;\n        for (int __i = 0; i < __a.len; i++)\n        {\n            io::printfn(\"Value: %d, x2: %d\", __value1, __value2);\n        }\n    }\n}\n```\n\n## Macros returning values\n\nA macro may return a value, it is then considered an expression rather than a statement:\n\n```c3\nmacro square(x)\n{\n    return x * x;\n}\n\nfn int getTheSquare(int x)\n{\n    return square(x);\n}\n\nfn double getTheSquare2(double x)\n{\n    return square(x);\n}\n```\n\n## Calling macros\n\nIt's perfectly fine for a macro to invoke another macro or itself.\n\n```c3\nmacro square(x) { return x * x; }\n\nmacro squarePlusOne(x)\n{\n    return square(x) + 1; // Expands to \"return x * x + 1;\"\n}\n```\n\nThe maximum recursion depth is limited to the `macro-recursion-depth` build setting.\n\n## Macro vaargs\n\nMacros support the typed vaargs used by C3 functions: `macro void foo(int... args)` and `macro void bar(args...)` \nbut it also supports a unique set of macro vaargs that look like C style vaargs: `macro void baz(...)`\n\nTo access the arguments there is a family of $va-* built-in functions to retrieve\nthe arguments:\n\n```c3\nmacro compile_time_sum(...)\n{\n    var $x = 0;\n    $for (var $i = 0; $i < $vacount; $i++)\n        $x += $vaconst[$i];\n    $endfor\n    return $x;\n}\n$if compile_time_sum(1, 3) > 2: // Will compile to $if 4 > 2\n    ...\n$endif\n```\n\n### $vacount\n\nReturns the number of arguments.\n\n### $vaarg\n\nReturns the argument as a regular parameter. The argument is\nguaranteed to be evaluated once, even if the argument is used multiple times.\n\n### $vaconst\n\nReturns the argument as a compile time constant, this is suitable for\nplacing in a compile time variable or use for compile time evaluation,\ne.g. `$foo = $vaconst(1)`. This corresponds to `$` parameters.\n\n### $vaexpr\n\nReturns the argument as an unevaluated expression. Multiple uses will\nevaluate the expression multiple times, this corresponds to `#` parameters.\n\n### $vatype\n\nReturns the argument as a type. This corresponds to `$Type` style parameters, \ne.g. `$vatype(2) a = 2` \n\n### $varef\n\nReturns the argument as an lvalue. This corresponds to `&myref` style parameters,\ne.g. `*$varef(1) = 123`.\n\n### $vasplat\n\n`$vasplat` allows you to paste the varargs in the call into another call. For example,\nif the macro was called with values `\"foo\"` and `1`, the code `foo($vasplat())`, would become `foo(\"foo\", 1)`.\nYou can even extract provide a range as the argument: `$vasplat(2..4)` (in this case, this would past in \narguments 2, 3 and 4).\n\nNor is it limited to function arguments, you can also use it with initializers:\n\n```c3\nint[*] a = { 5, $vasplat[2..], 77 };\n```\n\n## Untyped lists\n\nCompile time variables may hold untyped lists. Such lists may be iterated over or \nimplicitly converted to initializer lists:\n\n```c3\nvar $a = { 1, 2 };\n$foreach ($x : $a)\n    io::printfn(\"%d\", $x);\n$endforeach\nint[2] x = $a;\nio::printfn(\"%s\", x);\nio::printfn(\"%s\", $a[1]);\n// Will print\n// 1\n// 2\n// [1, 2]\n// 2\n```\n";
						const data = {title:"Macros",description:"Macros",editUrl:true,head:[],template:"doc",sidebar:{order:83,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Generic Programming/macros.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
