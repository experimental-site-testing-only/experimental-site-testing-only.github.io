import { c as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_DFSFkPP8.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<p>An important question to answer is “How does C3 compare to other similar programming languages?”.\nHere is an extremely brief (and not yet complete) overview.</p>\n<h2 id=\"c\">C</h2>\n<p>As C3 is an evolution of C, the languages are quite similar.\nC3 adds features, but also removes a few.</p>\n<h5 id=\"in-c3-but-not-in-c\">In C3 but not in C</h5>\n<ul>\n<li>Module system</li>\n<li>Integrated build system</li>\n<li>Generics</li>\n<li>Semantic Macros</li>\n<li>Error handling</li>\n<li>Defer</li>\n<li>Value methods</li>\n<li>Associated enum data</li>\n<li>Distinct types and subtypes</li>\n<li>Optional contracts</li>\n<li>Built-in slices</li>\n<li>Foreach for iteration over arrays and types</li>\n<li>Dynamic calls and types</li>\n</ul>\n<h5 id=\"in-c-but-not-in-c3\">In C but not in C3</h5>\n<ul>\n<li>Qualified types (<code dir=\"auto\">const</code>, <code dir=\"auto\">volatile</code> etc)</li>\n<li>Unsafe implicit conversions</li>\n</ul>\n<h2 id=\"c-1\">C++</h2>\n<p>C++ is a complex object oriented “almost superset” of C. It tries to be everything to everyone,\nwhile squeezing this into a C syntax. The language is well known for its\nmany pitfalls and quirky corners – as well as its long compile times.</p>\n<p>C3 is in many ways different from C++ in the same way that C is different from C++,\nbut the semantic macro system and the generics close the gap in terms of writing\nreusable generic code. The C3 module system and error handling is also very\ndifferent from how C++ does things.</p>\n<h5 id=\"in-c-but-not-in-c3-1\">In C++ but not in C3</h5>\n<ul>\n<li>Objects and classes</li>\n<li>RAII</li>\n<li>Exceptions</li>\n</ul>\n<h5 id=\"in-c3-but-not-in-c-1\">In C3 but not in C++</h5>\n<ul>\n<li>Module system (yet)</li>\n<li>Integrated build system</li>\n<li>Semantic macros</li>\n<li>Error handling</li>\n<li>Defer</li>\n<li>Associated enum data</li>\n<li>Built-in slices</li>\n<li>Dynamic calls</li>\n</ul>\n<h2 id=\"rust\">Rust</h2>\n<p>Rust is a safe systems programming language. While not quite as complex as C++,\nit is still a feature rich programming language with semantic macros, traits and\npattern matching to mention a few.</p>\n<p>Error handling is handled using <code dir=\"auto\">Result</code> and <code dir=\"auto\">Optional</code> which is similar to\nhow C3 works.</p>\n<p>C3 compares to Rust much like C, although the presence of built-in slices and\nstrings reduces the places where C3 is unsafe. Rust provides arrays and strings,\nbut they are not built in.</p>\n<h5 id=\"in-rust-but-not-in-c3\">In Rust but not in C3</h5>\n<ul>\n<li>RAII</li>\n<li>Memory safety</li>\n<li>Safe union types with functions</li>\n<li>Different syntax from C</li>\n<li>Pattern matching</li>\n<li>Async built in</li>\n</ul>\n<h5 id=\"in-c3-but-not-in-rust\">In C3 but not in Rust</h5>\n<ul>\n<li>Same ease of programming as C</li>\n<li>Optional contracts</li>\n<li>Familiar C syntax and behaviour</li>\n<li>Dynamic calls</li>\n</ul>\n<h2 id=\"zig\">Zig</h2>\n<p>Zig is a systems programming language with extensive compile time execution to\nenable polymorphic functions and parameterized types. It aims to be a C replacement.</p>\n<p>Compared to C3, Zig tries to be a completely new language in terms of syntax and feel.\nC3 uses macros to a modest degree where it is more pervasive in Zig, and\ndoes not depart from C to the same degree. Like Rust, it features slices as a first\nclass type. The standard library uses an explicit allocator to allow it to work\nwith many different allocation strategies.</p>\n<p>Zig is a very ambitious project, aiming to support as many types of platforms as\npossible.</p>\n<h5 id=\"in-zig-but-not-in-c3\">In Zig but not in C3</h5>\n<ul>\n<li>Pervasive compile time execution.</li>\n<li>Memory allocation failure is an error.</li>\n<li>Toolchain uses build files written in native Zig.</li>\n<li>Different syntax and behaviour compared to C.</li>\n<li>Structs define namespace.</li>\n<li>Async primitives built in.</li>\n<li>Arbitrary integer sizes.</li>\n</ul>\n<h5 id=\"in-c3-but-not-in-zig\">In C3 but not in Zig</h5>\n<ul>\n<li>Module system.</li>\n<li>Integrated build system.</li>\n<li>C ABI compatibility by default.</li>\n<li>Optional contracts.</li>\n<li>Familiar C syntax and behaviour.</li>\n<li>Dynamic interfaces.</li>\n<li>Built in benchmarks.</li>\n</ul>\n<h2 id=\"jai\">Jai</h2>\n<p>Jai is a programming language aimed at high performance game programming.\nIt has an extensive compile time meta programming functionality, even\nto the point of being able to run programs at compile time. It also\nhas compile-time polymorphism, a powerful macro system and uses\nan implicit context system to switch allocation schemes.</p>\n<h5 id=\"in-jai-but-not-in-c3\">In Jai but not in C3</h5>\n<ul>\n<li>Pervasive compile time execution.</li>\n<li>Jai’s compile time execution is the build system.</li>\n<li>Different syntax and behaviour compared to C.</li>\n<li>More powerful macro system than C3.</li>\n<li>Implicit constructors.</li>\n</ul>\n<h5 id=\"in-c3-but-not-in-jai\">In C3 but not in Jai</h5>\n<ul>\n<li>Module system.</li>\n<li>Integrated build system.</li>\n<li>Optional contracts.</li>\n<li>Familiar C syntax and behaviour.</li>\n<li>Fairly small language.</li>\n<li>Dynamic interfaces.</li>\n</ul>\n<h2 id=\"odin\">Odin</h2>\n<p>Odin is a language built for high performance but tries to remain\na simple language to learn. Superficially the syntax shares much with\nJai, and some of Jai’s features things – like an implicit context – also shows up\nin Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation\nand instead only relies on parametric polymorphism to ensure reuse.\nIt also contains conveniences, like maps and arrays built into\nthe language. For error handling it relies on Go style tuple returns.</p>\n<h5 id=\"in-odin-but-not-in-c3\">In Odin but not in C3</h5>\n<ul>\n<li>Different syntax and behaviour compared to C.</li>\n<li>Ad hoc parametric polymorphism.</li>\n<li>Multiple return values.</li>\n<li>Error handling through multiple returns.</li>\n<li>A rich built in set of types.</li>\n</ul>\n<h5 id=\"in-c3-but-not-in-odin\">In C3 but not in Odin</h5>\n<ul>\n<li>Familiar C syntax and behaviour.</li>\n<li>Semantic macros.</li>\n<li>Value methods.</li>\n<li>Optional contracts.</li>\n<li>Built in error handling.</li>\n<li>Dynamic interfaces.</li>\n</ul>\n<h2 id=\"d\">D</h2>\n<p>D is an incredibly extensive language, it covers anything C++ does and adds much more.\nD manages this with much fewer syntactic quirks than C++. It is a strong,\nfeature-rich language.</p>\n<h5 id=\"in-d-but-not-in-c3\">In D but not in C3</h5>\n<ul>\n<li>Objects and classes.</li>\n<li>RAII.</li>\n<li>Exceptions.</li>\n<li>Optional GC.</li>\n</ul>\n<p><em>+ Many, many more features.</em></p>\n<h5 id=\"in-c3-but-not-in-d\">In C3 but not in D</h5>\n<ul>\n<li>Fairly small language.</li>\n</ul>";

				const frontmatter = {"title":"Comparisons With Other Languages","description":"How C3 compares to other languages","sidebar":{"order":701}};
				const file = "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/FAQ/compare-languages.md";
				const url = undefined;
				function rawContent() {
					return "An important question to answer is \"How does C3 compare to other similar programming languages?\".\nHere is an extremely brief (and not yet complete) overview.\n\n## C\n\nAs C3 is an evolution of C, the languages are quite similar.\nC3 adds features, but also removes a few.\n\n##### In C3 but not in C\n\n- Module system\n- Integrated build system\n- Generics\n- Semantic Macros\n- Error handling\n- Defer\n- Value methods\n- Associated enum data\n- Distinct types and subtypes\n- Optional contracts\n- Built-in slices\n- Foreach for iteration over arrays and types\n- Dynamic calls and types\n\n##### In C but not in C3\n\n- Qualified types (`const`, `volatile` etc)\n- Unsafe implicit conversions\n\n## C++\n\nC++ is a complex object oriented \"almost superset\" of C. It tries to be everything to everyone,\nwhile squeezing this into a C syntax. The language is well known for its\nmany pitfalls and quirky corners – as well as its long compile times.\n\nC3 is in many ways different from C++ in the same way that C is different from C++,\nbut the semantic macro system and the generics close the gap in terms of writing\nreusable generic code. The C3 module system and error handling is also very\ndifferent from how C++ does things.\n\n##### In C++ but not in C3\n\n- Objects and classes\n- RAII\n- Exceptions\n\n##### In C3 but not in C++\n\n- Module system (yet)\n- Integrated build system\n- Semantic macros\n- Error handling\n- Defer\n- Associated enum data\n- Built-in slices\n- Dynamic calls\n\n## Rust\n\nRust is a safe systems programming language. While not quite as complex as C++,\nit is still a feature rich programming language with semantic macros, traits and\npattern matching to mention a few.\n\nError handling is handled using `Result` and `Optional` which is similar to \nhow C3 works.\n\nC3 compares to Rust much like C, although the presence of built-in slices and \nstrings reduces the places where C3 is unsafe. Rust provides arrays and strings,\nbut they are not built in.\n\n##### In Rust but not in C3\n\n- RAII\n- Memory safety\n- Safe union types with functions\n- Different syntax from C\n- Pattern matching\n- Async built in\n\n##### In C3 but not in Rust\n\n- Same ease of programming as C\n- Optional contracts\n- Familiar C syntax and behaviour\n- Dynamic calls\n\n## Zig\n\nZig is a systems programming language with extensive compile time execution to\nenable polymorphic functions and parameterized types. It aims to be a C replacement.\n\nCompared to C3, Zig tries to be a completely new language in terms of syntax and feel.\nC3 uses macros to a modest degree where it is more pervasive in Zig, and\ndoes not depart from C to the same degree. Like Rust, it features slices as a first\nclass type. The standard library uses an explicit allocator to allow it to work\nwith many different allocation strategies.\n\nZig is a very ambitious project, aiming to support as many types of platforms as\npossible.\n\n##### In Zig but not in C3\n\n- Pervasive compile time execution.\n- Memory allocation failure is an error.\n- Toolchain uses build files written in native Zig.\n- Different syntax and behaviour compared to C.\n- Structs define namespace.\n- Async primitives built in.\n- Arbitrary integer sizes.\n\n##### In C3 but not in Zig\n\n- Module system.\n- Integrated build system.\n- C ABI compatibility by default.\n- Optional contracts.\n- Familiar C syntax and behaviour.\n- Dynamic interfaces.\n- Built in benchmarks.\n\n## Jai\n\nJai is a programming language aimed at high performance game programming.\nIt has an extensive compile time meta programming functionality, even\nto the point of being able to run programs at compile time. It also\nhas compile-time polymorphism, a powerful macro system and uses \nan implicit context system to switch allocation schemes.\n\n##### In Jai but not in C3\n\n- Pervasive compile time execution.\n- Jai's compile time execution is the build system.\n- Different syntax and behaviour compared to C.\n- More powerful macro system than C3.\n- Implicit constructors.\n\n##### In C3 but not in Jai\n\n- Module system.\n- Integrated build system.\n- Optional contracts.\n- Familiar C syntax and behaviour.\n- Fairly small language.\n- Dynamic interfaces.\n\n## Odin\n\nOdin is a language built for high performance but tries to remain\na simple language to learn. Superficially the syntax shares much with\nJai, and some of Jai's features things – like an implicit context – also shows up\nin Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation\nand instead only relies on parametric polymorphism to ensure reuse.\nIt also contains conveniences, like maps and arrays built into\nthe language. For error handling it relies on Go style tuple returns.\n\n##### In Odin but not in C3\n\n- Different syntax and behaviour compared to C.\n- Ad hoc parametric polymorphism.\n- Multiple return values.\n- Error handling through multiple returns.\n- A rich built in set of types.\n\n##### In C3 but not in Odin\n\n- Familiar C syntax and behaviour.\n- Semantic macros.\n- Value methods.\n- Optional contracts.\n- Built in error handling.\n- Dynamic interfaces.\n\n## D\n\nD is an incredibly extensive language, it covers anything C++ does and adds much more.\nD manages this with much fewer syntactic quirks than C++. It is a strong,\nfeature-rich language.\n\n##### In D but not in C3\n\n- Objects and classes.\n- RAII.\n- Exceptions.\n- Optional GC.\n\n*+ Many, many more features.* \n\n##### In C3 but not in D\n\n- Fairly small language.";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"c","text":"C"},{"depth":5,"slug":"in-c3-but-not-in-c","text":"In C3 but not in C"},{"depth":5,"slug":"in-c-but-not-in-c3","text":"In C but not in C3"},{"depth":2,"slug":"c-1","text":"C++"},{"depth":5,"slug":"in-c-but-not-in-c3-1","text":"In C++ but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-c-1","text":"In C3 but not in C++"},{"depth":2,"slug":"rust","text":"Rust"},{"depth":5,"slug":"in-rust-but-not-in-c3","text":"In Rust but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-rust","text":"In C3 but not in Rust"},{"depth":2,"slug":"zig","text":"Zig"},{"depth":5,"slug":"in-zig-but-not-in-c3","text":"In Zig but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-zig","text":"In C3 but not in Zig"},{"depth":2,"slug":"jai","text":"Jai"},{"depth":5,"slug":"in-jai-but-not-in-c3","text":"In Jai but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-jai","text":"In C3 but not in Jai"},{"depth":2,"slug":"odin","text":"Odin"},{"depth":5,"slug":"in-odin-but-not-in-c3","text":"In Odin but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-odin","text":"In C3 but not in Odin"},{"depth":2,"slug":"d","text":"D"},{"depth":5,"slug":"in-d-but-not-in-c3","text":"In D but not in C3"},{"depth":5,"slug":"in-c3-but-not-in-d","text":"In C3 but not in D"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
