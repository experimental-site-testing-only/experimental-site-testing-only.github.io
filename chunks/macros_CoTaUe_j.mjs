const id = "Generic Programming/macros.md";
						const collection = "docs";
						const slug = "generic-programming/macros";
						const body = "The macro capabilities of C3 reaches across several constructs:\nmacros, [generic functions, generic modules](/generic-programming/generics/), and [compile time variables](/generic-programming/compiletime/#compile-time-values)\n(prefixed with `$`), macro compile time execution (using `$if`, `$for`, `$foreach`, `$switch`) and attributes.\n\n## A quick comparison of C and C3 macros\n\n### Conditional compilation\n\n```c\n// C Macro\n#if defined(x) && Y > 3\nint z;\n#endif\n```\n\n```c3\n// C3 Macro\n$if $defined(x) && Y > 3:\n    int z;\n$endif\n\n// or\nint z @if($defined(x) && Y > 3);\n```\n\n\n### Macros\n```c\n// C Macro\n#define M(x) ((x) + 2)\n#define UInt32 unsigned int\n\n// Use:\nint y = M(foo() + 2);\nUInt32 b = y;\n```\n\n```c3\n// C3 Macro\nmacro m(x)\n{\n    return x + 2;\n}\nalias UInt32 = uint;\n\n// Use:\nint y = m(foo() + 2);\nUInt32 b = y;\n```\n\n### Dynamic scoping\n```c\n// C Macro\n#define Z() ptr->x->y->z\nint x = Z();\n```\n\n```c3\n// C3 Macro\n... currently no corresponding functionality ...\n```\n\n### Expression arguments\n\n\n```c\n// C Macro\n#define M(x, y) x = 2 * (y);\n...\nM(x, 3);\n```\n\n```c3\n// C3 Macro\nmacro @m(#x, y)\n{\n    #x = 2 * y;\n}\n...\n@m(x, 3);\n```\n\n### First class types\n\n```c\n// C Macro\n#define SIZE(T) (sizeof(T) + sizeof(int))\n```\n\n```c3\n// C3 Macro\nmacro size($Type)\n{\n    return $Type.sizeof + int.sizeof;\n}\n```\n\n### Trailing blocks for macros\n\n```\n// C Macro\n#define FOR_EACH(x, list) \\\nfor (x = (list); x; x = x->next)\n\n// Use:\nFoo *it;\nFOR_EACH(it, list)\n{\n    if (!process(it)) return;\n}\n```\n\n```c3\n// C3 Macro\nmacro @for_each(list; @body(it))\n{\n    for ($typeof(list) x = list; x; x = x.next)\n    {\n        @body(x);\n    }\n}\n\n// Use:\n@for_each(list; Foo* x)\n{\n    if (!process(x)) return;\n}\n```\n\n### First class names\n\n```c\n// C Macro\n#define offsetof(T, field) (size_t)(&((T*)0)->field)\n```\n\n```c3\n// C3 Macro\nmacro usz @offset($Type, #field)\n{\n    $Type* t = null;\n    return (usz)(uptr)&t.#field;\n}\n```\n\n### Declaration attributes\n\n```c\n// C Macro\n#define PURE_INLINE __attribute__((pure)) __attribute__((always_inline))\nint foo(int x) PURE_INLINE { ... }\n```\n\n```c3\n// C3 Macro\nattrdef @NoDiscardInline = { @nodiscard @inline };\nfn int foo(int) @NoDiscardInline { ... }\n```\n\n### Declaration macros\n```c\n// C Macro\n#define DECLARE_LIST(name) List name = { .head = NULL };\n// Use:\nDECLARE_LIST(hello)\n```\n\n```c3\n// C3 Macro\n... currently no corresponding functionality ...\n```\n### Stringification\n\n```c\n// C Macro\n#define CHECK(x) do { if (!x) abort(#x); } while(0)\n```\n\n```c3\n// C3 Macro\nmacro @check(#expr)\n{\n    if (!#expr) abort($stringify(#expr));\n}\n```\n\n## Top level evaluation\n\nScript languages, and also upcoming languages like *Jai*,\nusually have unbounded top level evaluation.\nThe flexibility of this style of meta programming has a trade-off in making the code more challenging to understand.\n\nIn C3, top level compile time evaluation is limited to `@if` attributes to conditionally enable or\ndisable declarations. This makes the code easier to read, but at the cost of expressive power.\n\n## Macro declarations\n\nA macro is defined using `macro <name>(<parameters>)`. All user defined macros use the @ symbol if they use the `$` or `#` parameters.\n\nThe parameters have different sigils:\n`$` means compile time evaluated (constant expression or type). `#` indicates an expression that is not yet evaluated,\nbut is bound to where it was defined. `@` is required on macros that use `#` parameters or trailing macro bodies.\n\nA basic swap:\n\n```c3\n<*\n @checked $defined(#a = #b, #b = #a)\n*>\nmacro void @swap(#a, #b)\n{\n    var temp = #a;\n    #a = #b;\n    #b = temp;\n}\n```\n\nThis expands on usage like this:\n\n```c3\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    @swap(a, b);\n}\n// Equivalent to:\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    {\n        int __temp = a;\n        a = b;\n        b = __temp;\n    }\n}\n```\n\nNote the necessary `#`. Here is an incorrect swap and what it would expand to:\n\n```c3\nmacro void badswap(a, b)\n{\n    var temp = a;\n    a = b;\n    b = temp;\n}\n\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    badswap(a, b);\n}\n// Equivalent to:\nfn void test()\n{\n    int a = 10;\n    int b = 20;\n    {\n        int __a = a;\n        int __b = b;\n        int __temp = __a;\n        __a = __b;\n        __b = __temp;\n    }\n}\n```\n\n## Macro methods\n\nSimilar to regular *methods* a macro may also be associated with a particular type:\n\n```c3\nstruct Foo { ... }\n\nmacro Foo.generate(&self) { ... }\nFoo f;\nf.generate();\n```\n\nSee the chapter on [functions](/language-fundamentals/functions/) for more details.\n\n## Capturing a trailing block\n\nIt is often useful for a macro to take a trailing compound statement as an argument. In C++ this pattern is usually expressed with a lambda, but in C3 this is completely inlined.\n\nTo accept a trailing block, `; @name(param1, ...)` is placed after declaring the regular macro parameters.\n\nHere's an example to illustrate its use:\n\n```c3\n<*\n A macro looping through a list of values, executing the body once\n every pass.\n\n @require $defined(a.len) && $defined(a[0])\n*>\nmacro @foreach(a; @body(index, value))\n{\n    for (int i = 0; i < a.len; i++)\n    {\n        @body(i, a[i]);\n    }\n}\n\nfn void test()\n{\n    double[] a = { 1.0, 2.0, 3.0 };\n    @foreach(a; int index, double value)\n    {\n        io::printfn(\"a[%d] = %f\", index, value);\n    };\n}\n\n// Expands to code similar to:\nfn void test()\n{\n    double[] a = { 1.0, 2.0, 3.0 };\n    {\n        double[] __a = a;\n        for (int __i = 0; __i < __a.len; __i++)\n        {\n            int __index = __i;\n            double __value = __a[__i];\n            io::printfn(\"a[%d] = %f\", __index, __value);\n        }\n    }\n}\n```\n\n## Macros returning values\n\nA macro may return a value, it is then considered an expression rather than a statement:\n\n```c3\nmacro square(x)\n{\n    return x * x;\n}\n\nfn int getTheSquare(int x)\n{\n    return square(x);\n}\n\nfn double getTheSquare2(double x)\n{\n    return square(x);\n}\n```\n\n## Calling macros\n\nIt's perfectly fine for a macro to invoke another macro or itself.\n\n```c3\nmacro square(x) { return x * x; }\n\nmacro squarePlusOne(x)\n{\n    return square(x) + 1; // Expands to \"return x * x + 1;\"\n}\n```\n\nThe maximum recursion depth is limited to the `macro-recursion-depth` build setting.\n\n## Macro vaargs\n\nMacros support the typed vaargs used by C3 functions: `macro void foo(int... args)` and `macro void bar(args...)`\nbut it also supports a unique set of macro vaargs that look like C style vaargs: `macro void baz(...)`\n\nTo access the arguments there is a family of $va-* built-in functions to retrieve\nthe arguments:\n\n```c3\nmacro compile_time_sum(...)\n{\n    var $x = 0;\n    $for var $i = 0; $i < $vacount; $i++:\n        $x += $vaconst[$i];\n    $endfor\n    return $x;\n}\n$if compile_time_sum(1, 3) > 2: // Will compile to $if 4 > 2\n    ...\n$endif\n```\n\n### `$vacount`\n\nReturns the number of arguments.\n\n### `$vaarg`\n\nReturns the argument as a regular parameter. The argument is\nguaranteed to be evaluated once, even if the argument is used multiple times.\n\n### `$vaconst`\n\nReturns the argument as a compile time constant, this is suitable for\nplacing in a compile time variable or use for compile time evaluation,\ne.g. `$foo = $vaconst(1)`. This corresponds to `$` parameters.\n\n### `$vaexpr`\n\nReturns the argument as an unevaluated expression. Multiple uses will\nevaluate the expression multiple times, this corresponds to `#` parameters.\n\n### `$vatype`\n\nReturns the argument as a type. This corresponds to `$Type` style parameters,\ne.g. `$vatype(2) a = 2`\n\n### `$vasplat`\n\n`$vasplat` allows you to paste the varargs in the call into another call. For example,\nif the macro was called with values `\"foo\"` and `1`, the code `foo($vasplat)`, would become `foo(\"foo\", 1)`.\nYou can even extract provide a range as the argument: `$vasplat[2..4]` (in this case, this would paste in\narguments 2, 3 and 4).\n\nNor is it limited to function arguments, you can also use it with initializers:\n\n```c3\nint[*] a = { 5, $vasplat[2..], 77 };\n```\n\n## Untyped lists\n\nCompile time variables may hold untyped lists. Such lists may be iterated over or\nimplicitly converted to initializer lists:\n\n```c3\nvar $a = { 1, 2 };\n$foreach $x : $a:\n    io::printfn(\"%d\", $x);\n$endforeach\nint[2] x = $a;\nio::printfn(\"%s\", x);\nio::printfn(\"%s\", $a[1]);\n// Will print\n// 1\n// 2\n// [1, 2]\n// 2\n```\n";
						const data = {title:"Macros",description:"Macros",editUrl:true,head:[],template:"doc",sidebar:{order:83,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Generic Programming/macros.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
