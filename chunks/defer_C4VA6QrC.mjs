const id = "Previous Versions/v0_6_8/Language Common/defer.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/language-common/defer";
						const body = "\n# Defer \n\nA `defer` *always* runs at the [end of a scope](#end-of-a-scope) at any point *after* it is declared, `defer` is commonly used to simplify code that needs clean-up; like closing unix file descriptors, freeing dynamically allocated memory or closing database connections.\n\n### End of a scope\nThe end of a scope also includes `return`, `break`, `continue` or [rethrow `!`](/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value). \n\n```c3\nfn void test() \n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, on function return\");\n    io::printn(\"print second\");\n    return;\n}\n```\nThe `defer` runs **after** the other print statements, at the function return.\n\n:::note\n[Rethrow `!`](/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value) unwraps the Optional result if present, afterwards the previously Optional variable is a normal variable again, if the Optional result is empty then the Excuse is returned from the function back to the caller.\n:::\n\n### Defer Execution order\nWhen there are multiple `defer` statements they are executed in reverse order of their declaration, last-to-first declared. \n\n```c3\nfn void test() \n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, defers execute in reverse order\");\n    defer io::printn(\"print second, defers execute in reverse order\");\n    return;\n}\n```\n\n### Example defer\n\n```c3\nimport std::io;\n\nfn char[]! file_read(String filename, char[] buffer)\n{   \n    // return Excuse if failed to open file\n    File file = file::open(filename, \"r\")!; \n\n    defer { \n        io::printn(\"File was found, close the file\"); \n        if (catch excuse = file.close()) \n        {\n            io::printfn(\"Fault closing file: %s\", excuse); \n        }\n    }\n\n    // return if fault reading the file into the buffer\n    file.read(buffer)!; \n    return buffer;\n}\n```\n\nIf the file named `filename` is found the function will read the content into a buffer, \n`defer` will then make sure that any open `File` handlers are closed. \nNote that if a scope exit happens before the `defer` declaration, the `defer` will not run, this a useful property because if the file failed to open, we don't need to close it.\n\n\n## `defer try`\n\nA `defer try` is called at [end of a scope](#end-of-a-scope) when the returned [Optional contained a result](/language-common/optionals-essential/#what-is-an-optional) value.\n\n### Examples\n\n```c3\nfn void! test() \n{\n    defer try io::printn(\"✅ defer try run\"); \n    // Returned an Optional result\n    return;\n}\n\nfn void main(String[] args) \n{\n    (void)test();\n}\n```\nFunction returns an [Optional result](/language-common/optionals-essential/#what-is-an-optional) value, \nthis means `defer try` runs on [scope exit](#end-of-a-scope).\n\n```c3\nfn void! test() \n{\n    defer try io::printn(\"❌ defer try not run\");\n    // Returned an Optional Excuse\n    return IoError.FILE_NOT_FOUND?;\n}\n\nfn void main(String[] args) \n{\n    if (catch err = test()) \n    {\n        io::printfn(\"test() returned a fault: %s\", err);\n    }\n}\n```\nFunction returns an [Optional Excuse](/language-common/optionals-essential/#what-is-an-optional), \nthis means the `defer try` does *not* run on [scope exit](#end-of-a-scope).\n\n## `defer catch`\n\nA `defer catch` is called at [end of a scope](#end-of-a-scope) when exiting exiting with an \n[Optional Excuse](/language-common/optionals-essential/#what-is-an-optional), and is helpful for logging, cleanup and freeing resources.\n \n\n```c3\ndefer catch { ... }\n```\n\n```c3\ndefer (catch err) { ... };\n```\nWhen the fault is captured this is convenient for logging the fault:\n\n```c3\ndefer (catch err) io::printfn(\"fault found: %s\", err)\n```\n### Memory allocation example\n\n```c3\nimport std::core::mem;\n\nfn char[]! test()\n{\n    char[] data = mem::new_array(char, 12)!;\n    \n    defer (catch err) \n    {\n        io::printfn(\"Excuse found: %s\", err)\n        (void)free(data);\n    }\n\n    // Returns Excuse, memory gets freed\n    return IoError.FILE_NOT_FOUND?; \n}\n```\n\n:::caution[Pitfalls with `defer` and `defer catch`]\nIf cleaning up memory allocations or resources make sure the `defer` or `defer catch` \nare declared as close to the resource declaration as possible. \nThis helps to avoid unwanted memory leaks or unwanted resource usage from other code [rethrowing `!`](/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value) before the `defer catch` was even declared. \n\n```c3\nfn void! function_throws() \n{\n    return IoError.FILE_NOT_FOUND?;\n}\n\nfn String! test()\n{\n    char[] data = mem::new_array(char, 12)!;\n    \n    // ❌ Before the defer catch declaration\n    // memory was NOT freed\n    // function_throws()!;  \n\n    defer (catch err) \n    {\n        io::printn(\"freeing memory\");\n        (void)free(data);\n    }\n\n    // ✅ After the defer catch declaration\n    // memory freed correctly\n    function_throws()!;     \n\n    return (String)data; \n}\n```\n:::\n";
						const data = {title:"Defer and Cleanup",description:"Defer and Cleanup",editUrl:true,head:[],template:"doc",sidebar:{order:66,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
