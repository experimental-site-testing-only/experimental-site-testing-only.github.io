const id = "Language Fundamentals/basic-types-and-values.md";
						const collection = "docs";
						const slug = "language-fundamentals/basic-types-and-values";
						const body = "\nC3 provides a similar set of fundamental data types as C: integers, floats, arrays and pointers. On top of this it\nexpands on this set by adding slices and vectors, as well as the `any` and `typeid` types for advanced use.\n\n## Integers\n\nC3 has signed and unsigned integer types. The built-in signed integer types are `ichar`, `short`, `int`, `long`,\n`int128`, `iptr` and `isz`. `ichar` to `int128` have all well-defined power-of-two bit sizes, whereas `iptr`\nhas the same number of bits as a `void*` and `isz` has the same number of bits as the maximum difference\nbetween two pointers. For each signed integer type there is a corresponding unsigned integer type: `char`,\n`ushort`, `uint`, `ulong`, `uint128`, `uptr` and `usz`.\n\n| type    | signed? | min    | max       | bits   |\n|---------|---------|--------|-----------|--------|\n| ichar   | yes     | -128   | 127       | 8      |\n| short   | yes     | -32768 | 32767     | 16     |\n| int     | yes     | -2^31  | 2^31 - 1  | 32     |\n| long    | yes     | -2^63  | 2^63 - 1  | 64     |\n| int128  | yes     | -2^127 | 2^127 - 1 | 128    |\n| iptr    | yes     | varies | varies    | varies |\n| isz     | yes     | varies | varies    | varies |\n| char    | no      | 0      | 255       | 8      |\n| ushort  | no      | 0      | 65535     | 16     |\n| uint    | no      | 0      | 2^32 - 1  | 32     |\n| ulong   | no      | 0      | 2^64 - 1  | 64     |\n| uint128 | no      | 0      | 2^128 - 1 | 128    |\n| uptr    | no      | 0      | varies    | varies |\n| usz     | no      | 0      | varies    | varies |\n\nOn 64-bit machines `iptr`/`uptr` and `isz`/`usz` are usually 64-bits, like `long`/`ulong`.\nOn 32-bit machines on the other hand they are generally `int`/`uint`.\n\n### Integer constants\n\nNumeric constants typically use decimal, e.g. `234`, but may also use hexadecimal (base 16) numbers by prefixing\nthe number with `0x` or `0X`, e.g. `int a = 0x42edaa02;`. There is also octal (base 8) using the\n`0o` or `0O` prefix, and `0b` for binary (base 2) numbers:\n\nNumbers may also insert underscore `_` between digits to improve readability, e.g. `1_000_000`.\n\n```c3\na = -2_000;\nb = 0o770;\nc = 0x7f7f7f;\n```\n\nFor decimal numbers, the value is assumed to be a signed `int`, unless the number doesn't fit in an\n`int`, in which case it is assumed to be the smallest signed type it *does* fit in (`long` or `int128`).\n\nFor hexadecimal, octal and binary, the type is assumed to be unsigned.\n\nA integer literal can *implicitly* convert to a floating point literal, or an integer of\na different type provided the number fits in the type.\n\n### Constant suffixes\n\nIf you want to ensure that a constant is of a certain type, you can either add an explicit cast\nlike: `(ushort)345`, or use an integer suffix: `345u16`.\n\nThe following integer suffixes are available:\n\n| suffix |    type |\n|--------|--------:|\n| i8     |   ichar |\n| i16    |   short |\n| i32    |     int |\n| i64    |    long |\n| i128   |  int128 |\n| u8     |    char |\n| u16    |  ushort |\n| u32    |    uint |\n| u      |    uint |\n| u64    |   ulong |\n| u128   | uint128 |\n\nNote how `uint` also has the `u` suffix.\n\n## Booleans\n\nA `bool` will be either `true` or `false`. Although a bool is only a single bit of data,\nit should be noted that it is stored in a byte.\n\n```c\nbool b = true;\nbool f = false;\n```\n\n### Character literals\n\nA character literal is a value enclosed in `''`. Its value is interpreted as being its\nASCII value for a single character.\n\nIt is also possible to use 2, 4 or 8 character wide character literals. Such are interpreted\nas `ushort`, `uint` and `ulong` respectively and are laid out in memory from left to right.\nThis means that the actual value depends on the [endianness](https://en.wikipedia.org/wiki/Endianness)\nof the target.\n\n- 2 character literals, e.g. `'C3'`, would convert to an ushort.\n- 4 character literals, e.g. `'TEST'`, converts to an uint.\n- 8 character literals, e.g. `'FOOBAR11'` converts to an ulong.\n\nThe 4 character literals correspond to the layout of [FourCC](https://en.wikipedia.org/wiki/FourCC)\ncodes. It will also correctly arrange unicode characters in memory. E.g. `Char32 smiley = '\\u1F603'`\n\n## Floating point types\n\nAs is common, C3 has two floating point types: `float` and `double`. `float` is the 32 bit floating\npoint type and `double` is 64 bits.\n\n### Floating point constants\n\nFloating point constants will *at least* use 64 bit precision.\nJust like for integer constants, it is possible to use `_` to improve\nreadability, but it may not occur immediately before or after a dot or an exponential.\n\nC3 supports floating points values either written in decimal or hexadecimal formats.\nFor decimal, the exponential symbol is e (or E, both are acceptable),\nfor hexadecimal p (or P) is used: `-2.22e-21` `-0x21.93p-10`\n\nWhile floating point numbers default to `double` it is possible to type a\nfloating point by adding a suffix:\n\n| Suffix           | type       |\n| ---------------- | ----------:|\n| `f32` *or* `f`   | `float`    |\n| `f64`            | `double`   |\n\n## Arrays\n\n[Arrays](/language-common/arrays/) have the format `Type[size]`, so for example: `int[4]`. An array is a type consisting\nof the same element repeated a number of times. Our `int[4]` is essentially four `int` values\npacked together.\n\nFor initialization it's sometimes convenient to use the wildcard `Type[*]` declaration, which\ninfers the length from the number of elements:\n\n```c3\nint[3] abc = { 1, 2, 3 }; // Explicit int[3]\nint[*] bcd = { 1, 2, 3 }; // Implicit int[3]\n```\n\n## Slices\n\n[Slices](/language-common/arrays/#slice) have the format `Type[]`. Unlike the array, a slice does not hold the values themselves\nbut instead presents a view of some underlying array or vector.\n\nSlices have two properties: `.ptr`, which retrieves the array it points to, and `.len` which\nis the length of the slice - that is, the number of elements it is possible to index into.\n\nUsually we can get a slice by taking the address of an array:\n\n```c3\nint[3] abc = { 1, 2, 3 };\nint[] slice = &abc;       // A slice pointing to abc with length 3\n```\n\nBecause indexing into slices is range checked in safe mode, slices are vastly more safe\nproviding pointer + length separately.\n\nThe internal representation of a slice is a two element struct:\n```c3\nstruct SliceRaw\n{\n\tvoid* ptr;\n\tusz len;\n}\n```\nThis definition can be found in the module `std::core::runtime`.\n\n## Vectors\n\n[Vectors](/language-common/vectors/) similar to arrays, use the format\n`Type[<size>]`, with the restriction that vectors may only form out\nof integers, floats and booleans. Similar to arrays, wildcard can be\nused to infer the size of a vector:\n\n```c3\nint[<*>] a = { 1, 2 };\n```\n\nVectors are based on hardware SIMD vectors, and supports many different operations that work\non all elements in parallel, including arithmetics:\n\n```c3\nint[<2>] b = { 3, 8 };\nint[<2>] c = { 7, 2 };\nint[<2>] d = b * c;    // d is { 21, 16 }\n```\n\nVector initialization and literals work the same way as arrays, using `{ ... }`\n\n## String literals\n\nString literals are special and can convert to several different types:\n`String`, `char` and `ichar` arrays and slices and finally `ichar*` and `char*`.\n\nString literals are text enclosed in `\" \"` just like in C. These support\nescape sequences like `\\n` for line break and need to use `\\\"` for any `\"` inside of the\nstring.\n\nC3 also offers *raw strings* which are enclosed in `` ` ` ``.\nA raw string may span multiple lines.\nInside of a raw string, no escapes are available, and to write a `` ` ``, simply double the character:\n\n```c3\n// Note: String is a typedef inline char[]\nString three_lines =\n`multi\nline\nstring`;\n\nString foo = `C:\\foo\\bar.dll`;\nString bar = `\"Say ``hello``\"`;\n// Same as\nString foo = \"C:\\\\foo\\\\bar.dll\";\nString bar = \"\\\"Say `hello`\\\"\";\n```\n\n`String` is a\n[typedef inline](/language-common/alias/#typedef-inline) `char[]`, which can implicitly convert to `char[]` when required.\n\n`ZString` is a [typedef inline](/language-common/alias/#typedef-inline) `char*`.`ZString` is a C compatible null terminated string, which can implicitly convert to `char*` when required.\n\n\n\n## Base64 and hex data literals\n\nBase64 literals are strings prefixed with `b64` to containing\n[Base64 encoded](https://en.wikipedia.org/wiki/Base64) data, which\nis converted into a char array at compile time:\n\n```c3\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\";\n```\n\nThe corresponding hex data literals convert a hexadecimal string rather than Base64:\n\n```c3\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n```\n## Pointer types\n\nPointers have the syntax `Type*`. A pointer is a memory address where one or possibly more\nelements of the underlying address are stored. Pointers can be stacked: `Foo*` is a pointer to a `Foo`\nwhile `Foo**` is a pointer to a pointer to `Foo`.\n\nThe pointer type has a special literal called `null`, which is an invalid, empty pointer.\n\n### `void*`\n\nThe `void*` type is a special pointer which implicitly converts to any other pointer. It is not \"a pointer to void\",\nbut rather a wildcard pointer which matches any other pointer.\n\n## Printing values\n\nPrinting values can be done using `io::print`, `io::printn`, `io::printf` and `io::printfn`. This requires\nimporting the module `std::io`.\n\n:::note\nThe `n` variants of the print functions will add a newline after printing, which is what we'll often\nuse in the examples, but `print` and `printf` work the same way.\n\n:::\n\n```c3\nimport std::io; // Get the io functions.\n\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printn(a);\n    io::printn(b);\n    io::printn(d);\n    io::printn(hex);\n}\n```\n\nIf you run this program you will get:\n\n```\n1234\n71963842633920255\n0.001303\n[72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]\n```\n\nTo get more control we can format the output using `printf` and `printfn`:\n\n```c3\nimport std::io;\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printfn(\"a was:                        %d\", a);\n    io::printfn(\"b in hex was:                 %x\", b);\n    io::printfn(\"d in scientific notation was: %e\", d);\n    io::printfn(\"Bytes as string:              %s\", (String)&hex);\n}\n```\n\nWe can apply the [standard printf formatting rules](https://en.cppreference.com/w/c/io/fprintf), but\nunlike in C/C++ there is no need to indicate the type when using `%d` - it will print unsigned and\nsigned up to `int128`, in fact there is no support for `%u`, `%lld` etc in `io::printf`. Furthermore,\n`%s` works not just on strings but on any type:\n\n```c3\nimport std::io;\n\nenum Foo\n{\n    ABC,\n    BCD,\n    EFG,\n}\nfn void main()\n{\n    int a = 1234;\n    uint128 b = 0xFFEEDDCC_BBAA9988_77665544_33221100;\n    Foo foo = BCD;\n    io::printfn(\"a: %s, b: %d, foo: %s\", a, b, foo);\n}\n```\n\nThis prints:\n\n```\na: 1234, b: 340193404210632335760508365704335069440, foo: BCD\n```\n";
						const data = {title:"Basic Types and Values",description:"Get an overview of C3's basic types and values",editUrl:true,head:[],template:"doc",sidebar:{order:33,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Fundamentals/basic-types-and-values.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
