const id = "Language Common/contracts.md";
						const collection = "docs";
						const slug = "language-common/contracts";
						const body = "\nContracts are optional pre- and post-conditions checks that the compiler may use for optimization and runtime checks. Note that _compilers are not obliged to process pre- and post-conditions at all_. However, violating either pre- or post-conditions is considered undefined behaviour, so a compiler may optimize as if they always hold â€“ even if a potential bug may cause them to be violated.\n\n# Pre-conditions\n\nPre-conditions are usually used to validate incoming arguments.\nEach condition must be an expression that can be evaluated to a boolean.\nPre-conditions use the `@require` annotation, and optionally can have an\nerror message to display after them.\n\n```c3\n<*\n @require foo > 0, foo < 1000 : \"optional error msg\"\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n```\n\n# Post conditions\n\nPost conditions are evaluated to make checks on the resulting state after passing through the function.\nThe post condition uses the `@ensure` annotation. Where `return` is used to represent the return value from the function.\n\n\n\n```c3\n<*\n @require foo != null\n @ensure return > foo.x\n*>\nfn uint checkFoo(Foo* foo)\n{\n    uint y = abs(foo.x) + 1;\n    // If we had row: foo.x = 0, then this would be a compile time error.\n    return y * abs(foo.x);\n}\n```\n\n## Parameter annotations\n\n`@param` supports `[in]` `[out]` and `[inout]`. These are only applicable\nfor pointer arguments. `[in]` disallows writing to the variable,\n`[out]` disallows reading from the variable. Without an annotation,\npointers may both be read from and written to without checks. If an `&` is placed\nin front of the annotation (e.g. `[&in]`), then this means the pointer must be non-null\nand is checked for `null`.\n\n| Type          | readable? | writable? | use as \"in\"? | use as \"out\"? | use as \"inout\"? |\n|---------------|:---------:|:---------:|:------------:|:-------------:|:---------------:|\n| no annotation |    Yes    |    Yes    |     Yes      |      Yes      |       Yes       |\n| `in`          |    Yes    |    No     |     Yes      |      No       |        No       |\n| `out`         |    No     |    Yes    |      No      |      Yes      |        No       |\n| `inout`       |    Yes    |    Yes    |     Yes      |      Yes      |       Yes       |\n\nHowever, it should be noted that the compiler might not detect whether the annotation is correct or not! This program might compile, but will behave strangely:\n\n```c3\nfn void bad_func(int* i)\n{\n    *i = 2;\n}\n\n<*\n @param [&in] i\n*>\nfn void lying_func(int* i)\n{\n    bad_func(i); // The compiler might not check this!\n}\n\nfn void test()\n{\n    int a = 1;\n    lying_func(&a);\n    io::printf(\"%d\", a); // Might print 1!\n}\n```\n\nHowever, compilers will usually detect this:\n\n```c3\n<*\n @param [&in] i\n*>\nfn void bad_func(int* i)\n{\n    *i = 2; // <- Compiler error: cannot write to \"in\" parameter\n}\n```\n\n### Pure in detail\n\nThe `pure` annotation allows a program to make assumptions in regard to how the function treats global variables.\nUnlike for `const`, a pure function is not allowed to call a function which is known to be impure.\n\nHowever, just like for `const` the compiler might not detect whether the annotation\nis correct or not! This program might compile, but will behave strangely:\n\n```c3\nint i = 0;\n\nalias SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // The compiler cannot reason about this!\n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\nHowever, compilers will usually detect this:\n\n```c3\nint i = 0;\n\nalias SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // <- ERROR: Only '@pure' functions may be called.\n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\nConsequently, circumventing \"pure\" annotations is undefined behaviour.\n\n\n# Pre-conditions for macros\n\nIn order to check macros, it's often useful to use the builtin `$defined`\nfunction which returns true if the code inside would pass semantic checking.\n\n\n```c3\n<*\n @require $defined(resource.open, resource.open()), `Expected resource to have an \"open\" function`\n @require resource != nil\n @require $assignable(resource.open(), void*)\n*>\nmacro open_resource(resource)\n{\n    return resource.open();\n}\n```\n";
						const data = {title:"Contracts",description:"Contracts",editUrl:true,head:[],template:"doc",sidebar:{order:67,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Common/contracts.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
