const id = "Language Common/alias.md";
						const collection = "docs";
						const slug = "language-common/alias";
						const body = "\n# The `alias` statement\n\nThe `alias` statement in C3 is intended for aliasing identifiers and types.\n\n## Defining a type alias\n\n`alias <type alias> = <type>` creates a type alias. Type aliases need to follow the name convention of user defined types (i.e. capitalized\nnames with at least one lower case letter).\n\n```c3\nalias CharPtr = char*;\nalias Numbers = int[10];\n```\n\nFunction pointers _must_ be aliased in C3. The syntax is somewhat different from C:\n\n```c3\nalias Callback = fn void(int a, bool b);\n```\n\nThis defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage:\n\n```c3\nCallback cb = my_callback;\ncb(10, false);\n```\n\n## typedef types\n\nSimilar to `alias` aliases are `typedef` which create distinct new types. Unlike type aliases,\nthey do not implicitly convert to or from any other type.\nLiterals will convert to the `typedef` types if they would convert to the underlying type.\n\nBecause a `typedef` type is a new type, it can have its own methods, like any other user-defined type.\n\n```c3\ntypedef Foo = int;\nFoo f = 0; // Valid since 0 converts to an int.\nf = f + 1;\nint i = 1;\n// f = f + i Error!\nf = f + (Foo)i; // Valid\n```\n\n## typedef inline\n\nWhen interacting with various APIs it is sometimes desirable for `typedef` types to implicitly convert *to*\nits base type, but not *from* that type.\n\nBehaviour here is analogous how structs may use `inline` to create struct subtypes.\n\n```c3\ntypedef CString = char*;\ntypedef ZString = inline char*;\n...\nCString abc = \"abc\";\nZString alias = \"alias\";\n// char* from_abc = abc; // Error!\nchar* from_def = alias; // Valid!\n```\n\n## Function and variable aliases\n\n`alias` can also be used to create aliases for functions and variables.\n\nThe syntax is `alias <alias> = <original identifier>`.\n\n```c3\nfn void foo() { ... }\nint foo_var;\n\nalias bar = foo;\nalias bar_var = foo_var;\n\nfn void test()\n{\n  // These are the same:\n  foo();\n  bar();\n\n  // These access the same variable:\n  int x = foo_var;\n  int y = bar_var;\n}\n```\n\n## Using `alias` to create generic types, functions and variables\n\nIt is recommended to favour using alias to create aliases for parameterized types, but it can also be used for parameterized functions and variables:\n\n```c3\nimport generic_foo;\n\n// Parameterized function aliases\nalias int_foo_call = generic_foo::foo_call{ int };\nalias double_foo_call = generic_foo::foo_call{ double };\n\n// Parameterized type aliases\nalias IntFoo = Foo{ int };\nalias DoubleFoo = Foo{ double };\n\n// Parameterized global aliases\nalias int_max_foo = generic_foo::max_foo{ int };\nalias double_max_foo = generic_foo::max_foo{ double };\n```\n\nFor more information, see the chapter on [generics](/generic-programming/generics/).\n\n## Function pointer default arguments and named parameters\n\nIt is possible to attach default arguments to function pointer aliases. There is no requirement\nthat the function has the same default arguments. In fact, the function pointer may have\ndefault arguments where the function doesn't have it and vice-versa. Calling the function\ndirectly will then use the function's default arguments, and calling through the function pointer\nwill yield the function pointer alias' default argument.\n\nSimilarly, named parameter arguments follow the alias definition when calling through the\nfunction pointer:\n\n```c3\nalias TestFn = fn void(int y = 123);\n\nfn void test(int x = 5)\n{\n    io::printfn(\"X = %d\", x);\n}\n\nfn void main()\n{\n    TestFn test2 = &test;\n    test();         // Prints X = 5\n    test2();        // Prints X = 123\n    test(x: 3);     // Prints X = 3\n    test2(y: 4);    // Prints X = 4\n}\n```\n";
						const data = {title:"Alias",description:"The `alias` statement",editUrl:true,head:[],template:"doc",sidebar:{order:61,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Language Common/alias.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
