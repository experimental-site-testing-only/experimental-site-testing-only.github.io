import { c as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_DFSFkPP8.mjs';
import 'kleur/colors';
import 'clsx';

const html = "<p>Here is a summary of <em>all</em> the features of C3 and changes from C</p>\n<h2 id=\"symbols-and-literals\">Symbols and literals</h2>\n<p>Changes relating to literals, identifiers etc.</p>\n<h3 id=\"added\">Added</h3>\n<ol>\n<li>0o prefix for octal.</li>\n<li>0b prefix for binary.</li>\n<li>Optional ”_” as digit separator.</li>\n<li>Hexadecimal byte data, e.g <code dir=\"auto\">x\"abcd\"</code>.</li>\n<li>Base64 byte data, e.g. <code dir=\"auto\">b64\"QzM=\"</code>.</li>\n<li>Type name restrictions (PascalCase).</li>\n<li>Variable and function name restrictions (must start with lower case letter).</li>\n<li>Constant name restrictions (no lower case).</li>\n<li>Character literals may be 2, 4, 8, 16 bytes long. (2cc, 4cc etc).</li>\n<li>Raw string literals between ”`”.</li>\n<li><code dir=\"auto\">\\e</code> escape character.</li>\n<li>Source code must be UTF-8.</li>\n<li>Assumes <code dir=\"auto\">\\n</code> for new row <code dir=\"auto\">\\r</code> is stripped from source.</li>\n<li>Bit-width integer and float suffixes: <code dir=\"auto\">u8</code>/<code dir=\"auto\">i8</code>/<code dir=\"auto\">u16</code>/<code dir=\"auto\">i16</code>/… <code dir=\"auto\">f32</code>/<code dir=\"auto\">f64</code>/…</li>\n<li>The <code dir=\"auto\">null</code> literal is a pointer value of 0.</li>\n<li>The <code dir=\"auto\">true</code> and <code dir=\"auto\">false</code> are boolean constants true and false.</li>\n</ol>\n<h3 id=\"removed\">Removed</h3>\n<ol>\n<li>Trigraphs / digraphs.</li>\n<li>0123-style octal.</li>\n<li><code dir=\"auto\">z</code>, <code dir=\"auto\">LL</code> and <code dir=\"auto\">ULL</code> suffixes.</li>\n</ol>\n<h2 id=\"built-in-types\">Built-in types</h2>\n<h3 id=\"added-1\">Added</h3>\n<ol>\n<li>Type declaration is left to right: <code dir=\"auto\">int[4]*[2] a;</code> instead of <code dir=\"auto\">int (*a[2])[4];</code></li>\n<li>Simd vector types using <code dir=\"auto\">[&#x3C;>]</code> syntax, e.g. <code dir=\"auto\">float[&#x3C;4>]</code>, use <code dir=\"auto\">[&#x3C;*>]</code> for inferred length.</li>\n<li>Slice type built in, using <code dir=\"auto\">[]</code> suffix, e.g. <code dir=\"auto\">int[]</code></li>\n<li>Distinct types, similar to a typedef but forms a new type. (Example: the <code dir=\"auto\">String</code> type is a distinct <code dir=\"auto\">char[]</code>)</li>\n<li>Built-in 128-bit integer on all platforms.</li>\n<li><code dir=\"auto\">char</code> is an unsigned 8-bit integer. <code dir=\"auto\">ichar</code> is its signed counterpart.</li>\n<li>Well-defined bitwidth for integer types: ichar/char (8 bits), short/ushort (16 bits), int/uint (32 bits), long/ulong (64 bits), int128/uint128 (128 bits)</li>\n<li>Pointer-sized <code dir=\"auto\">iptr</code> and <code dir=\"auto\">uptr</code> integers.</li>\n<li><code dir=\"auto\">isz</code> and <code dir=\"auto\">usz</code> integers corresponding to the <code dir=\"auto\">size_t</code> bitwidth.</li>\n<li>Optional types are formed using the <code dir=\"auto\">!</code> suffix.</li>\n<li><code dir=\"auto\">bool</code> is the boolean type.</li>\n<li><code dir=\"auto\">typeid</code> is a unique type identifier for a type, it can be used at runtime and compile time.</li>\n<li><code dir=\"auto\">any</code> contains a <code dir=\"auto\">typeid</code> and <code dir=\"auto\">void*</code> allowing it to act as a reference to any type of value.</li>\n<li><code dir=\"auto\">anyfault</code> holds any <code dir=\"auto\">fault</code> value (see below).</li>\n</ol>\n<h3 id=\"changed\">Changed</h3>\n<ol>\n<li>Inferred array type uses <code dir=\"auto\">[*]</code> (e.g. <code dir=\"auto\">int[*] x = { 1, 2 };</code>).</li>\n<li>Flexible array member uses <code dir=\"auto\">[*]</code>.</li>\n</ol>\n<h3 id=\"removed-1\">Removed</h3>\n<ol>\n<li>The spiral rule type declaration (see above).</li>\n<li>Complex types</li>\n<li>size_t, ptrdiff_t (see above).</li>\n<li>Array types do not decay.</li>\n</ol>\n<h2 id=\"types\">Types</h2>\n<h3 id=\"added-2\">Added</h3>\n<ol>\n<li><code dir=\"auto\">bitstruct</code> a struct with a container type allowing precise control over bit-layout, replacing bitfields and enum masks.</li>\n<li><code dir=\"auto\">fault</code> an enum type with unique values which are used together with optional.</li>\n<li>Vector types.</li>\n<li>Optional types.</li>\n<li><code dir=\"auto\">enum</code> allows a set of unique constants to be associated with each enum value.</li>\n<li>Compile time reflection and limited runtime reflection on types (see “Reflection”)</li>\n<li>All types have a <code dir=\"auto\">typeid</code> property uniquely referring to that particular type.</li>\n<li>Distinct types, which are similar to aliases, but represent distinctly different types.</li>\n<li>Types may have methods. Methods can be added to any type, including built-in types.</li>\n<li>Subtyping: using <code dir=\"auto\">inline</code> on a struct member allows a struct to be implicitly converted to this member type and use corresponding methods.</li>\n<li>Using <code dir=\"auto\">inline</code> on a distinct type allows it to be implicitly converted <em>to</em> its base type (but not vice versa).</li>\n<li>Types may add operator overloading to support <code dir=\"auto\">foreach</code> and subscript operations.</li>\n<li>Generic types through generic modules, using <code dir=\"auto\">(&#x3C; ... >)</code> for the generic parameter list (e.g. <code dir=\"auto\">List(&#x3C;int>) list;</code>).</li>\n<li>Interface types, <code dir=\"auto\">any</code> types which allows dynamic invocation of methods.</li>\n</ol>\n<h3 id=\"changed-1\">Changed</h3>\n<ol>\n<li><code dir=\"auto\">typedef</code> is replaced by <code dir=\"auto\">def</code> and has somewhat different syntax (e.g. <code dir=\"auto\">def MyTypeAlias = int;</code>).</li>\n<li>Function pointer syntax is prefix <code dir=\"auto\">fn</code> followed by a regular function declaration without the function name.</li>\n</ol>\n<h3 id=\"removed-2\">Removed</h3>\n<ol>\n<li>Enums, structs and unions no longer have distinct namespaces.</li>\n<li>Enum, struct and union declarations should not have a trailing ’;’</li>\n<li>Inline <code dir=\"auto\">typedef</code> is not allowed. <code dir=\"auto\">def</code> can only be used at the top level.</li>\n<li>Anonymous structs are not allowed.</li>\n<li>Type qualifiers are all removed, including <code dir=\"auto\">const</code>, <code dir=\"auto\">restrict</code>, <code dir=\"auto\">volatile</code></li>\n<li>Function pointers types <strong>cannot</strong> be used “raw”, but must always be used through a type alias.</li>\n</ol>\n<h3 id=\"introspection\">Introspection</h3>\n<p>Compile time type methods: <code dir=\"auto\">alignof</code>, <code dir=\"auto\">associated</code>, <code dir=\"auto\">elements</code>, <code dir=\"auto\">extnameof</code>, <code dir=\"auto\">inf</code>, <code dir=\"auto\">inner</code>, <code dir=\"auto\">kindof</code>, <code dir=\"auto\">len</code>,\n<code dir=\"auto\">max</code>, <code dir=\"auto\">membersof</code>, <code dir=\"auto\">min</code>, <code dir=\"auto\">nan</code>, <code dir=\"auto\">names</code>, <code dir=\"auto\">params</code>, <code dir=\"auto\">returns</code>, <code dir=\"auto\">sizeof</code>, <code dir=\"auto\">typeid</code>, <code dir=\"auto\">values</code>,\n<code dir=\"auto\">qnameof</code>, <code dir=\"auto\">is_eq</code>, <code dir=\"auto\">is_ordered</code>.</p>\n<p>Runtime type methods: <code dir=\"auto\">inner</code>, <code dir=\"auto\">kind</code>, <code dir=\"auto\">len</code>, <code dir=\"auto\">names</code>, <code dir=\"auto\">sizeof</code>.</p>\n<h2 id=\"expressions\">Expressions</h2>\n<h3 id=\"added-3\">Added</h3>\n<ol>\n<li>Expression block using <code dir=\"auto\">{| ... |}</code>. Somewhat similar to GCC statement expressions.</li>\n<li>Array initializers may use ranges. (e.g. <code dir=\"auto\">int[256] x = { [0..128] = 1 }</code>)</li>\n<li><code dir=\"auto\">?:</code> operator, returning the first value if it can be converted to a boolean true, otherwise the second value is returned.</li>\n<li>Orelse <code dir=\"auto\">??</code> returning the first value if it is a result, the second if the first value was an optional value.</li>\n<li>Rethrow <code dir=\"auto\">!</code> suffix operator with an implicit <code dir=\"auto\">return</code> the value if it was an optional value.</li>\n<li>Dynamic calls, allowing calls to be made on the <code dir=\"auto\">any</code> and interfaces dispatched using a dynamic mechanism.</li>\n<li>Create a slice using a range subscript (e.g. <code dir=\"auto\">a[4..8]</code> to form a slice from element 4 to element 8).</li>\n<li>Two range subscript methods: <code dir=\"auto\">[start..inclusive_end]</code> and <code dir=\"auto\">[start:length]</code>. Start, end and length may be omitted for default values.</li>\n<li>Indexing from end: slices, arrays and vectors may be indexed from the end using <code dir=\"auto\">^</code>. <code dir=\"auto\">^1</code> represents the last element. This works for ranges as well.</li>\n<li>Range assignment, assign a single value to an entire range e.g. <code dir=\"auto\">a[4..8] = 1;</code>.</li>\n<li>Slice assignment, copy one range to the other range e.g. <code dir=\"auto\">a[4..8] = b[8..12];</code>.</li>\n<li>Array, vector and slice comparison: <code dir=\"auto\">==</code> can be used to make an element-wise comparison of two containers.</li>\n<li><code dir=\"auto\">?</code> suffix operator turns a fault into an optional value.</li>\n<li><code dir=\"auto\">!!</code> suffix panics if the value is an optional value.</li>\n<li><code dir=\"auto\">$defined(...)</code> returns true if the last expression is defined (sub-expressions must be valid).</li>\n<li><code dir=\"auto\">$and(...)</code> <code dir=\"auto\">$or(...)</code> perform compile time logic, and may also be written as <code dir=\"auto\">&#x26;&#x26;&#x26;</code> and <code dir=\"auto\">|||</code> respectively.</li>\n</ol>\n<ul>\n<li>It does not check any elements after the first false value found for <code dir=\"auto\">$and()</code> also written as <code dir=\"auto\">&#x26;&#x26;&#x26;</code>. To check both conditions are false use: <code dir=\"auto\">!false_condition &#x26;&#x26;&#x26; !false_condition</code>.</li>\n<li>It does not check any values after the first true found for <code dir=\"auto\">$or()</code> also written as <code dir=\"auto\">|||</code>.</li>\n</ul>\n<ol start=\"17\">\n<li>Lambdas (anonymous functions) may be defined, they work just like functions and do not capture any state.</li>\n<li>Simple bitstructs (only containing booleans) may be manipulated using bit operations <code dir=\"auto\">&#x26; ^ | ~</code> and assignment.</li>\n<li>Structs may implicitly convert to their <code dir=\"auto\">inline</code> member if they have one.</li>\n<li>Pointers to arrays may implicitly convert to slices.</li>\n<li>Any pointer may implicitly convert to an <code dir=\"auto\">any</code> with type being the pointee.</li>\n<li>Optional values will implicitly invoke “flatmap” on an expression it is a subexpression of.</li>\n<li>Swizzling for arrays and vectors.</li>\n</ol>\n<h3 id=\"changed-2\">Changed</h3>\n<ol>\n<li>Compound literals use <code dir=\"auto\">Type { ... }</code> rather than <code dir=\"auto\">(Type) { ... }</code></li>\n<li>Operator precedence of bit operations is higher than <code dir=\"auto\">+</code> and <code dir=\"auto\">-</code>.</li>\n<li>Well defined-evaluation order: left-to-right, assignment after expression evaluation.</li>\n<li><code dir=\"auto\">sizeof</code> is <code dir=\"auto\">$sizeof</code> and only works on expressions. Use <code dir=\"auto\">Type.sizeof</code> on types.</li>\n<li><code dir=\"auto\">alignof</code> is <code dir=\"auto\">$alignof</code> for expressions. Types use <code dir=\"auto\">Type.alignof</code>.</li>\n<li>Narrowing conversions are only allowed if all sub-expressions is as small or smaller than the type.</li>\n<li>Widening conversions are only allowed on simple expressions (i.e. most binary expressions and some unary may not be widened)</li>\n</ol>\n<h3 id=\"removed-3\">Removed</h3>\n<ol>\n<li>The comma operator is removed.</li>\n</ol>\n<h3 id=\"cast-changes\">Cast changes</h3>\n<h2 id=\"functions\">Functions</h2>\n<h3 id=\"added-4\">Added</h3>\n<ol>\n<li>Functions may be invoked using named arguments, the name is the dot-prefixed parameter name, e.g. <code dir=\"auto\">foo(name: a, len: 2)</code>.</li>\n<li>Typed varargs are declared <code dir=\"auto\">Type... argument</code>, and will take 0 or more arguments of the given type.</li>\n<li>It is possible to “splat” an array or slice into the location of a typed vararg using <code dir=\"auto\">...</code>: <code dir=\"auto\">foo(a, b, ...list)</code></li>\n<li><code dir=\"auto\">any</code> varargs are declared <code dir=\"auto\">argument...</code>, it can take 0 or more arguments of any type which are implicitly converted to the <code dir=\"auto\">any</code> type.</li>\n<li>The function declaration may have <code dir=\"auto\">@inline</code> or <code dir=\"auto\">@noinline</code> as a default.</li>\n<li>Using <code dir=\"auto\">@inline</code> or <code dir=\"auto\">@noinline</code> on a function call expression will override the function default.</li>\n<li>Type methods are functions defined in the form <code dir=\"auto\">fn void Foo.my_method(Foo* foo) { ... }</code>, they can be invoked using dot syntax.</li>\n<li>Type methods may be attached to any type, even arrays and vectors.</li>\n<li>Error handling using optional return types.</li>\n</ol>\n<h3 id=\"changed-3\">Changed</h3>\n<ol>\n<li>Function declarations use the <code dir=\"auto\">fn</code> prefix.</li>\n</ol>\n<h3 id=\"removed-4\">Removed</h3>\n<ol>\n<li>Functions with C-style varargs may be called, and declared as external functions, but not used for C3 functions.</li>\n</ol>\n<h2 id=\"attributes\">Attributes</h2>\n<p>C3 adds a long range of attributes in the form <code dir=\"auto\">@name(...)</code>. It is possible to create custom\nattribute groups using <code dir=\"auto\">def</code> (e.g. <code dir=\"auto\">def MyAttribute(usz align) = { @aligned(align) @weak };</code>) which\ngroups certain attributes. Empty attribute groups are permitted.</p>\n<p>The complete list: <code dir=\"auto\">@align</code>, <code dir=\"auto\">@benchmark</code>, <code dir=\"auto\">@bigendian</code>, <code dir=\"auto\">@builtin</code>,\n<code dir=\"auto\">@callconv</code>, <code dir=\"auto\">@deprecated</code>, <code dir=\"auto\">@dynamic</code>, <code dir=\"auto\">@export</code>,\n<code dir=\"auto\">@extern</code>, <code dir=\"auto\">@if</code>, <code dir=\"auto\">@inline</code>, <code dir=\"auto\">@interface</code>,\n<code dir=\"auto\">@littleendian</code>, <code dir=\"auto\">@local</code>, <code dir=\"auto\">@maydiscard</code>, <code dir=\"auto\">@naked</code>,\n<code dir=\"auto\">@nodiscard</code>, <code dir=\"auto\">@noinit</code>, <code dir=\"auto\">@noreturn</code>, <code dir=\"auto\">@nostrip</code>,\n<code dir=\"auto\">@obfuscate</code>, <code dir=\"auto\">@operator</code>, <code dir=\"auto\">@overlap</code>, <code dir=\"auto\">@priority</code>,\n<code dir=\"auto\">@private</code>, <code dir=\"auto\">@public</code>, <code dir=\"auto\">@pure</code>, <code dir=\"auto\">@reflect</code>,\n<code dir=\"auto\">@section</code>, <code dir=\"auto\">@test</code>, <code dir=\"auto\">@used</code>, <code dir=\"auto\">@unused</code>.</p>\n<h2 id=\"declarations\">Declarations</h2>\n<h3 id=\"added-5\">Added</h3>\n<ol>\n<li><code dir=\"auto\">var</code> declaration for type inferred variables in macros. E.g. <code dir=\"auto\">var a = some_value;</code></li>\n<li><code dir=\"auto\">var</code> declaration for new type variables in macros. E.g. <code dir=\"auto\">var $Type = int;</code></li>\n<li><code dir=\"auto\">var</code> declaration for compile time mutable variables in function and macros. E.g. <code dir=\"auto\">var $foo = 1;</code></li>\n<li><code dir=\"auto\">const</code> declarations may be untyped. Such constants are not stored in the resulting binary.</li>\n</ol>\n<h3 id=\"changed-4\">Changed</h3>\n<ol>\n<li><code dir=\"auto\">tlocal</code> declares a variable to be thread local.</li>\n<li><code dir=\"auto\">static</code> top level declarations are replaced with <code dir=\"auto\">@local</code>. (<code dir=\"auto\">static</code> in functions is unchanged)</li>\n</ol>\n<h3 id=\"removed-5\">Removed</h3>\n<ol>\n<li><code dir=\"auto\">restrict</code> removed.</li>\n<li><code dir=\"auto\">atomic</code> should be replaced by atomic load/store operations.</li>\n<li><code dir=\"auto\">volatile</code> should be replaced by volatile load/store operations.</li>\n</ol>\n<h2 id=\"statements\">Statements</h2>\n<h3 id=\"added-6\">Added</h3>\n<ol>\n<li>Match-style variant of the <code dir=\"auto\">switch</code> statement, allows each <code dir=\"auto\">case</code> to hold an expression to test.</li>\n<li>Switching over type with <code dir=\"auto\">typeid</code>.</li>\n<li>Unpack <code dir=\"auto\">any</code> to the underlying type with an <code dir=\"auto\">any</code>-switch.</li>\n<li><code dir=\"auto\">nextcase</code> to fallthrough to the next case.</li>\n<li><code dir=\"auto\">nextcase &#x3C;expr></code> to jump to the case with the expression value (this may be an expression evaluated at runtime).</li>\n<li><code dir=\"auto\">nextcase default</code> to jump to the <code dir=\"auto\">default</code> clause.</li>\n<li>Labelled <code dir=\"auto\">while</code>/<code dir=\"auto\">do</code>/<code dir=\"auto\">for</code>/<code dir=\"auto\">foreach</code> to use with <code dir=\"auto\">break</code> <code dir=\"auto\">nextcase</code> and <code dir=\"auto\">continue</code>.</li>\n<li><code dir=\"auto\">foreach</code> to iterate over arrays, vectors, slices and user-defined containers using operator overloading.</li>\n<li><code dir=\"auto\">foreach_r</code> to iterate in reverse.</li>\n<li><code dir=\"auto\">foreach</code> / <code dir=\"auto\">foreach_r</code> may take the element by value or reference. The index may optionally be provided.</li>\n<li><code dir=\"auto\">$if</code>, <code dir=\"auto\">$switch</code>, <code dir=\"auto\">$for</code>, <code dir=\"auto\">$foreach</code> statements executing at compile time.</li>\n<li><code dir=\"auto\">$echo</code> printing a message at compile time.</li>\n<li><code dir=\"auto\">$assert</code> compile time assert.</li>\n<li><code dir=\"auto\">defer</code> statement to execute statements at scope exit.</li>\n<li><code dir=\"auto\">defer catch</code> and <code dir=\"auto\">defer try</code> similar to <code dir=\"auto\">defer</code> but executes only on optional exit or regular exit of scope respectively.</li>\n<li><code dir=\"auto\">do</code> statements may omit <code dir=\"auto\">while</code>, behaving same as <code dir=\"auto\">while (0)</code></li>\n<li><code dir=\"auto\">if</code> may have a label. Labelled <code dir=\"auto\">if</code> may be exited using labelled break.</li>\n<li><code dir=\"auto\">asm</code> blocks for inline assembly.</li>\n<li>if-try statements allows you to run code where an expression is a result.</li>\n<li>if-catch statements runs code on fault. It can be used to implicitly unwrap variables.</li>\n<li>Exhaustive switching on enums.</li>\n</ol>\n<h3 id=\"changed-5\">Changed</h3>\n<ol>\n<li>Switch cases will have implicit break, rather than implicit fallthrough.</li>\n<li><code dir=\"auto\">assert</code> is an actual statement and may take a string or a format + arguments.</li>\n<li><code dir=\"auto\">static_assert</code> is <code dir=\"auto\">$assert</code> and is a statement.</li>\n</ol>\n<h3 id=\"removed-6\">Removed</h3>\n<ol>\n<li><code dir=\"auto\">goto</code> removed, replaced by labelled break, continue and nextcase.</li>\n</ol>\n<h2 id=\"compile-time-evaluation\">Compile time evaluation</h2>\n<h3 id=\"added-7\">Added</h3>\n<ol>\n<li><code dir=\"auto\">@if(cond)</code> to conditionally include a struct/union field, a user-defined type etc.</li>\n<li>Compile time variables with <code dir=\"auto\">$</code> prefix e.g. <code dir=\"auto\">$foo</code>.</li>\n<li><code dir=\"auto\">$if...$else...$endif</code> and <code dir=\"auto\">$switch...$endswitch</code> inside of functions to conditionally include code.</li>\n<li><code dir=\"auto\">$for</code> and <code dir=\"auto\">$foreach</code> to loop over compile time variables and data.</li>\n<li><code dir=\"auto\">$typeof</code> determines an expression type without evaluating it.</li>\n<li>Type properties may be accessed at compile time.</li>\n<li><code dir=\"auto\">$define</code> returns true if the variable, function or type exists.</li>\n<li><code dir=\"auto\">$error</code> emits an error if encountered.</li>\n<li><code dir=\"auto\">$embed</code> includes a file as binary data.</li>\n<li><code dir=\"auto\">$include</code> includes a file as text.</li>\n<li><code dir=\"auto\">$exec</code> includes the output of a program as code.</li>\n<li><code dir=\"auto\">$evaltype</code> takes a compile time string and turns it into a type.</li>\n<li><code dir=\"auto\">$eval</code> takes a string and turns it into an identifier.</li>\n<li><code dir=\"auto\">$extnameof</code> turns an identifier into its string external name.</li>\n<li><code dir=\"auto\">$nameof</code> turns an identifier into its local string name.</li>\n<li><code dir=\"auto\">$qnameof</code> turns an identifier into its local string name with the module prefixed.</li>\n<li>Compile time constant values are always compile time folded for arithmetic operations and casts.</li>\n<li><code dir=\"auto\">$$FUNCTION</code> returns the current function as an identifier.</li>\n</ol>\n<h3 id=\"changed-6\">Changed</h3>\n<ol>\n<li><code dir=\"auto\">#define</code> for constants is replaced by untyped constants, e.g. <code dir=\"auto\">#define SOME_CONSTANT 1</code> becomes <code dir=\"auto\">const SOME_CONSTANT = 1;</code>.</li>\n<li><code dir=\"auto\">#define</code> for variable and function aliases is replaced by <code dir=\"auto\">def</code>, e.g. <code dir=\"auto\">#define native_foo win32_foo</code> becomes <code dir=\"auto\">def native_foo = win32_foo;</code></li>\n<li>In-function <code dir=\"auto\">#if...#else..#endif</code> is replaced by <code dir=\"auto\">$if</code>, <code dir=\"auto\">#if...#elif...#endif</code> is replaced by <code dir=\"auto\">$switch</code>.</li>\n<li>For converting code into a string use <code dir=\"auto\">$stringify</code>.</li>\n<li>Macros for date, line etc are replaced by <code dir=\"auto\">$$DATE</code>, <code dir=\"auto\">$$FILE</code>, <code dir=\"auto\">$$FILEPATH</code>, <code dir=\"auto\">$$FUNC</code>, <code dir=\"auto\">$$LINE</code>, <code dir=\"auto\">$$MODULE</code>, <code dir=\"auto\">$$TIME</code>.</li>\n</ol>\n<h3 id=\"removed-7\">Removed</h3>\n<ol>\n<li>Top level <code dir=\"auto\">#if...#endif</code> does not have a counterpart. Use <code dir=\"auto\">@if</code> instead.</li>\n<li>No <code dir=\"auto\">#include</code> directives, <code dir=\"auto\">$include</code> will include text but isn’t for the same use.</li>\n</ol>\n<h2 id=\"macros\">Macros</h2>\n<h3 id=\"added-8\">Added</h3>\n<ol>\n<li><code dir=\"auto\">macro</code> for defining macros.</li>\n<li>“Function-like” macros have no prefix and has only regular parameters or type parameters.</li>\n<li>“At”-macros are prefixed with <code dir=\"auto\">@</code> and may also have compile time values, expression and ref parameters, and may have a trailing body.</li>\n<li>Type parameters have the prefix <code dir=\"auto\">$</code> and conform to the type naming standard (“$TypeFoo”).</li>\n<li>“ref” parameters are declared using with a <code dir=\"auto\">&#x26;</code> prefix operator. This is similar to C++ ref parameters.</li>\n<li>Expression parameters are unevaluated expressions, this is similar to arguments to <code dir=\"auto\">#define</code>.</li>\n<li>Compile time values have a <code dir=\"auto\">$</code> prefix and must contain compile time constant values.</li>\n<li>Any macro that evaluates to a constant result can be used as if it was the resulting constant.</li>\n<li>Macros may be recursively evaluated.</li>\n<li>Macros are inlined at the location where they are invoked.</li>\n<li>Unless resulting in a single constant, macros implicitly create a runtime scope.</li>\n</ol>\n<h3 id=\"removed-8\">Removed</h3>\n<ol>\n<li>No <code dir=\"auto\">#define</code> macros.</li>\n<li>Macros cannot be incomplete statements.</li>\n</ol>\n<h2 id=\"features-provided-by-builtins\">Features provided by builtins</h2>\n<p>Some features are provided by builtins, and appears as normal functions and macros in the standard library\nbut nonetheless provided unique functionality:</p>\n<ol>\n<li><code dir=\"auto\">@likely(...)</code> / <code dir=\"auto\">@unlikely(...)</code> on branches affects compilation optimization.</li>\n<li><code dir=\"auto\">@anycast(...)</code> casts an <code dir=\"auto\">any</code> with an optional result.</li>\n<li><code dir=\"auto\">unreachable(...)</code> marks a path as unreachable with a panic in safe mode.</li>\n<li><code dir=\"auto\">unsupported(...)</code> similar to unreachable but for functionality not implemented.</li>\n<li><code dir=\"auto\">@expect(...)</code> expect a certain value with an optional probability for the optimizer.</li>\n<li><code dir=\"auto\">@prefetch(...)</code> prefect a pointer.</li>\n<li><code dir=\"auto\">swizzle(...)</code> swizzles a vector.</li>\n<li><code dir=\"auto\">@volatile_load(...)</code> and <code dir=\"auto\">@volatile_store(...)</code> volatile load/store.</li>\n<li><code dir=\"auto\">@atomic_load(...)</code> and <code dir=\"auto\">@atomic_store(...)</code> atomic load/store.</li>\n<li><code dir=\"auto\">compare_exchange(...)</code> atomic compare exchange.</li>\n<li>Saturating add, sub, mul, shl on integers.</li>\n<li>Vector reduce operations: add, mul, and, or, xor, max, min.</li>\n</ol>\n<h2 id=\"modules\">Modules</h2>\n<ol>\n<li>Modules are defined using <code dir=\"auto\">module &#x3C;name></code>. Where name is on the form <code dir=\"auto\">foo::bar::baz</code></li>\n<li>Modules can be split into an unlimited number of module sections, each starting with the same module name declaration.</li>\n<li>The <code dir=\"auto\">import</code> statement imports a given module.</li>\n<li>Each module section has its own set of import statements.</li>\n<li>Importing a module gives access to the declarations that are <code dir=\"auto\">@public</code>.</li>\n<li>Declarations are default <code dir=\"auto\">@public</code>, but a module section may set a different default (e.g. <code dir=\"auto\">module my_module @private;</code>)</li>\n<li><code dir=\"auto\">@private</code> means the declaration is only visible in the module.</li>\n<li><code dir=\"auto\">@local</code> means only visible to the current module section.</li>\n<li>Imports are recursive. For example, <code dir=\"auto\">import my_lib</code> will implicitly also import <code dir=\"auto\">my_lib::net</code>.</li>\n<li>Multiple imports may be specified with the same <code dir=\"auto\">import</code>, e.g. <code dir=\"auto\">import std::net, std::io;</code>.</li>\n<li>Generic modules have a set of parameters after the module name <code dir=\"auto\">module arr(&#x3C;Type, LEN>);</code></li>\n<li>Generic modules are not type checked until any of its types, functions or globals are instantiated.</li>\n</ol>\n<h2 id=\"contracts\">Contracts</h2>\n<ol>\n<li>Doc comments (starting with <code dir=\"auto\">&#x3C;*</code>) are parsed.</li>\n<li>The first part, up until the first <code dir=\"auto\">@</code> directive is ignored.</li>\n<li>The <code dir=\"auto\">@param</code> directive for pointer arguments may define usage constraints <code dir=\"auto\">[in]</code> <code dir=\"auto\">[out]</code> and <code dir=\"auto\">[inout]</code>.</li>\n<li>Pointer argument constraints may add a <code dir=\"auto\">&#x26;</code> prefix to indicate that they may not be <code dir=\"auto\">null</code>, e.g. <code dir=\"auto\">[&#x26;inout]</code>.</li>\n<li>Contracts may be attached to generic modules, functions and macros.</li>\n<li><code dir=\"auto\">@require</code> directives are evaluated given the arguments provided. Failing them may be a compile time or runtime error.</li>\n<li>The <code dir=\"auto\">@ensure</code> directive is evaluated at exit - if the return is a result and not an optional.</li>\n<li><code dir=\"auto\">return</code> can be used as a variable identifier inside of <code dir=\"auto\">@ensure</code>, and holds the return value.</li>\n<li><code dir=\"auto\">@return!</code> optionally lists the errors used. This will be checked at compile time.</li>\n<li><code dir=\"auto\">@pure</code> says that no writing to globals is allowed inside and only <code dir=\"auto\">@pure</code> functions may be called.</li>\n</ol>\n<h2 id=\"benchmarking\">Benchmarking</h2>\n<ol>\n<li>Benchmarks are indicated by <code dir=\"auto\">@benchmark</code>.</li>\n<li>Marking a module section <code dir=\"auto\">@benchmark</code> makes all functions inside of it implicitly benchmarks.</li>\n<li>Benchmarks are usually not compiled.</li>\n<li>Benchmarks are instead only run by the compiler on request.</li>\n</ol>\n<h2 id=\"testing\">Testing</h2>\n<ol>\n<li>Tests are indicated by <code dir=\"auto\">@test</code>.</li>\n<li>Marking a module section <code dir=\"auto\">@test</code> makes all functions inside of it implicitly tests.</li>\n<li>Tests are usually not compiled.</li>\n<li>Tests are instead only run by the compiler on request.</li>\n</ol>\n<h2 id=\"safe--fast\">Safe / fast</h2>\n<p>Compilation has two modes: “safe” and “fast”. Safe will insert checks for out-of-bounds access, null-pointer deref,\nshifting by negative numbers, division by zero, violation of contracts and asserts.</p>\n<p>Fast will assume all of those checks can be assumed to always pass. This means that unexpected behaviour may result\nfrom violating those checks. It is recommended to develop in “safe” mode.</p>\n<p>If debug symbols are available, C3 will produce a stack trace in safe mode where an error occurs.</p>";

				const frontmatter = {"title":"All Features","description":"A list of all features of C3.","sidebar":{"order":701}};
				const file = "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/FAQ/allfeatures.md";
				const url = undefined;
				function rawContent() {
					return "\nHere is a summary of _all_ the features of C3 and changes from C\n\n## Symbols and literals\n\nChanges relating to literals, identifiers etc.\n\n### Added\n\n1. 0o prefix for octal.\n2. 0b prefix for binary.\n3. Optional \"_\" as digit separator.\n4. Hexadecimal byte data, e.g `x\"abcd\"`.\n5. Base64 byte data, e.g. `b64\"QzM=\"`.\n6. Type name restrictions (PascalCase).\n7. Variable and function name restrictions (must start with lower case letter).\n8. Constant name restrictions (no lower case).\n9. Character literals may be 2, 4, 8, 16 bytes long. (2cc, 4cc etc).\n10. Raw string literals between \"\\`\".\n11. `\\e` escape character.\n12. Source code must be UTF-8.\n13. Assumes `\\n` for new row `\\r` is stripped from source.\n14. Bit-width integer and float suffixes: `u8`/`i8`/`u16`/`i16`/... `f32`/`f64`/... \n15. The `null` literal is a pointer value of 0.\n16. The `true` and `false` are boolean constants true and false.\n\n### Removed \n\n1. Trigraphs / digraphs.\n2. 0123-style octal.\n3. `z`, `LL` and `ULL` suffixes.\n\n## Built-in types\n\n### Added\n\n1. Type declaration is left to right: `int[4]*[2] a;` instead of `int (*a[2])[4];` \n2. Simd vector types using `[<>]` syntax, e.g. `float[<4>]`, use `[<*>]` for inferred length.\n3. Slice type built in, using `[]` suffix, e.g. `int[]`\n4. Distinct types, similar to a typedef but forms a new type. (Example: the `String` type is a distinct `char[]`)\n5. Built-in 128-bit integer on all platforms.\n6. `char` is an unsigned 8-bit integer. `ichar` is its signed counterpart.\n7. Well-defined bitwidth for integer types: ichar/char (8 bits), short/ushort (16 bits), int/uint (32 bits), long/ulong (64 bits), int128/uint128 (128 bits)\n8. Pointer-sized `iptr` and `uptr` integers.\n9. `isz` and `usz` integers corresponding to the `size_t` bitwidth.\n10. Optional types are formed using the `!` suffix.\n11. `bool` is the boolean type.\n12. `typeid` is a unique type identifier for a type, it can be used at runtime and compile time.\n13. `any` contains a `typeid` and `void*` allowing it to act as a reference to any type of value.\n14. `anyfault` holds any `fault` value (see below).\n\n### Changed\n1. Inferred array type uses `[*]` (e.g. `int[*] x = { 1, 2 };`).\n2. Flexible array member uses `[*]`.\n\n### Removed\n\n1. The spiral rule type declaration (see above).\n2. Complex types\n3. size_t, ptrdiff_t (see above).\n4. Array types do not decay.\n\n## Types\n\n### Added\n\n1. `bitstruct` a struct with a container type allowing precise control over bit-layout, replacing bitfields and enum masks.\n2. `fault` an enum type with unique values which are used together with optional.\n3. Vector types.\n4. Optional types.\n5. `enum` allows a set of unique constants to be associated with each enum value.\n6. Compile time reflection and limited runtime reflection on types (see \"Reflection\")\n7. All types have a `typeid` property uniquely referring to that particular type.\n8. Distinct types, which are similar to aliases, but represent distinctly different types.\n9. Types may have methods. Methods can be added to any type, including built-in types.\n10. Subtyping: using `inline` on a struct member allows a struct to be implicitly converted to this member type and use corresponding methods.\n11. Using `inline` on a distinct type allows it to be implicitly converted *to* its base type (but not vice versa).\n12. Types may add operator overloading to support `foreach` and subscript operations.\n13. Generic types through generic modules, using `(< ... >)` for the generic parameter list (e.g. `List(<int>) list;`).\n14. Interface types, `any` types which allows dynamic invocation of methods.\n\n### Changed\n\n1. `typedef` is replaced by `def` and has somewhat different syntax (e.g. `def MyTypeAlias = int;`).\n2. Function pointer syntax is prefix `fn` followed by a regular function declaration without the function name.\n\n### Removed\n\n1. Enums, structs and unions no longer have distinct namespaces.\n2. Enum, struct and union declarations should not have a trailing ';'\n3. Inline `typedef` is not allowed. `def` can only be used at the top level.\n4. Anonymous structs are not allowed.\n5. Type qualifiers are all removed, including `const`, `restrict`, `volatile`\n6. Function pointers types **cannot** be used \"raw\", but must always be used through a type alias.\n\n### Introspection\n\nCompile time type methods: `alignof`, `associated`, `elements`, `extnameof`, `inf`, `inner`, `kindof`, `len`,\n`max`, `membersof`, `min`, `nan`, `names`, `params`, `returns`, `sizeof`, `typeid`, `values`,\n`qnameof`, `is_eq`, `is_ordered`.\n\nRuntime type methods: `inner`, `kind`, `len`, `names`, `sizeof`.\n\n## Expressions\n\n### Added\n\n1. Expression block using `{| ... |}`. Somewhat similar to GCC statement expressions.\n2. Array initializers may use ranges. (e.g. `int[256] x = { [0..128] = 1 }`)\n3. `?:` operator, returning the first value if it can be converted to a boolean true, otherwise the second value is returned.\n4. Orelse `??` returning the first value if it is a result, the second if the first value was an optional value.\n5. Rethrow `!` suffix operator with an implicit `return` the value if it was an optional value.\n6. Dynamic calls, allowing calls to be made on the `any` and interfaces dispatched using a dynamic mechanism.\n7. Create a slice using a range subscript (e.g. `a[4..8]` to form a slice from element 4 to element 8).\n8. Two range subscript methods: `[start..inclusive_end]` and `[start:length]`. Start, end and length may be omitted for default values.\n9. Indexing from end: slices, arrays and vectors may be indexed from the end using `^`. `^1` represents the last element. This works for ranges as well.\n10. Range assignment, assign a single value to an entire range e.g. `a[4..8] = 1;`.\n11. Slice assignment, copy one range to the other range e.g. `a[4..8] = b[8..12];`.\n12. Array, vector and slice comparison: `==` can be used to make an element-wise comparison of two containers. \n13. `?` suffix operator turns a fault into an optional value.\n14. `!!` suffix panics if the value is an optional value.\n15. `$defined(...)` returns true if the last expression is defined (sub-expressions must be valid).\n16. `$and(...)` `$or(...)` perform compile time logic, and may also be written as `&&&` and `|||` respectively. \n- It does not check any elements after the first false value found for `$and()` also written as `&&&`. To check both conditions are false use: `!false_condition &&& !false_condition`.\n- It does not check any values after the first true found for `$or()` also written as `|||`.\n17. Lambdas (anonymous functions) may be defined, they work just like functions and do not capture any state.\n18. Simple bitstructs (only containing booleans) may be manipulated using bit operations `& ^ | ~` and assignment.\n19. Structs may implicitly convert to their `inline` member if they have one.\n20. Pointers to arrays may implicitly convert to slices.\n21. Any pointer may implicitly convert to an `any` with type being the pointee.\n22. Optional values will implicitly invoke \"flatmap\" on an expression it is a subexpression of.\n23. Swizzling for arrays and vectors.\n\n### Changed\n\n1. Compound literals use `Type { ... }` rather than `(Type) { ... }`\n2. Operator precedence of bit operations is higher than `+` and `-`.\n3. Well defined-evaluation order: left-to-right, assignment after expression evaluation.\n4. `sizeof` is `$sizeof` and only works on expressions. Use `Type.sizeof` on types.\n5. `alignof` is `$alignof` for expressions. Types use `Type.alignof`.\n6. Narrowing conversions are only allowed if all sub-expressions is as small or smaller than the type.\n7. Widening conversions are only allowed on simple expressions (i.e. most binary expressions and some unary may not be widened)\n\n### Removed\n\n1. The comma operator is removed.\n\n### Cast changes\n\n## Functions\n\n### Added\n\n1. Functions may be invoked using named arguments, the name is the dot-prefixed parameter name, e.g. `foo(name: a, len: 2)`.\n2. Typed varargs are declared `Type... argument`, and will take 0 or more arguments of the given type.\n3. It is possible to \"splat\" an array or slice into the location of a typed vararg using `...`: `foo(a, b, ...list)`\n4. `any` varargs are declared `argument...`, it can take 0 or more arguments of any type which are implicitly converted to the `any` type.\n5. The function declaration may have `@inline` or `@noinline` as a default.\n6. Using `@inline` or `@noinline` on a function call expression will override the function default.\n7. Type methods are functions defined in the form `fn void Foo.my_method(Foo* foo) { ... }`, they can be invoked using dot syntax.\n8. Type methods may be attached to any type, even arrays and vectors.\n9. Error handling using optional return types.\n\n### Changed\n\n1. Function declarations use the `fn` prefix.\n\n### Removed\n\n1. Functions with C-style varargs may be called, and declared as external functions, but not used for C3 functions.\n\n## Attributes\n\nC3 adds a long range of attributes in the form `@name(...)`. It is possible to create custom \nattribute groups using `def` (e.g. `def MyAttribute(usz align) = { @aligned(align) @weak };`) which\ngroups certain attributes. Empty attribute groups are permitted.\n\nThe complete list: `@align`, `@benchmark`, `@bigendian`, `@builtin`,\n`@callconv`, `@deprecated`, `@dynamic`, `@export`,\n`@extern`, `@if`, `@inline`, `@interface`,\n`@littleendian`, `@local`, `@maydiscard`, `@naked`,\n`@nodiscard`, `@noinit`, `@noreturn`, `@nostrip`,\n`@obfuscate`, `@operator`, `@overlap`, `@priority`,\n`@private`, `@public`, `@pure`, `@reflect`,\n`@section`, `@test`, `@used`, `@unused`.\n\n## Declarations\n\n### Added\n\n1. `var` declaration for type inferred variables in macros. E.g. `var a = some_value;`\n2. `var` declaration for new type variables in macros. E.g. `var $Type = int;`\n3. `var` declaration for compile time mutable variables in function and macros. E.g. `var $foo = 1;`\n4. `const` declarations may be untyped. Such constants are not stored in the resulting binary.\n\n### Changed\n\n1. `tlocal` declares a variable to be thread local.\n2. `static` top level declarations are replaced with `@local`. (`static` in functions is unchanged)\n\n### Removed\n\n1. `restrict` removed.\n2. `atomic` should be replaced by atomic load/store operations.\n3. `volatile` should be replaced by volatile load/store operations.\n\n## Statements\n\n### Added\n\n1. Match-style variant of the `switch` statement, allows each `case` to hold an expression to test.\n2. Switching over type with `typeid`.\n3. Unpack `any` to the underlying type with an `any`-switch.\n4. `nextcase` to fallthrough to the next case.\n5. `nextcase <expr>` to jump to the case with the expression value (this may be an expression evaluated at runtime).\n6. `nextcase default` to jump to the `default` clause.\n7. Labelled `while`/`do`/`for`/`foreach` to use with `break` `nextcase` and `continue`.\n8. `foreach` to iterate over arrays, vectors, slices and user-defined containers using operator overloading.\n9. `foreach_r` to iterate in reverse.\n10. `foreach` / `foreach_r` may take the element by value or reference. The index may optionally be provided.\n11. `$if`, `$switch`, `$for`, `$foreach` statements executing at compile time.\n12. `$echo` printing a message at compile time.\n13. `$assert` compile time assert.\n14. `defer` statement to execute statements at scope exit.\n15. `defer catch` and `defer try` similar to `defer` but executes only on optional exit or regular exit of scope respectively.\n16. `do` statements may omit `while`, behaving same as `while (0)`\n17. `if` may have a label. Labelled `if` may be exited using labelled break.\n18. `asm` blocks for inline assembly. \n19. if-try statements allows you to run code where an expression is a result.\n20. if-catch statements runs code on fault. It can be used to implicitly unwrap variables.\n21. Exhaustive switching on enums.\n\n### Changed\n\n1. Switch cases will have implicit break, rather than implicit fallthrough.\n2. `assert` is an actual statement and may take a string or a format + arguments.\n3. `static_assert` is `$assert` and is a statement.\n\n### Removed\n\n1. `goto` removed, replaced by labelled break, continue and nextcase.\n\n## Compile time evaluation\n\n### Added\n\n1. `@if(cond)` to conditionally include a struct/union field, a user-defined type etc.\n2. Compile time variables with `$` prefix e.g. `$foo`.\n3. `$if...$else...$endif` and `$switch...$endswitch` inside of functions to conditionally include code.\n4. `$for` and `$foreach` to loop over compile time variables and data.\n5. `$typeof` determines an expression type without evaluating it.\n6. Type properties may be accessed at compile time.\n7. `$define` returns true if the variable, function or type exists.\n8. `$error` emits an error if encountered.\n9. `$embed` includes a file as binary data.\n10. `$include` includes a file as text.\n11. `$exec` includes the output of a program as code.\n12. `$evaltype` takes a compile time string and turns it into a type.\n13. `$eval` takes a string and turns it into an identifier.\n14. `$extnameof` turns an identifier into its string external name.\n15. `$nameof` turns an identifier into its local string name.\n16. `$qnameof` turns an identifier into its local string name with the module prefixed.\n17. Compile time constant values are always compile time folded for arithmetic operations and casts.\n18. `$$FUNCTION` returns the current function as an identifier.\n\n### Changed\n\n1. `#define` for constants is replaced by untyped constants, e.g. `#define SOME_CONSTANT 1` becomes `const SOME_CONSTANT = 1;`.\n2. `#define` for variable and function aliases is replaced by `def`, e.g. `#define native_foo win32_foo` becomes `def native_foo = win32_foo;`\n3. In-function `#if...#else..#endif` is replaced by `$if`, `#if...#elif...#endif` is replaced by `$switch`.\n4. For converting code into a string use `$stringify`.\n5. Macros for date, line etc are replaced by `$$DATE`, `$$FILE`, `$$FILEPATH`, `$$FUNC`, `$$LINE`, `$$MODULE`, `$$TIME`.\n\n### Removed\n\n1. Top level `#if...#endif` does not have a counterpart. Use `@if` instead.\n2. No `#include` directives, `$include` will include text but isn't for the same use.\n\n## Macros\n\n### Added\n\n1. `macro` for defining macros.\n2. \"Function-like\" macros have no prefix and has only regular parameters or type parameters.\n3. \"At\"-macros are prefixed with `@` and may also have compile time values, expression and ref parameters, and may have a trailing body.\n4. Type parameters have the prefix `$` and conform to the type naming standard (\"$TypeFoo\").\n5. \"ref\" parameters are declared using with a `&` prefix operator. This is similar to C++ ref parameters.\n6. Expression parameters are unevaluated expressions, this is similar to arguments to `#define`.\n7. Compile time values have a `$` prefix and must contain compile time constant values.\n8. Any macro that evaluates to a constant result can be used as if it was the resulting constant.\n9. Macros may be recursively evaluated.\n10. Macros are inlined at the location where they are invoked.\n11. Unless resulting in a single constant, macros implicitly create a runtime scope.\n\n### Removed\n\n1. No `#define` macros.  \n2. Macros cannot be incomplete statements.\n\n## Features provided by builtins\n\nSome features are provided by builtins, and appears as normal functions and macros in the standard library\nbut nonetheless provided unique functionality:\n\n1. `@likely(...)` / `@unlikely(...)` on branches affects compilation optimization.\n2. `@anycast(...)` casts an `any` with an optional result.\n3. `unreachable(...)` marks a path as unreachable with a panic in safe mode.\n4. `unsupported(...)` similar to unreachable but for functionality not implemented.\n5. `@expect(...)` expect a certain value with an optional probability for the optimizer.\n6. `@prefetch(...)` prefect a pointer.\n7. `swizzle(...)` swizzles a vector.\n8. `@volatile_load(...)` and `@volatile_store(...)` volatile load/store.\n9. `@atomic_load(...)` and `@atomic_store(...)` atomic load/store.\n10. `compare_exchange(...)` atomic compare exchange.\n11. Saturating add, sub, mul, shl on integers.\n12. Vector reduce operations: add, mul, and, or, xor, max, min.\n\n## Modules\n\n1. Modules are defined using `module <name>`. Where name is on the form `foo::bar::baz`\n2. Modules can be split into an unlimited number of module sections, each starting with the same module name declaration.\n3. The `import` statement imports a given module.\n4. Each module section has its own set of import statements.\n5. Importing a module gives access to the declarations that are `@public`.\n6. Declarations are default `@public`, but a module section may set a different default (e.g. `module my_module @private;`)\n7. `@private` means the declaration is only visible in the module.\n8. `@local` means only visible to the current module section.\n9. Imports are recursive. For example, `import my_lib` will implicitly also import `my_lib::net`.\n10. Multiple imports may be specified with the same `import`, e.g. `import std::net, std::io;`.\n11. Generic modules have a set of parameters after the module name `module arr(<Type, LEN>);`\n12. Generic modules are not type checked until any of its types, functions or globals are instantiated.\n\n## Contracts\n\n1. Doc comments (starting with `<*`) are parsed.\n2. The first part, up until the first `@` directive is ignored.\n3. The `@param` directive for pointer arguments may define usage constraints `[in]` `[out]` and `[inout]`.\n4. Pointer argument constraints may add a `&` prefix to indicate that they may not be `null`, e.g. `[&inout]`.\n5. Contracts may be attached to generic modules, functions and macros.\n6. `@require` directives are evaluated given the arguments provided. Failing them may be a compile time or runtime error.\n7. The `@ensure` directive is evaluated at exit - if the return is a result and not an optional.\n8. `return` can be used as a variable identifier inside of `@ensure`, and holds the return value.\n9. `@return!` optionally lists the errors used. This will be checked at compile time.\n10. `@pure` says that no writing to globals is allowed inside and only `@pure` functions may be called.\n\n## Benchmarking\n\n1. Benchmarks are indicated by `@benchmark`.\n2. Marking a module section `@benchmark` makes all functions inside of it implicitly benchmarks.\n3. Benchmarks are usually not compiled.\n4. Benchmarks are instead only run by the compiler on request.\n\n## Testing\n\n1. Tests are indicated by `@test`.\n2. Marking a module section `@test` makes all functions inside of it implicitly tests.\n3. Tests are usually not compiled.\n4. Tests are instead only run by the compiler on request.\n\n## Safe / fast\n\nCompilation has two modes: \"safe\" and \"fast\". Safe will insert checks for out-of-bounds access, null-pointer deref,\nshifting by negative numbers, division by zero, violation of contracts and asserts.\n\nFast will assume all of those checks can be assumed to always pass. This means that unexpected behaviour may result\nfrom violating those checks. It is recommended to develop in \"safe\" mode.\n\nIf debug symbols are available, C3 will produce a stack trace in safe mode where an error occurs.";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"symbols-and-literals","text":"Symbols and literals"},{"depth":3,"slug":"added","text":"Added"},{"depth":3,"slug":"removed","text":"Removed"},{"depth":2,"slug":"built-in-types","text":"Built-in types"},{"depth":3,"slug":"added-1","text":"Added"},{"depth":3,"slug":"changed","text":"Changed"},{"depth":3,"slug":"removed-1","text":"Removed"},{"depth":2,"slug":"types","text":"Types"},{"depth":3,"slug":"added-2","text":"Added"},{"depth":3,"slug":"changed-1","text":"Changed"},{"depth":3,"slug":"removed-2","text":"Removed"},{"depth":3,"slug":"introspection","text":"Introspection"},{"depth":2,"slug":"expressions","text":"Expressions"},{"depth":3,"slug":"added-3","text":"Added"},{"depth":3,"slug":"changed-2","text":"Changed"},{"depth":3,"slug":"removed-3","text":"Removed"},{"depth":3,"slug":"cast-changes","text":"Cast changes"},{"depth":2,"slug":"functions","text":"Functions"},{"depth":3,"slug":"added-4","text":"Added"},{"depth":3,"slug":"changed-3","text":"Changed"},{"depth":3,"slug":"removed-4","text":"Removed"},{"depth":2,"slug":"attributes","text":"Attributes"},{"depth":2,"slug":"declarations","text":"Declarations"},{"depth":3,"slug":"added-5","text":"Added"},{"depth":3,"slug":"changed-4","text":"Changed"},{"depth":3,"slug":"removed-5","text":"Removed"},{"depth":2,"slug":"statements","text":"Statements"},{"depth":3,"slug":"added-6","text":"Added"},{"depth":3,"slug":"changed-5","text":"Changed"},{"depth":3,"slug":"removed-6","text":"Removed"},{"depth":2,"slug":"compile-time-evaluation","text":"Compile time evaluation"},{"depth":3,"slug":"added-7","text":"Added"},{"depth":3,"slug":"changed-6","text":"Changed"},{"depth":3,"slug":"removed-7","text":"Removed"},{"depth":2,"slug":"macros","text":"Macros"},{"depth":3,"slug":"added-8","text":"Added"},{"depth":3,"slug":"removed-8","text":"Removed"},{"depth":2,"slug":"features-provided-by-builtins","text":"Features provided by builtins"},{"depth":2,"slug":"modules","text":"Modules"},{"depth":2,"slug":"contracts","text":"Contracts"},{"depth":2,"slug":"benchmarking","text":"Benchmarking"},{"depth":2,"slug":"testing","text":"Testing"},{"depth":2,"slug":"safe--fast","text":"Safe / fast"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
