const id = "Previous Versions/v0_6_8/Generic Programming/operator-overloading.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/generic-programming/operator-overloading";
						const body = "\nC3 allows some *limited* operator overloading for working with containers. \n\n## \"Element at\" operator `[]`\n\nImplementing `[]` allows a type to use the `my_type[<value>]` syntax:\n\n```c3\nstruct Foo\n{\n    double[] x;\n}\n\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n```\n\nIt's possible to use any type as argument, such as a string:\n\n```c3\nfn double Bar.get(&self, String str) @operator([])\n{\n    return self.get_val_by_key(str);\n}\n```\n\nOnly a single `[]` overload is allowed.\n\n## \"Element ref\" operator `&[]`\n\nSimilar to `[]`, the operator returns a value for `&my_type[<value>]`, which may\nbe retrieved in a different way. If this overload isn't defined, then `&my_type[<value>]` would\nbe a syntax error.\n\n```c3\nfn double* Foo.get_ref(&self, usz i) @operator(&[])\n{\n    return &self.x[i];\n}\n```\n\n## \"Element set\" operator `[]=`\n\nThe counterpart of `[]` allows setting an element using `my_type[<index>] = <value>`.\n\n```c3\nfn void Foo.set(&self, usz i, double new_val) @operator([]=)\n{\n    return self.x[i] = new_val;\n}\n```\n\n## \"len\" operator\n\nUnlike the previous operator overloads, the \"len\" operator simply enables functionality\nwhich augments the `[]`-family of operators: you can use the \"from end\" syntax e.g `my_type[^1]` \nto get the last element assuming the indexing uses integers.\n\n## Enabling `foreach`\n\nIn order to use a type with foreach, e.g. `foreach(d : foo)`, at a minimum methods \nwith overloads for `[]` (`@operator([])`) and `len` (`@operator(len)`) need to be added. \nIf `&[]` is implemented, foreach by reference is enabled (e.g. `foreach(double* &d : foo)`)\n\n```c3\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n\nfn usz Foo.len(&self) @operator(len)\n{\n    return self.x.len;\n}\n\nfn void test(Foo f)\n{\n    // Print all elements in f\n    foreach (d : f)\n    {\n        io::printfn(\"%f\", d);\n    }\n}\n```\n\n:::note\n\nOperator overloading is limited, by design, as these features delivered the most value while still keeping the language as simple as possible.\n\n:::\n";
						const data = {title:"Operator Overloading",description:"Operator Overloading",editUrl:true,head:[],template:"doc",sidebar:{order:81,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
