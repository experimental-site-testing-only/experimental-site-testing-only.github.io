const id = "Previous Versions/v0_6_8/Language Common/define.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/language-common/define";
						const body = "\n# The `def` statement\n\nThe `def` statement in C3 is intended for aliasing identifiers and types.\n\n## Defining a type alias\n\n`def <type alias> = <type>` creates a type alias. Type aliases need to follow the name convention of user defined types (i.e. capitalized\nnames with at least one lower case letter).\n\n```c3\ndef CharPtr = char*;\ndef Numbers = int[10];\n```\n\nFunction pointers _must_ be aliased in C3. The syntax is somewhat different from C:\n\n```c3\ndef Callback = fn void(int a, bool b);\n```\n\nThis defines an alias to function pointer type of a function that returns nothing and requires two arguments: an int and a bool. Here is a sample usage:\n\n```c3\nCallback cb = my_callback;\ncb(10, false);\n```\n\n## Distinct types\n\nSimilar to `def` aliases are `distinct` which create distinct new types. Unlike type aliases,\nthey do not implicitly convert to or from any other type.\nLiterals will convert to the distinct types if they would convert to the underlying type.\n\nBecause a distinct type is a standalone type, it can have its own methods, like any other user-defined type.\n\n```c3\ndistinct Foo = int;\nFoo f = 0; // Valid since 0 converts to an int.\nf = f + 1;\nint i = 1;\n// f = f + i Error!\nf = f + (Foo)i; // Valid\n```\n\n## Distinct inline\n\nWhen interacting with various APIs it is sometimes desirable for distinct types to implicitly convert *to* \nits base type, but not *from* that type.\n\nBehaviour here is analogous how structs may use `inline` to create struct subtypes.\n\n```c3\ndistinct CString = char*;\ndistinct ZString = inline char*;\n...\nCString abc = \"abc\";\nZString def = \"def\";\n// char* from_abc = abc; // Error!\nchar* from_def = def; // Valid!\n```\n\n## Function and variable aliases\n\n`def` can also be used to create aliases for functions and variables.\n\nThe syntax is `def <alias> = <original identifier>`.\n\n```c3\nfn void foo() { ... }\nint foo_var;\n\ndef bar = foo;\ndef bar_var = foo_var;\n\nfn void test() \n{\n  // These are the same:\n  foo();\n  bar();\n  \n  // These access the same variable:\n  int x = foo_var;\n  int y = bar_var;\n}  \n```\n\n## Using `def` to create generic types, functions and variables\n\nIt is recommended to favour using def to create aliases for parameterized types, but it can also be used for parameterized functions and variables:\n\n```c3\nimport generic_foo;\n\n// Parameterized function aliases\ndef int_foo_call = generic_foo::foo_call(<int>);\ndef double_foo_call = generic_foo::foo_call(<double>);\n\n// Parameterized type aliases\ndef IntFoo = Foo(<int>);\ndef DoubleFoo = Foo(<double>);\n\n// Parameterized global aliases\ndef int_max_foo = generic_foo::max_foo(<int>);\ndef double_max_foo = generic_foo::max_foo(<double>);\n```\n\nFor more information, see the chapter on [generics](/generic-programming/generics/).\n\n## Function pointer default arguments and named parameters\n\nIt is possible to attach default arguments to function pointer aliases. There is no requirement\nthat the function has the same default arguments. In fact, the function pointer may have \ndefault arguments where the function doesn't have it and vice-versa. Calling the function\ndirectly will then use the function's default arguments, and calling through the function pointer\nwill yield the function pointer alias' default argument.\n\nSimilarly, named parameter arguments follow the alias definition when calling through the \nfunction pointer:\n\n```c3\ndef TestFn = fn void(int y = 123);\n\nfn void test(int x = 5)\n{\n    io::printfn(\"X = %d\", x);\n}\n\nfn void main()\n{\n    TestFn test2 = &test;\n    test();         // Prints X = 5\n    test2();        // Prints X = 123\n    test(x: 3);     // Prints X = 3 \n    test2(y: 4);    // Prints X = 4\n}\n```\n";
						const data = {title:"Define",description:"The `def` statement",editUrl:true,head:[],template:"doc",sidebar:{order:61,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
