const id = "Standard Library/index.mdx";
						const collection = "docs";
						const slug = "standard-library";
						const body = "\nThe standard library is currently in development, so frequent changes will occur. Note that all std::core modules and\nsub modules are implicitly imported.\n\n## `std::core::builtin`\n\nAll functions and macros in this library can be used without path qualifiers.\n\n### `void panic(char* message, char *file, char *function, uint line)`\nDefault function called when the asserts fails.\n\n### `void @swap(&a, &b)`\nSwap values in `a` and `b`.\n\n```c\nint a = 3;\nint b = 5;\n@swap(a, b);\nio::printfn(\"%d\", a); // Prints 5\n```\n\n### `anycast(any v, $Type)`\n\nOptionally cast the value `v` to type `$Type*` on failure returns `CastResult.TYPE_MISMATCH`.\n\n```c\nint b;\nany a = &b;\nfloat*? c = anycast(a, float); // Will return TYPE_MISMATCH\nint*? d = anycast(a, int);     // Works!\n```\n\n### `void unreachable($string = \"Unreachable statement reached.\")`\n\nMark a code path as unreachable.\n\n```c\nswitch (x)\n{\n    case 0:\n        foo();\n    case 1:\n        bar();\n    default:\n        // Should never happen.\n        unreachable(\"x should have been 0 or 1\");\n}\n```\n\nOn safe mode this will throw a runtime panic when reached. For release mode the\ncompiler will assume this case never happens.\n\n### `bitcast(value, $Type)`\nDo a bitcast of a value to `$Type`, requires that the types are of the same memory size.\n```c\nfloat x = 1.0;\nint y = bitcast(x, int); // y = 0x3f800000\n```\n\n### `enum_by_name($Type, enum_name)`\nOptionally returns the enum value with the given name. `$Type` must be an enum. Returns `SearchResult.MISSING`\non failure.\n```c\nenum Foo { ABC, CDE, EFG }\n\nfn void? test()\n{\n    Foo f = enum_by_name(Foo, \"CDE\")!;\n    // same as Foo f = Foo.CDE;\n}\n```\n\n### `void @scope(&variable; @body)`\n\nScopes a variable:\n\n```\nint a = 3;\n\n@scope(a)\n{\n    a = 4;\n    a++;\n};\n\n// Prints a = 3\nio::printfn(\"a = %d\", a, b);\n```\n\n### `less`, `greater`, `less_eq`, `greater_eq`, `equals`\nAll macros take two values and compare them. Any type implementing `Type.less`\nor `Type.compare_to` may be compared (or if the type implements `<`). Types\nimplementing `Type.equals` may use `equals` even if neither `less` nor `compare_to`\nare implemented.\n\n### Faults\n\n- `IteratorResult` returned when reaching the end of an iterator.\n- `SearchResult` used when a search fails.\n- `CastResult` when an anycast fails.\n\n## `std::core::env`\n\n### Constants\n- `OS_TYPE` the OS type compiled for.\n- `COMPILER_OPT_LEVEL` the optimization level used.\n- `I128_SUPPORT` true if int128 support is available.\n- `COMPILER_SAFE_MODE` true if compiled with safety checks.\n\n## `std::core::mem`\n\n### `malloc`, `malloc_aligned`\n\nAllocate the given number of bytes. `malloc` will panic on out of memory,\nwhereas `malloc_aligned` returns an optional value.\n`malloc_aligned` adds an alignment, which must be a power of 2. Any pointer\nallocated using `malloc_aligned` must be freed using `free_aligned` rather\nthe normal `free` or memory corruption may result.\n\n```c\nchar* data = malloc(8);\nint[<16>]*? data2 = malloc_aligned(16 * int.sizeof), 128);\n```\n\n### `new($Type, #initializer), new_aligned($Type, #initializer)`\n\nThis allocates a single element of $Type, returning the pointer. An optional initializer may be added, which\nimmediately initializes the value to that of the initializer.\n\nIf no initializer is provided, it is zero initialized. `new_aligned` works the same but for overaligned types, such allocations\nmust be freed using `free_aligned`\n\n```c3\nint* a = mem::new(int);\nFoo* foo = mem::new(Foo, { 1, 2 });\n```\n\n### `alloc($Type)`, `alloc_aligned($Type)`\n\nAllocates a single element of $Type, same as `new`, but without initializing the data.\n\n### `new_array($Type, usz elements)`, `new_array_aligned($Type, usz elements)`\n\nAllocates a slice of `elements` number of elements, returning\na slice of the given length. Elements are zero initialized. `new_array_aligned` is used for\ntypes that exceed standard alignment.\n\n```c3\nint[] ints = mem::new_array(int, 100); // Allocated int[100] on the heap, zero initialized.\n```\n\n### `alloc_array($Type, usz elements)`, `alloc_array_aligned($Type, usz elements)`\n\nSame as `new_array` but without initialization.\n\n### `calloc`, `calloc_checked`, `calloc_aligned`\n\nIdentical to the `malloc` variants, except the data is guaranteed to be zeroed out.\n\n### `realloc`, `realloc_checked`, `realloc_aligned`\n\nResizes memory allocated using `malloc` or `calloc`. Any extra data is\nguaranteed to be zeroed out. `realloc_aligned` can only be used with\npointers created using `calloc_aligned` or `alloc_aligned`.\n\n### `free`, `free_aligned`\n\nFrees memory allocated using `malloc` or `calloc`. Any memory allocated using \"_aligned\" variants\nmust be freed using `free_aligned`.\n\n### `@scoped(Allocator allocator; @body())`\n\nSwaps the current memory allocator for the duration of the call.\n\n```c\nDynamicArenaAllocator dynamic_arena;\ndynamic_arena.init(1024);\nmem::@scoped(&dynamic_arena)\n{\n    // This allocation uses the dynamic arena\n    Foo* f = malloc(Foo);\n};\n// Release any dynamic arena memory.\ndynamic_arena.destroy();\n\n```\n\n### `@tscoped(; @body())`\n\nSame as @scoped, but uses the temporary allocator rather than any\narbitrary allocator.\n\n### `void* tmalloc(usz size, usz alignment = 0)`\n\nAllocates memory using the temporary allocator. Panic on failure. It has type\nvariants similar to `malloc`, so `tmalloc(Type)` would create a `Type*` using\nthe temporary allocator.\n\n### `void* tcalloc(usz size, usz alignment = 0)`\n\nSame as `tmalloc` but clears the memory.\n\n### `void* trealloc(void* ptr, usz size, usz alignment = 0)`\n\n`realloc` but on memory received using `tcalloc` or `tmalloc`.\n\n### `tnew`, `temp_alloc`, `temp_array`, `talloc_array`\n\nSame as the `new`, `alloc`, `new_array` and `alloc_array` respectively.\n\n### `void @pool(;@body)`\n\nOpens a temporary memory scope.\n\n```c3\n@pool()\n{\n    // This allocation uses the dynamic arena\n    Foo* f = tmalloc(Foo);\n};\n```\n\n\n### `@volatile_load(&x)`\n\nReturns the value in `x` using a volatile load.\n\n```c3\n// Both loads will always happen:\nint y = @volatile_load(my_global);\ny = @volatile_load(my_global);\n```\n\n\n### `@volatile_store(&x, y)`\n\nStore the value `y` in `x` using a volatile store.\n\n```c3\n// Both stores will always happen:\n@volatile_store(y, 1);\n@volatile_store(y, 1);\n```\n### `usz aligned_offset(usz offset, usz alignment)`\n\nReturns an aligned size based on the current offset. The alignment\nmust be a power of two. E.g. `mem::aligned_offset(17, 8)` would return `24`\n\n### `usz aligned_pointer(void* ptr, usz alignment)`\n\nReturns a pointer aligned to the given alignment, using `aligned_offset`.\n\n### `bool ptr_is_aligned(void* ptr, usz alignment)`\n\nReturn true if the pointer is aligned, false otherwise.\n\n### `void copy(void* dst, void* src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)`\n\nCopies bytes from one pointer to another. It may optionally be set as volatile,\nin which case the copy may not be optimized away. Furthermore the source\nand destination alignment may be used.\n\n```c3\nFoo* f = tmalloc(data_size);\nmem::copy(f, slice.ptr, size);\n```\n\n### `void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)`\n\nSets bytes to a value. This operation may be aligned and/or volatile. See the `copy` method.\n\n### `void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)`\n\nSets bytes to zero. This operation may be aligned and/or volatile. See the `copy` method.\n\n### `@clone(&value)`\n\nMakes a shallow copy of a value using the regular allocator.\n\n```c\nFoo f = ...\n\nreturn @clone(f);\n```\n\n### `@tclone(&value)`\n\nSame as `@clone` but uses the temporary allocator.\n\n## `std::core::types`\n\n### `bool is_comparable_value($Type)`\n\nReturn true if the type can be used with comparison operators.\n\n### `bool is_equatable_value(value)`\n\nReturn `true` if the value can be compared using the `equals` macro.\n\n### `bool is_equatable_value(value)`\n\nReturn `true` if the value can be compared using the comparison macros.\n\n### `kind_is_int(TypeKind kind)`\n### `any_to_int(any* v, $Type)`\n\nReturns an optional value of `$Type` if the any value losslessly\nmay be converted into the given type. Returns a `ConversionResult` otherwise.\n\n```c\nany* v = &&128;\nshort y = any_to_int(v, short)!!; // Works\nichar z = any_to_int(v, ichar)!!; // Panics VALUE_OUT_OF_RANGE\n```\n\n## `std::core::str::conv`\n\n### `usz? char32_to_utf8(Char32 c, char* output, usz available)`\nConvert a UTF32 codepoint to an UTF8 buffer. `size` has the number of\nwritable bytes left. It returns the number of bytes used, or\n`UnicodeResult.CONVERSION_FAILED` if the buffer is too small.\n\n### `void char32_to_utf16_unsafe(Char32 c, Char16** output)`\nConvert a UTF32 codepoint to an UTF16 buffer without bounds checking,\nmoving the output pointer 1 or 2 steps.\n\n## `std::io`\n\n### `String? readline(stream = io::stdin(), Allocator allocator = allocator::heap())`\nRead a `String?` from a file stream, which is standard input (stdin) by default, reads to the next newline character `\\n` or to the end of stream.\n`Readline` returns an [Optional](/language-common/optionals-essential/#what-is-an-optional) string.\n\n```c3\nimport std::io;\n\nfn void? hello_name()\n{\n    String? name = io::readline();\n    if (catch excuse = name)\n    {\n        return excuse?;\n    }\n\n    io::printfn(\"Name was: %s.\", name);\n}\n```\n\n:::note\n`\\r` will be filtered from the String.\n:::\n\n### `String? treadline(stream = io::stdin())`\nRead a `String?` from a file stream which is standard input (stdin) by default, Reads to the next newline character `\\n` or to the end of stream. `Treadline` returns an [Optional](/language-common/optionals-essential/#what-is-an-optional) string. The temporary allocator is used by `Treadline`, in contrast the `readline` defaults to the heap allocator, but is configurable to other allocators.\n\n```c\nimport std::io;\n\nfn void? hello_name()\n{\n    String? name = io::treadline();\n    if (catch excuse = name) {\n        return excuse?;\n    }\n\n    io::printfn(\"Hello %s! Hope you have a great day\", name);\n}\n```\n\n:::note\n`\\r` will be filtered from the String.\n:::\n\n### `void print(x)`, `void printn(x = \"\")`\n\nPrint a value to stdout works for the majority of types, including structs, which can be helpful for debugging.\nThe `printn` variant appends a newline.\n\n```c3\nimport std::io;\n\nenum Heat\n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main()\n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = WARM;\n    int[5] fib = { 0, 1, 1, 2, 3 };\n    String dialogue = \"secret\";\n\n    io::print(\"Hello\");   // Hello\n    io::print(20);        // 20\n    io::print(2.2);       // 2.200000\n    io::print(vec);       // [<4, 2>]\n    io::print(weather);   // WARM\n    io::print(fib);       // [0, 1, 1, 2, 3]\n    io::print(dialogue);  // secret\n}\n```\n\n### `void eprint(x)`, `void eprintn(x)`\nPrint any value to stderr.\nThe `eprintn` variant appends a newline.\n\nSee `print` for usage.\n\n### `usz? printf(String format, args...) @maydiscard`\nRegular printf functionality: `%s`, `%x`, `%d`, `%f` and `%p` are supported.\nWill also print enums and vectors. Prints to stdout.\n\n```c3\nimport std::io;\n\nenum Heat\n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main()\n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = REALLY_WARM;\n    String dialogue = \"Hello\";\n\n    io::printfn(\"%s\", dialogue);  // Hello\n    io::printfn(\"%d\", 20);        // 20\n    io::printfn(\"%f\", 2.2);       // 2.200000\n    io::printfn(\"%s\", vec);       // [<4, 2>]\n    io::printfn(\"%s\", weather);   // REALLY_WARM\n}\n```\n\nAlso available as `printfn` which appends a newline.\n\n### `usz? eprintf(String format, args...) @maydiscard`\nRegular printf functionality: `%s`, `%x`, `%d`, `%f` and `%p` are supported.\nWill also print enums and vectors. Prints to stderr.\n\nAlso available as `eprintfn` which appends a newline.\n\nSee `printf` for usage\n\n### `char[]? bprintf(char[] buffer, String format, args...) @maydiscard`\nPrints using a 'printf'-style formatting string, to a string buffer.\n\nReturns a slice of the `buffer` argument with the resulting length.\n\n### `usz? fprint(out, x)`, `usz? fprintn(out, x = \"\")`\nPrint a value to a stream. `out` must implement `OutStream`.\nThe `fprintn` variant appends a newline.\n\n### `usz? fprintf(OutStream out, String format, args...)`\nPrints to the specified OutStream using a 'printf'-style formatting string.\n\nReturns the number of characters printed.\n\n`fprintfn` appends a newline.\n\n### `void putchar(char c) @inline`\nLibc `putchar`, prints a single character to stdout.\n\n### `usz? DString.appendf(DString* str, String format, args...) @maydiscard`\nSame as printf but on dynamic strings.\n\n### `File* stdout()`, `File* stdin()`, `File* stderr()`\nReturn stdout, stdin and stderr respectively.\n\n## `std::io::file`\n\n### `File? open(String filename, String mode)`\nOpen a file with the given file name with the given mode (r, w etc)\n\n### `File? open_path(Path path, String mode)`\nOpen a file pointed to by a Path struct, with the given mode.\n\n### `bool is_file(String path)`\nSee whether the given path is a file.\n\n### `usz? get_size(String path)`\nGet the size of a file.\n\n### `void? delete(String filename)`\nDelete a file.\n\n### `void? File.reopen(&self, String filename, String mode)`\nReopen a file with a new filename and mode.\n\n### `usz? File.seek(&self, isz offset, Seek seek_mode = Seek.SET)`\nSeek in a file. Based on the libc function.\n\n### `void? File.write_byte(&self, char c) @dynamic`\nWrite a single byte to a file.\n\n### `void? File.close(&self) @inline @dynamic`\nClose a file, based on the libc function.\n\n### `bool File.eof(&self) @inline`\nTrue if EOF has been reached. Based on the libc function.\n\n### `usz? File.read(&self, char[] buffer)`\nRead into a buffer, based on the libc function.\n\n### `usz? File.write(&self, char[] buffer)`\nWrite to a buffer, based on the libc function.\n\n### `char? File.read_byte(&self) @dynamic`\nRead a single byte from a file.\n\n### `char[]? load_buffer(String filename, char[] buffer)`\nLoad up to buffer.len characters into the buffer.\n\nReturns IoError.OVERFLOW if the file is longer than the buffer.\n\n### `char[]? load_new(String filename, Allocator allocator = allocator::heap())`\nLoad the entire file into a new buffer.\n\n### `char[]? load_temp(String filename)`\nLoad the entire file into a buffer allocated using the temporary allocator.\n\n### `void? File.flush(&self) @dynamic`\nFlush a file, based on the libc function.\n\n## `std::collections::list({ Type })`\n\nGeneric list module, elements are of `Type`.\n\n```c\nimport std::collections::list;\nalias MyIntList = List{ int };\n\n...\n\nMyIntList list;\nlist.init(mem); // heap allocated\nlist.push(123);\nlist.free();\n```\n\n### `List.push(List *list, Type element)`, `append(...)`\nAppend a single value to the list.\n\n### `Type List.pop(List* list)`\nRemoves and returns the last entry in the list.\n\n### `Type List.pop_first(List *list)`\nRemoves the first entry in the list.\n\n### `void List.remove_at(List *list, usz index)`\nRemoves the entry at `index`.\n\n### `void List.insert_at(List *list, usz index, Type type)`\nInserts a value at `index`.\n\n### `void List.push_front(List *list, Type type)`\nInserts a value to the front of the list.\n\n### `void List.remove_last(List* list)`\nRemove the last value of the list.\n\n### `void List.remove_first(List *list)`\nRemove the first element in the list.\n\n### `Type* List.first(List* list)`\nReturn the first element in the list if available.\n\n### `Type* List.last(List *list)`\nReturn the last element in the list if available.\n\n### `List.is_empty(List *list)`\nReturn `true` if the list is empty.\n\n### `usz List.len(List *list)`\nReturn the number of elements in the list.\n\n### `Type List.get(List *list, usz index)`\nReturn the value at `index`.\n\n### `void List.free(List *list)`\nFree all memory associated with this list.\n\n### `void List.swap(List *list, usz i, usz j)`\nSwap two elements in the list.\n\n";
						const data = {title:"Standard Library",description:"Standard Library",editUrl:true,head:[],template:"doc",sidebar:{order:128,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Standard Library/index.mdx",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
