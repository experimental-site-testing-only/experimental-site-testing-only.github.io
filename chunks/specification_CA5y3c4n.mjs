const id = "Previous Versions/v0_6_8/Implementation Details/specification.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/implementation-details/specification";
						const body = "\n*THIS SPECIFICATION IS UNDER DEVELOPMENT*\n\n## Notation\n\nThe syntax is specified using Extended Backus-Naur Form (EBNF):\n\n```\nproduction  ::= PRODUCTION_NAME '::=' expression?\nexpression  ::= alternative (\"|\" alternative)* \nalternative ::= term term*\nterm        ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition\nset         ::= '[' (range | CHAR) (rang | CHAR)* ']'\nrange       ::= CHAR '-' CHAR \ngroup       ::= '(' expression ')'\noption      ::= expression '?'\nrepetition  ::= expression '*'\n```\n\nProductions are expressions constructed from terms and the following operators, in increasing precedence:\n\n```\n|   alternation\n()  grouping\n?  option (0 or 1 times)\n*  repetition (0 to n times)\n```\n\nUppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are\nenclosed in single quotes ''.\n\nThe form `a..b` represents the set of characters from a through b as alternatives.\n\n## Source code representation\n\nA program consists of one or more _translation units_ stored in files written in the Unicode character set,\nstored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string\nliterals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode.\n\nA raw byte stream is translated into a sequence of tokens which white space and comments are discarded. Doc\ncomments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols\nof the syntactic grammar.\n\n### Lexical Translations\n\nA raw byte stream is translated into a sequence of tokens which white space and comments are discarded. Doc\ncomments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols\nof the syntactic grammar.\n\nThe longest possible translation is used at each step, even if the result does not ultimately make a correct program\nwhile another lexical translation would.\n\n> Example: `a--b` is translated as `a`, `--`, `b`, which does not form a grammatically correct expression, even though the tokenization `a`, `-`, `-`, `b` could form a grammatically correct expression.\n\n### Line Terminators\n\nThe C3 compiler divides the sequence of input bytes into lines by recognizing *line terminators*\n\nLines are terminated by the ASCII LF character (U+000A), also known as \"newline\". A line termination specifies the\ntermination of the // form of a comment.\n\n### Input Elements and Tokens\n\nAn input element may be:\n\n1. White space\n2. Comment\n3. Doc Contract\n4. Token\n\nA token may be:\n\n1. Identifier\n2. Keyword\n3. Literal\n4. Separator\n5. Operator\n\nA Doc Contract consists of:\n\n1. A stream of descriptive text\n2. A list of directive Tokens\n\nThose input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the\nsyntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For\nexample the characters `+` and `=` may form the operator token `+=` only if there is no intervening white space or\ncomment.\n\n### White Space\n\nWhite space is defined as the ASCII horizontal tab character (U+0009), form feed character (U+000A), vertical tab (\nU+000B), carriage return (U+000D), space character (U+0020) and the line terminator character (U+000D).\n\n```\nWHITESPACE      ::= [ \\t\\f\\v\\r\\n]\n```\n\n### Letters and digits\n\n```\nUC_LETTER       ::= [A-Z]\nLC_LETTER       ::= [a-z]\nLETTER          ::= UC_LETTER | LC_LETTER\nDIGIT           ::= [0-9]\nHEX_DIGIT       ::= [0-9a-fA-F]\nBINARY_DIGIT    ::= [01]\nOCTAL_DIGIT     ::= [0-7]\nLC_LETTER_US    ::= LC_LETTER | \"_\"\nUC_LETTER_US    ::= UC_LETTER | \"_\"\nALPHANUM        ::= LETTER | DIGIT\nALPHANUM_US     ::= ALPHANUM | \"_\"\nUC_ALPHANUM_US  ::= UC_LETTER_US | DIGIT\nLC_ALPHANUM_US  ::= LC_LETTER_US | DIGIT\n```\n\n### Comments\n\nThere are three types of regular comments:\n\n1. `// text` a line comment. The text between `//` and line end is ignored.\n2. `/* text */` block comments. The text between `/*` and `*/` is ignored. It has nesting behaviour, so for every `/*`\n   discovered between the first `/*` and the last `*/` a corresponding `*/` must be found.\n\n### Doc contract\n\n1. `<* text *>` doc block comment. The text between `<*` and `*>` is optionally parsed using the doc comment\n   syntactic grammar. A compiler may choose to read `<* text *>` as a regular comment.\n\n### Identifiers\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and\ndigits.\nThe first character in an identifier must be a letter or underscore.\n\nC3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters,\ntype identifiers - starting with an upper case letter followed by at least one underscore letter and regular\nidentifiers, starting with a lower case letter.\n\n```\nIDENTIFIER      ::=  \"_\"* LC_LETTER ALPHANUM_US*\nCONST_IDENT     ::=  \"_\"* UC_LETTER UC_ALPHANUM_US*\nTYPE_IDENT      ::=  \"_\"* UC_LETTER UC_ALPHANUM_US* LC_LETTER ALPHANUM_US*\nCT_IDENT        ::=  \"$\" IDENTIFIER\nCT_CONST_IDENT  ::=  \"$\" CONST_IDENT\nCT_TYPE_IDENT   ::=  \"$\" TYPE_IDENT\nAT_TYPE_IDENT   ::=  \"@\" TYPE_IDENT\nPATH_SEGMENT    ::= \"_\"* LC_LETTER LC_ALPHANUM_US*\n```\n\n### Keywords\n\nThe following keywords are reserved and may not be used as identifiers:\n\n```\nasm         any         anyfault\nassert      attribute   break\ncase        catch       const       \ncontinue    default     defer       \ndef         do          else        \nenum        extern      false\nfault       fn          if          \nimport      inline      macro\nmodule      nextcase    null\npublic      return      struct\nswitch      true        try\ntypeid      var         void        \nwhile\n\nbool        int128      double      \nfloat       long        ulong\nint         uint        byte\nshort       ushort      char\nisz         usz         float16\nfloat128    uint128     bfloat16\n\n$assert     $case       $default    \n$echo       $else       $error      \n$endfor     $endforeach $endif      \n$endswitch  $for        $foreach    \n$if         $switch     $typef      \n$vaarg      $vaconst    $vacount    \n$vaexpr     $vatype             \n                  \n```\n\n### Operators and punctuation\n\nThe following character sequences represent operators and punctuation.\n\n```\n&       @       ~       |       ^       :\n,       /       $       .       ;       )\n>       <       #       {       }       -\n(       )       *       [       ]       %\n>=      <=      +       +=      -=      !\n?       ?:      &&      ??      &=      |=\n^=      /=      ..      ==      ({      })\n[<      >]      (<      >)      ++      --      \n%=      !=      ||      ::      <<      >>      \n!!      ...     <<=     >>=\n```\n\n### Integer literals\n\nAn integer literal is a sequence of digits representing an integer constant.\nAn optional prefix sets a non-decimal base: 0b or 0B for binary,\n0o, or 0O for octal, and 0x or 0X for hexadecimal.\nA single 0 is considered a decimal zero.\nIn hexadecimal literals, letters a through f and A through F represent values 10 through 15.\n\nFor readability, an underscore character _ may appear after a base prefix\nor between successive digits; such underscores do not change the literal's value.\n\n```\nINTEGER         ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT\nDECIMAL_LIT     ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)?\nBINARY_LIT      ::= '0' [bB] '_'* BINARY_DIGITS\nOCTAL_LIT       ::= '0' [oO] '_'* OCTAL_DIGITS\nHEX_LIT         ::= '0' [xX] '_'* HEX_DIGITS\n\nBINARY_DIGIT    ::= [01]\nHEX_DIGIT       ::= [0-9a-fA-F]\n\nDECIMAL_DIGITS  ::= DIGIT ('_'* DIGIT)*\nBINARY_DIGITS   ::= BINARY_DIGIT ('_'* BINARY_DIGIT)*\nOCTAL_DIGITS    ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)*\nHEX_DIGITS      ::= HEX_DIGIT ('_'* HEX_DIGIT)*\n```\n\n```\n42\n4_2\n0_600\n0o600\n0O600           // second character is capital letter 'O'\n0xBadFace\n0xBad_Face\n0x_67_7a_2f_cc_40_c6\n170141183460469231731687303715884105727\n170_141183_460469_231731_687303_715884_105727\n\n0600            // Invalid, non zero decimal number may not start with 0 \n_42             // an identifier, not an integer literal\n42_             // invalid: _ must separate successive digits\n0_xBadFace      // invalid: _ must separate successive digits\n```\n\n### Floating point literals\n\nA floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point,\na fractional part (decimal digits), and an exponent part (e or E followed by an optional\nsign and decimal digits). One of the integer part or the fractional part may be elided;\none of the decimal point or the exponent part may be elided. An exponent value exp scales\nthe mantissa (integer and fractional part) by powers of 10.\n\nA hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part\n(hexadecimal digits), a radix point, a fractional part (hexadecimal digits),\nand an exponent part (p or P followed by an optional sign and decimal digits).\nOne of the integer part or the fractional part may be elided; the radix point\nmay be elided as well, but the exponent part is required.\nAn exponent value exp scales the mantissa (integer and fractional part) by powers of 2.\n\nFor readability, an underscore character _ may appear after a base prefix or between successive digits;\nsuch underscores do not change the literal value.\n\n```\nFLOAT_LIT       ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT\nDEC_FLOAT_LIT   ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? \n                    | DECIMAL_DIGITS DEC_EXPONENT\n                    | '.' DECIMAL_DIGITS DEC_EXPONENT?\nDEC_EXPONENT    ::= [eE] [+-]? DECIMAL_DIGITS\nHEX_FLOAT_LIT   ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT\nHEX_MANTISSA    ::= HEX_DIGITS '.' HEX_DIGITS?\n                    | HEX_DIGITS\n                    | '.' HEX_DIGITS \nHEX_EXPONENT    ::= [pP] [+-] DECIMAL_DIGITS                    \n```\n\n### Characters\n\nCharacters are the fundamental components of strings and character literals.\n\n```\nCHAR_ELEMENT    ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F]\nCHAR_LIT_BYTE   ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE\nCHAR_ESCAPE     ::= [abefnrtv\\'\\\"\\\\] \n                    | 'x' HEX_DIGIT HEX_DIGIT\nUNICODE_CHAR    ::= unicode_char                    \n                    | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n                    | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT \n                          HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n```\n\n### Backslash escapes\n\nThe following backslash escapes are available for characters and string literals:\n\n```text\n\\0      0x00 zero value\n\\a      0x07 alert/bell\n\\b      0x08 backspace\n\\e      0x1B escape\n\\f      0x0C form feed\n\\n      0x0A newline\n\\r      0x0D carriage return\n\\t      0x09 horizontal tab\n\\v      0x0B vertical tab\n\\\\      0x5C backslash\n\\'      0x27 single quote '\n\\\"      0x22 double quote \"\n\\x      Escapes a single byte hex value\n\\u      Escapes a two byte unicode hex value \n\\U      Escapes a four byte unicode hex value\n```\n\n### String literals\n\nA string literal represents a string constant obtained from concatenating a sequence of characters.\nString literals are character sequences between double quotes, as in \"bar\". Within the quotes,\nany character may appear except newline and unescaped double quote. The text between the\nquotes forms the value of the literal, with backslash escapes interpreted as they are in\nrune literals, with the same restrictions. The two-digit hexadecimal (\\xnn) escapes represent\nindividual bytes of the resulting string; all other escapes represent the (possibly multibyte)\nUTF-8 encoding of individual characters. Thus inside a string literal `\\xFF` represent a single\nbyte of value `0xFF` = 255, while `Ã¿`, `\\u00FF`, `\\U000000FF` and `\\xc3\\xbf` represent the two bytes\n`0xc3 0xbf` of the UTF-8 encoding of character `U+00FF`.\n\n```\nSTRING_LIT      ::= \\x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \\x22\n```\n\n#### Compile time string concatenation\n\nStrings will concatenate if declared in sequence.\n\nExample:\n\n```c\nString s = \"abc\" \"def\" \"ghi\";\n// This is equivalent to:\nString s = \"abcdefghi\";\n```\n\n### Raw string literals\n\nRaw string literals are enclosed between \\`\\` and consist of the raw UTF8 in the source\ncode between the \"\\`\". A sequence of two \"\\`\" will be interpreted as a single escaped \"\\`\" that does\nnot terminate the literal.\n\n#### Compile time concatenation\n\nRaw strings will concatenate with other regular strings and raw strings (\nsee [string literal compile time concatenation](#compile-time-string-concatenation)).\n\n#### Source code pre-filtering\n\nThe source code will pre-filter `\\r` (`0x0D`) from the source code. This means that it is also implicitly\nfiltered out of raw strings.\n\n### Character literals\n\nA character literal is enclosed in `'` and may either consist of 1, 2, 4, 8, 16 bytes.\n\n```\nCHARACTER_LIT   ::= \"'\" (CHAR_LIT_BYTE+) | UNICODE_CHAR \"'\"\n```\n\n## Types\n\nTypes consist of built-in types and user-defined types (enums, structs, unions, bitstructs, fault and distinct).\n\n### Boolean types\n\n`bool` may have the two values `true` and `false`. It holds a single bit of information but is\nstored in a `char` type.\n\n### Integer types\n\nThe built-in integer types:\n\n```text\nchar      unsigned 8-bit\nichar     signed 8-bit\nushort    unsigned 16-bit\nshort     signed 16-bit\nuint      unsigned 32-bit\nint       signed 32-bit\nulong     unsigned 64-bit\nlong      signed 64-bit\nuint128   unsigned 128-bit\nint128    singed 128-bit\n```\n\nIn addition, the following type aliases exist:\n\n```text\nuptr      unsigned pointer size\niptr      signed pointer size\nusz       unsigned pointer offset / object size\nisz       signed pointer offset  / object size\n```\n\n### Floating point types\n\nBuilt-in floating point types:\n\n```\nfloat16   IEEE 16-bit*\nbfloat16  Brainfloat*\nfloat     IEEE 32-bit\ndouble    IEEE 64-bit\nfloat128  IEEE 128-bit*\n```\n\n(* optionally supported)\n\n### Vector types\n\nA vector lowers to the platform's vector types where available. A vector has a base type and a width.\n\n```\nvector_type        ::= type \"[<\" length \">]\"\n```\n\n#### Vector base type\n\nThe base type of a vector must be boolean, an integer or a floating point type.\n\n#### Min width\n\nThe vector width must be at least 1.\n\n#### Element access\n\nVector elements are accessed using `[]`. It is possible to take the address of a single element.\n\n#### Alignment\n\nAlignment of vectors are platform dependent, but is at least the alignment of its element type.\n\n#### Vector operations\n\nVectors support the same arithmetics as its underlying type, and will perform the operation\nelement-wise.\n\nExample:\n\n```c\nint[<2>] a = { 1, 3 };\nint[<2>] b = { 2, 7 };\n\nint[<2>] c = a * b;\n// Equivalent to\nint[<2>] c = { a[0] * b[0], a[1] * b[1] };\n```\n\n### Array types\n\nAn array has the alignment of its elements. An array must have at least one element.\n\n### Slice types\n\nThe slice consist of a pointer, followed by an usz length, having the alignment of pointers.\n\n### Pointer types\n\nA pointer is the address to memory.\n\n```text\npointer_type       ::= type \"*\"\n```\n\n#### Pointee type\n\nThe type of the memory pointed to is the **pointee type**. It may be any runtime type.\n\n#### `iptr` and `uptr`\n\nA pointer may be losslessly cast to an `iptr` or `uptr`. An `iptr` or `uptr` may be cast to a pointer of any type.\n\n#### The wildcard pointer `void*`\n\nThe `void*` may implicitly cast into any other pointer type. The `void*`\n[implicitly casts into any other pointer.\n\nA void* pointer may never be dereferenced.\n\n#### Pointer arithmetic on `void*`\n\nPerforming pointer arithmetics on void* will assume that the element size is 1. This includes\npointer arithmetics using subscripting.\n\n#### Subscripting\n\nSubscripting a pointer is equal to performing pointer arithmetics using the index, followed by a deref.\nSubscripts on pointers may be negative and will never do bounds checks.\n\n#### Deref\n\nDereferencing a pointer will return the value in the memory location interpreted as the **pointee type**.\n\n####\n\n### Struct types\n\nA struct may not have zero members.\n\n#### Alignment\n\nA non-packed struct has the alignment of the member that has the highest alignment. A packed struct\nhas alignment 1. See [align attribute](#attributes) for details on changing the alignment.\n\n### Union types\n\nA union may not have zero members.\n\n#### Alignment\n\nA union has the alignment of the member that has the highest alignment. See [align attribute](#attributes) for\ndetails on changing the alignment.\n\n### Fault types\n\nA fault is an extensible enum which can be used to create an Excuse for an empty [optional](/language-common/optionals-essential/#what-is-an-optional).\n\n#### Alignment\n\nA fault type has the same alignment as a pointer. See [align attribute](#attributes) for details on changing the\nalignment.\n\n### Enum types\n\n### Function types\n\n### Typeid type\n\nThe typeid is a pointer sized value which uniquely identifies a type.\n\n### Any type\n\nThe `any` is a fat pointer (2 pointers wide) holding a pointer to a value and its corresponding [typeid](#typeid-type).\nIt cannot be dereferenced.\n\n#### Fields\n\n`.ptr` returns a `void*` pointer to the underlying value `.type` returns the [typeid](#typeid-type)\nof the underlying value.\n\n#### Switching over `any`\n\nSwitching over an `any` value creates an [any switch](#any-switch).\n\n### Anyfault type\n\n## Declarations and scope\n\n## Expressions\n\n### Assignment expression\n\n```\nassignment_expr    ::= ct_type_assign | unary_expr assignment_op expr\nct_type_assign     ::= ct_type_ident \"=\" type\nassignment_op      ::= \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \"&=\" | \"^=\" | \"|=\"\n```\n\n#### Type assign\n\nThis assigns a new type to a compile time type variable. The value of the expression is the type assigned.\n\n#### Combined assign\n\nAll assignment operations except for `=` are combined assign operation. They first perform the operation indicated\nby the leftmost character(s) in the operator (e.g `+` for `+=`, `<<` for `<<=` etc) with the lhs and the rhs.\nThe result is then assigned to the left hand side. The result of the operation is the new value of the left\nhand side.\n\n#### Implicit conversion\n\nIf the left hand side is a pointer and the operation is `+=` or `-=` an attempt to implicitly convert to\n`isz`/`usz` will be tried.\n\nFor all other types and operations, **an implicit conversion** of rhs to the type of lhs will be tried.\n\n### Ternary, elvis and or-else expressions\n\n```\nternary_group_expr ::= suffix_group_expr | ternary_expr | elvis_expr | orelse_expr\nternary_expr       ::= or_expr \"?\" expr \":\" ternary_group_expr\nelvis_expr         ::= suffix_expr \"?:\" ternary_group_expr\norelse_expr        ::= suffix_expr \"??\" ternary_group_expr\n```\n\n#### Ternary evaluation\n\nThe most left-hand expression is evaluated to a boolean. If it is true, the value of the middle\nexpression is returned, otherwise the last expression is returned.\n\nOnly the most left-hand expression and the returned expressions are evaluated.\n\nThe middle and last expression are implicitly converted to their **unified type**.\n\nThe resulting type is the **unified type**.\n\n#### Elvis evaluation\n\nLhs and rhs are implicitly converted to their **unified type**.\n\nThe lhs is evaluated, it is then converted to a boolean, if the result it true, return the lhs value\nbefore its boolean conversion. Otherwise return the right hand side.\n\nThe right hand side is only evaluated if the lhs evaluates to false.\n\nThe resulting type is the **unified type**.\n\n#### Orelse evaluation\n\nThe lhs must be optional. The non-optional type for lhs and rhs are calculated.\nThe **unified type** of the result is calculated. Lhs are converted to the unified type\npreserving their optionality.\n\nAt runtime, lhs is evaluated. If it evaluates to an optional, rhs is returned instead.\n\nRhs is only evaluated if lhs evaluates to an optional.\n\nThe resulting type of the orelse is the post conversion type of the rhs.\n\n### Suffix expression\n\nSuffix expressions convert a fault to an optional.\n\n```\nsuffix_group_exp   ::= or_group_expr | suffix_expr\nsuffix_expr        ::= or_group_expr \"?\" \"!\"?\n```\n\n#### Effect of `?`\n\nThe `?` will convert the expression into an optional. The left hand side must be a fault type.\nIf an optional `!` follows, this optional is immediately returned, as if by a `return <expr>?` statement.\n\n#### Type of the expression\n\nThe type is a **wildcard optional**. If `!` is added, it is a **wildcard** type.\n\n### Rethrow expression\n\nIf the expression is optional, implicitly return with the optional value.\n\n```\nrethrow_expr       ::= expr \"!\"\n```\n\n#### The expression to rethrow\n\nThe expression must have an optional type, otherwise this is a compile time error.\n\n#### Type\n\nThe type of \"rethrow\" is the inner expr type without optional.\n\n### Relational expression\n\n```\nrel_group_expr     ::= add_group_expr | relational_expr\nrelational_expr    ::= rel_group_expr relational_op add_group_expr\nrelational_op      ::= \"<\" | \">\" | \"<=\" | \">=\" \n```\n\nTODO\n\n### And expression\n\nThis binary expression evaluates the lhs, and if the result is `true` evaluates the rhs. The\nresult is true if both lhs and rhs are true.\n\n```\nand_group_expr     ::= rel_group_expr | and_expr\nand_expr           ::= and_group_expr \"&&\" rel_group_expr\n```\n\n#### Type\n\nThe type of the and-expression is `bool`.\n\n### Or expression\n\nThis binary expression evaluates the lhs, and if the result is `false` evaluates the rhs. The\nresult is true if lhs or rhs is true.\n\n```\nor_group_expr      ::= and_group_expr | or_expr\nor_expr            ::= or_group_expr \"||\" and_group_expr\n```\n\n#### Constant folded arithmetics\n\nConstant folding will happen for constant integers and floating. Vectors operations will\nnot be constant-folded.\n\nConstant folded operations are: multiplication, division, addition, subtraction,\nbit shifts, bit negation, bitwise and, or and xor, comparison, logical and/or,\nand negation.\n\n#### Type\n\nThe type of the or-expression is `bool`.\n\n### Casts\n\n### Pointer casts\n\n#### Integer to pointer cast\n\nAny integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered\nnon-constant, except in the special case where the integer == 0. In that case, the result is constant `null`.\n\nExample:\n\n```\nbyte a = 1;\nint* b = (int*)a; // Invalid, pointer type is > 8 bits.\nint* c = (int*)1; // Valid, but runtime value.\nint* d = (int*)0; // Valid and constant value.\n```\n\n#### Pointer to integer cast\n\nA pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer\nsize. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is\nequal to the integer value 0.\n\nExample:\n\n```\nfn void test() { ... }\ndef VoidFunc = fn void test();\n\nVoidFunc a = &test;\nint b = (int)null;\nint c = (int)a; // Invalid, not constant\nint d = (int)((int*)1); // Invalid, not constant\n```\n\n### Subscript operator\n\nThe subscript operator may take as its left side a pointer, array or slice. The index may be of any integer\ntype. TODO\n*NOTE* The subscript operator is not symmetrical as in C. For example in C3 `array[n] = 33` is allowed, but\nnot `n[array] = 33`. This is a change from C.\n\n### Operands\n\n### Compound Literals\n\nCompound literals have the format\n\n```\ncompound_literal   ::= (type) initializer_list\ninitializer_list   ::= '{' (initializer_param (',' initializer_param)* ','?)? '}'\ninitializer_param  ::= expression | designator '=' expression\ndesignator         ::= array_designator | range_designator | field_designator\narray_designator   ::= '[' expression ']'\nrange_designator   ::= '[' range_expression ']'\nfield_designator   ::= IDENTIFIER\nrange_expression   ::= (range_index)? '..' (range_index)?\nrange_index        ::= expression | '^' expression\n```\n\nTaking the address of a compound literal will yield a pointer to stack allocated temporary.\n\n### Function calls\n\n#### Function argument resolution\n\nCall slots are in order: regular slots, vaarg slot, name-only slots.\n\nNo regular slots may appear after the vaarg slot, however there may be named parameters with default values \nafter the vaarg slot if it's not a raw vaarg.\n\nThese \"name-only\" slots need to have a parameter name and a default value, and may only be called as named \narguments.\n\nNamed arguments may never be *splat* expressions.\n\n1. Step through all the arguments, resolve the named arguments and determine if there are any regular arguments.\n2. If there are regular arguments, then named arguments may only be in name-only slots, otherwise it is an error.\n3. If there are named arguments in the regular slots, all slots not provided arguments must have default values.\n4. Proceed with evaluation of arguments from left to right in call invocation order.\n6. Regular arguments are placed in the regular slots from left to right.\n7. If a regular argument is a *splat* expression, evaluate it *without inference* and determine if it is an array, vector, untyped list or slice with a known size, otherwise it is an error.\n8. A regular argument *splat* will be expanded into as many slots as its length, this may expand into vaarg arguments.\n9. In the vaarg slot, *splatting* a slice will *forward* it.\n10. In the vaarg slot, *splatting* an array, vector or untyped list will expand its elements as if they were provided as arguments.\n11. A named argument may never appear more than once.\n12. The vaarg slot may never be accessed using named arguments.\n\n#### Varargs\n\nFor varargs, a `bool` or *any integer* smaller than what the C ABI specifies for the c `int` type is cast to `int`. Any\nfloat smaller than a double is cast to `double`. Compile time floats will be cast to double. Compile time integers will\nbe cast to c `int` type.\n\n## Statements\n\n```\nstmt               ::= compound_stmt | non_compound_stmt\nnon_compound_stmt  ::= assert_stmt | if_stmt | while_stmt | do_stmt | foreach_stmt | foreach_r_stmt \n                       | for_stmt | return_stmt | break_stmt | continue_stmt | var_stmt \n                       | declaration_stmt | defer_stmt | nextcase_stmt | asm_block_stmt\n                       | ct_echo_stmt | ct_error_stmt | ct_assert_stmt | ct_if_stmt | ct_switch_stmt \n                       | ct_for_stmt | ct_foreach_stmt | expr_stmt \n```\n\n### Asm block statement\n\nAn asm block is either a string expression or a brace enclosed list of asm statements.\n\n```\nasm_block_stmt      ::= \"asm\" (\"(\" constant_expr \")\" | \"{\" asm_stmt* \"}\")\nasm_stmt            ::= asm_instr asm_exprs? \";\"\nasm_instr           ::= (\"int\" | IDENTIFIER) (\".\" IDENTIFIER)\nasm_expr            ::= CT_IDENT | CT_CONST_IDENT | \"&\"? IDENTIFIER | CONST_IDENT | FLOAT_LITERAL\n                        | INTEGER | \"(\" expr \")\" | \"[\" asm_addr \"]\"\nasm_addr            ::= asm_expr (additive_op asm_expr asm_addr_trail?)?\nasm_addr_trail      ::= \"*\" INTEGER (additive_op INTEGER)? | (shift_op | additive_op) INTEGER                         \n```\n\nTODO\n\n### Assert statement\n\nThe assert statement will evaluate the expression and call the panic function if it evaluates\nto false.\n\n```\nassert_stmt        ::= \"assert\" \"(\" expr (\",\" assert_message)? \")\" \";\"\nassert_message     ::= constant_expr (\",\" expr)*\n```\n\n#### Conditional inclusion\n\n`assert` statements are only included in \"safe\" builds. They may turn into **assume directives** for\nthe compiler on \"fast\" builds.\n\n#### Assert message\n\nThe assert message is optional. It can be followed by an arbitrary number of expressions, in which case\nthe message is understood to be a format string, and the following arguments are passed as values to the\nformat function.\n\nThe assert message must be a compile time constant. There are no restriction on the format argument expressions.\n\n#### Panic function\n\nIf the assert message has no format arguments or no assert message is included,\nthen the regular panic function is called. If it has format arguments then `panicf` is called instead.\n\nIn the case the `panicf` function does not exist (for example, compiling without the standard library),\nthen the format and the format arguments will be ignored and the `assert` will be treated\nas if no assert message was available.\n\n### Break statement\n\nA break statement exits a `while`, `for`, `do`, `foreach` or `switch` scope. A labelled break\nmay also exit a labelled `if`.\n\n```\nbreak_stmt         ::= \"break\" label? \";\"\n```\n\n#### Break labels\n\nIf a break has a label, then it will instead exit an outer scope with the label.\n\n#### Unreachable code\n\nAny statement following break in the same scope is considered unreachable.\n\n### Compile time echo statement\n\nDuring parsing, the compiler will output the text in the statement when it is semantically checked.\nThe statement will be turned into a NOP statement after checking.\n\n```\nct_echo_stmt       ::= \"$echo\" constant_expr \";\"\n```\n\n#### The message\n\nThe message must be a compile time constant string.\n\n### Compile time assert statement\n\nDuring parsing, the compiler will check the compile time expression\nand create a compile time error with the optional message. After\nevaluation, the `$assert` becomes a **NOP** statement.\n\n```\nct_assert_stmt     ::= \"$assert\" constant_expr (\":\" constant_expr) \";\"\n```\n\n#### Evaluated expression\n\nThe checked expression must evaluate to a boolean compile time constant.\n\n#### Error message\n\nThe second parameter, which is optional, must evaluate to a constant string.\n\n### Compile time error statement\n\nDuring parsing, when semantically checked this statement will output\na compile time error with the message given.\n\n```\nct_error_stmt      ::= \"$error\" constant_expr \";\"\n```\n\n#### Error message\n\nThe parameter must evaluate to a constant string.\n\n### Compile time if statement\n\nIf the cond expression is true, the then-branch is processed by the compiler. If it\nevaluates to false, the else-branch is processed if it exists.\n\n```\nct_if_stmt         ::= \"$if\" constant_expr \":\" stmt* (\"$else\" stmt*)? \"$endif\"\n```\n\n#### Cond expression\n\nThe cond expression must be possible to evaluate to true or false at compile time.\n\n#### Scopes\n\nThe \"then\" and \"else\" branches will add a compile time scope that is exited when reaching `$endif`.\nIt adds no runtime scope.\n\n#### Evaluation\n\nStatements in the branch not picked will not be semantically checked.\n\n### Compile time switch statement\n\n```\nct_switch_stmt     ::= \"$switch\" (\"(\" ct_expr_or_type \")\")? ct_case_stmt+ \"$endswitch\"\nct_case_stmt       ::= (\"$default\" | \"$case\" ct_expr_or_type) \":\" stmt* \n```\n\n#### No cond expression switch\n\nIf the cond expression is missing, evaluation will go through each case until one case expression\nevaluates to true.\n\n#### Type expressions\n\nIf a cond expression is a type, then all case statement expressions must be types as well.\n\n#### Ranged cases\n\nCompile time switch does not support ranged cases.\n\n#### Fallthrough\n\nIf a case clause has no statements, then when executing the case, rather than exiting the switch,\nthe next case clause immediately following it will be used. If that one should also be missing statements,\nthe procedure will be repeated until a case clause with statements is encountered,\nor the end of the switch is reached.\n\n#### Break and nextcase\n\nCompile time switches do not support `break` nor `nextcase`.\n\n#### Evaluation of statements\n\nOnly the case which is first matched has its statements processed by the compiler. All other statements\nare ignored and will not be semantically checked.\n\n### Continue statement\n\nA continue statement jumps to the cond expression of a `while`, `for`, `do` or `foreach`\n\n```\ncontinue_stmt      ::= \"continue\" label? \";\"\n```\n\n#### Continue labels\n\nIf a `continue` has a label, then it will jump to the cond of the while/for/do in the outer scope\nwith the corresponding label.\n\n#### Unreachable code\n\nAny statement following `continue` in the same scope is considered unreachable.\n\n### Declaration statement\n\nA declaration statement adds a new runtime or compile time variable to the current scope. It is available after the\ndeclaration statement.\n\n```\ndeclaration_stmt   ::= const_declaration | local_decl_storage? optional_type decls_after_type \";\"\nlocal_decl_storage ::= \"tlocal\" | \"static\"\ndecls_after_type   ::= local_decl_after_type (\",\" local_decl_after_type)*\ndecl_after_type    ::= CT_IDENT (\"=\" constant_expr)? | IDENTIFIER opt_attributes (\"=\" expr)?\n```\n\n#### Thread local storage\n\nUsing `tlocal` allocates the runtime variable as a **thread local** variable. In effect this is the same as declaring\nthe variable as a global `tlocal` variable, but the visibility is limited to the function. `tlocal` may not be\ncombined with `static`.\n\nThe initializer for a `tlocal` variable must be a valid global init expression.\n\n#### Static storage\n\nUsing `static` allocates the runtime variable as a function **global** variable. In effect this is the same as declaring\na global, but visibility is limited to the function. `static` may not be combined with `tlocal`.\n\nThe initializer for a `static` variable must be a valid global init expression.\n\n#### Scopes\n\nRuntime variables are added to the runtime scope, compile time variables to the compile time scope. See **var statements\n**.\n\n#### Multiple declarations\n\nIf more than one variable is declared, no init expressions are allowed for any of the variables.\n\n#### No init expression\n\nIf no init expression is provided, the variable is **zero initialized**.\n\n#### Opt-out of zero initialization\n\nUsing the @noinit attribute opts out of **zero initialization**.\n\n#### Self referencing initialization\n\nAn init expression may refer to the **address** of the same variable that is declared, but not the **value** of the\nvariable.\n\nExample:\n\n```c\nvoid* a = &a;  // Valid\nint a = a + 1; // Invalid\n```\n\n### Defer statement\n\nThe defer statements are executed at (runtime) scope exit, whether through `return`, `break`, `continue` or rethrow.\n\n```\ndefer_stmt         ::= \"defer\" (\"try\" | \"catch\")? stmt\n```\n\n#### Defer in defer\n\nThe defer body (statement) may not be a defer statement. However, if the body is a compound statement then\nthis may have any number of defer statements.\n\n#### Static and tlocal variables in defer\n\nStatic and tlocal variables are allowed in a defer statement. Only a single variable is instantiated regardless of\nthe number of inlining locations.\n\n#### Defer and return\n\nIf the `return` has an expression, then it is evaluated before the defer statements (due to exit from the current\nfunction scope),\nare executed.\n\nExample:\n\n```c\nint a = 0;\ndefer a++;\nreturn a;\n// This is equivalent to\nint a = 0;\nint temp = a;\na++;\nreturn temp;\n```\n\n#### Defer and jump statements\n\nA defer body may not contain a `break`, `continue`, `return` or rethrow that would exit the statement.\n\n#### Defer execution\n\nDefer statements are executed in the reverse order of their declaration, starting from the last declared\ndefer statement.\n\n#### `defer try`\n\nA `defer try` type of defer will only execute if the scope is left through normal fallthrough, `break`,\n`continue` or a `return` with a result.\n\nIt will not execute if the exit is through a rethrow or a `return` with an optional value.\n\n#### `defer catch`\n\nA `defer catch` type of defer will only execute if the scope is left through a rethrow or a `return` with an optional\nvalue\n\nIt will not execute if the exit is a normal fallthrough, `break`, `continue` or a `return` with a result.\n\n#### Non-regular returns - longjmp, panic and other errors\n\nDefers will not execute when doing `longjmp` terminating through a `panic` or other error. They\nare only invoked on regular scope exits.\n\n### Expr statement\n\nAn expression statement evaluates an expression.\n\n```\nexpr_stmt          ::= expr \";\"\n```\n\n#### No discard\n\nIf the expression is a function or macro call either returning an optional *or* annotated `@nodiscard`, then\nthe expression is a compile time error. A function or macro returning an optional can use the `@maydiscard`\nattribute to suppress this error.\n\n### If statement\n\nAn if statement will evaluate the cond expression, then execute the first statement (the \"then clause\") in the if-body\nif it evaluates to \"true\", otherwise execute the else clause. If no else clause exists, then the\nnext statement is executed.\n\n```\nif_stmt            ::= \"if\" (label \":\")? \"(\" cond_expr \")\" if_body\nif_body            ::= non_compound_stmt | compound_stmt else_clause? | \"{\" switch_body \"}\"\nelse_clause        ::= \"else\" (if_stmt | compound_stmt)\n\n```\n\n#### Scopes\n\nBoth the \"then\" clause and the else clause open new scopes, even if they are non-compound statements.\nThe cond expression scope is valid until the exit of the entire statement, so any declarations in the\ncond expression are available both in then and else clauses. Declarations in the \"then\" clause is not available\nin the else clause and vice versa.\n\n#### Special parsing of the \"then\" clause\n\nIf the then-clause isn't a compound statement, then it must follow on the same row as the cond expression.\nIt may not appear on a consecutive row.\n\n#### Break\n\nIt is possible to use labelled break to break out of an if statement. Note that an unlabelled `break` may not\nbe used.\n\n#### If-try\n\nThe cond expression may be a try-unwrap chain. In this case, the unwrapped variables are\nscoped to the \"then\" clause only.\n\n#### If-catch\n\nThe cond expression may be a catch-unwrap. The unwrap is scoped to the \"then\" clause only.\nIf one or more variables are in the catch, then the \"else\" clause have these variables\nimplicitly unwrapped.\n\nExample:\n\n```\nint! a = foo();\nint! b = foo();\nif (catch a, b)\n{\n    // Do something\n}\nelse\n{\n    int x = a + b; // Valid, a and b are implicitly unwrapped.\n}  \n```\n\n#### If-catch implicit unwrap\n\nIf an if-catch's \"then\"-clause will jump out of the outer scope in all code paths and\nthe catch is on one or more variables, then this variable(s) will be implicitly unwrapped in the outer scope\nafter the if-statement.\n\nExample:\n\n```\nint! a = foo();\nif (catch a)\n{\n  return;\n}  \nint x = a; // Valid, a is implicitly unwrapped.\n```\n\n### Nextcase statement\n\nNextcase will jump to another `switch` case.\n\n```\nnextcase_stmt      ::= \"nextcase\" ((label \":\")? (expr | \"default\"))? \";\" \n```\n\n#### Labels\n\nWhen a nextcase has a label, the jump is to the switch in an outer scope with the corresponding label.\n\n#### No expression jumps\n\nA `nextcase` without any expression jumps to the next case clause in the current switch. It is not possible\nto use no expression `nextcase` with labels.\n\n#### Jumps to default\n\nUsing `default` jumps to the default clause of a switch.\n\n#### Missing case\n\nIf the switch has constant case values, and the nextcase expression is constant, then the value of\nthe expression must match a case clause. Not matching a case is a compile time error.\n\nIf one or more cases are non-constant and/or the nextcase expression is non-constant, then no compile time check is\nmade.\n\n#### Variable expression\n\nIf the nextcase has a non-constant expression, or the cases are not all constant, then first the nextcase expression\nis evaluated. Next, execution will proceed *as if* the switch was invoked again, but with the nextcase expression as the\nswitch cond expression. See **switch statement**.\n\nIf the switch does not have a cond expression, nextcase with an expression is not allowed.\n\n#### Unreachable code\n\nAny statement in the same scope after a `nextcase` are considered **unreachable**.\n\n### Switch statement\n\n```\nswitch_stmt        ::= \"switch\" (label \":\")? (\"(\" cond_expr \")\")? switch body\nswitch_body        ::= \"{\" case_clause* \"}\"\ncase_clause        ::= default_stmt | case_stmt\ndefault_stmt       ::= \"default\" \":\" stmt*\ncase_stmt          ::= \"case\" label? expr (\"..\" expr)? \":\" stmt*\n```\n\n#### Regular switch\n\nIf the cond expression exists and all case statements have constant expression, then first the\ncond expression is evaluated, next the case corresponding to the expression's value will be jumped to\nand the statement will be executed. After reaching the end of the statements and a new case clause *or* the\nend of the switch body, the execution will jump to the first statement after the switch.\n\n#### If-switch\n\nIf the cond expression is missing or the case statements are non-constant expressions, then each case clause will\nbe evaluated in order after the cond expression has been evaluated (if it exists):\n\n1. If a cond expression exists, calculate the case expression and execute the case if it is matching the\n   cond expression. A default statement has no expression and will always be considered matching the cond expression\n   reached.\n2. If no con expression exists, calculate the case expression and execute the case if the expression evaluates to\n   \"true\" when implicitly converted to boolean. A default statement will always be considered having the \"true\" result.\n\n#### Any-switch\n\nIf the cond expression is an `any` type, the switch is handled as if switching was done over the `type`\nfield of the `any`. This field has the type of [typeid](#typeid-type), and the cases follows the rules\nfor [switching over typeid](#switching-over-typeid).\n\nIf the cond expression is a variable, then this variable is implicitly converted to a pointer with\nthe pointee type given by the case statement.\n\nExample:\n\n```c\nany a = abc();\nswitch (a)\n{\n    case int:\n        int b = *a;   // a is int*\n    case float:\n        float z = *a; // a is float*\n    case Bar:\n        Bar f = *a;   // a is Bar*\n    default:\n        // a is not unwrapped\n}              \n```\n\n#### Ranged cases\n\nCases may be ranged. The start and end of the range must both be constant integer values. The start must\nbe less or equal to the end value. Using non-integers or non-constant values is a compile time error.\n\n#### Fallthrough\n\nIf a case clause has no statements, then when executing the case, rather than exiting the switch, the next case clause\nimmediately following it will be executed. If that one should also be missing statement, the procedure\nwill be repeated until a case clause with statements is encountered (and executed), or the end of the switch is reached.\n\n#### Exhaustive switch\n\nIf a switch case has a default clause *or* it is switching over an enum and there exists a case for each enum value\nthen the switch is exhaustive.\n\n#### Break\n\nIf an unlabelled break, or a break with the switch's label is encountered,\nthen the execution will jump out of the switch and proceed directly after the end of the switch body.\n\n#### Unreachable code\n\nIf a switch is exhaustive and all case clauses end with a jump instruction, containing no break statement out\nof the current switch, then the code directly following the switch will be considered **unreachable**.\n\n#### Switching over typeid\n\nIf the switch cond expression is a typeid, then case declarations may use only the type name after the case,\nwhich will be interpreted as having an implicit `.typeid`. Example: `case int:` will be interpreted as if\nwritten `case int.typeid`.\n\n#### Nextcase without expression\n\nWithout a value `nextcase` will jump to the beginning of the next case clause. It is not allowed to\nput `nextcase` without an expression if there are no following case clauses.\n\n#### Nextcase with expression\n\nNextcase with an expression will evaluate the expression and then jump *as if* the switch was entered with\nthe cond expression corresponding to the value of the nextcase expression. Nextcase with an expression cannot\nbe used on a switch without a cond expression.\n\n#### Do statement\n\nThe do statement first evaluates its body (inner statement), then evaluates the cond expression.\nIf the cond expression evaluates to true, jumps back into the body and repeats the process.\n\n```\ndo_stmt            ::= \"do\" label? compound_stmt (\"while\" \"(\" cond_expr \")\")? \";\" \n```\n\n#### Unreachable code\n\nThe statement after a `do` is considered unreachable if the cond expression cannot ever be false\nand there is no `break` out of the do.\n\n#### Break\n\n`break` will exit the do with execution continuing on the following statement.\n\n#### Continue\n\n`continue` will jump directly to the evaluation of the cond, as if the end of the statement had been reached.\n\n#### Do block\n\nIf no `while` part exists, it will only execute the block once, as if it ended with `while (false)`, this is\ncalled a \"do block\"\n\n### For statement\n\nThe `for` statement will perform the (optional) init expression. The cond expression will then be tested. If\nit evaluates to `true` then the body will execute, followed by the incr expression. After execution will\njump back to the cond expression and execution will repeat until the cond expression evaluates to `false`.\n\n```\nfor_stmt           ::= \"for\" label? \"(\" init_expr \";\" cond_expr? \";\" incr_expr \")\" stmt\ninit_expr          ::= decl_expr_list?\nincr_expr          ::= expr_list? \n```\n\n#### Init expression\n\nThe init expression is only executed once before the rest of the for loop is executed.\nAny declarations in the init expression will be in scope until the for loop exits.\n\nThe init expression may optionally be omitted.\n\n#### Incr expression\n\nThe incr expression is evaluated before evaluating the cond expr every time except for the first one.\n\nThe incr expression may optionally be omitted.\n\n#### Cond expression\n\nThe cond expression is evaluated every loop. Any declaration in the cond expression is scoped to the\ncurrent loop, i.e. it will be reinitialized at the start of every loop.\n\nThe cond expression may optionally be omitted. This is equivalent to setting the cond expression to\nalways return `true`.\n\n#### Unreachable code\n\nThe statement after a `for` is considered unreachable if the cond expression cannot ever be false, or is\nomitted and there is no `break` out of the loop.\n\n#### Break\n\n`break` will exit the `for` with execution continuing on the following statement after the `for`.\n\n#### Continue\n\n`continue` will jump directly to the evaluation of the cond, as if the end of the statement had been reached.\n\n#### Equivalence of `while` and `for`\n\nA `while` loop is functionally equivalent to a `for` loop without init and incr expressions.\n\n### `foreach` and `foreach_r` statements\n\nThe `foreach` statement will loop over a sequence of values. The `foreach_r` is equivalent to\n`foreach` but the order of traversal is reversed.\n`foreach` starts with element `0` and proceeds step by step to element `len - 1`.\n`foreach_r` starts starts with element `len - 1` and proceeds step by step to element `0`.\n\n```\nforeach_stmt       ::= \"foreach\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_r_stmt     ::= \"foreach_r\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_vars       ::= (foreach_index \",\")? foreach_var\nforeach_var        ::= type? \"&\"? IDENTIFIER\n```\n\n#### Break\n\n`break` will exit the foreach statement with execution continuing on the following statement after.\n\n#### Continue\n\n`continue` will cause the next iteration to commence, as if the end of the statement had been reached.\n\n#### Iteration by value or reference\n\nNormally iteration are by value. Each element is copied into the foreach variable. If `&`\nis added before the variable name, the elements will be retrieved by reference instead, and consequently\nthe type of the variable will be a pointer to the element type instead.\n\n#### Foreach variable\n\nThe foreach variable may omit the type. In this case the type is inferred. If the type differs from the element\ntype, then an implicit conversion will be attempted. Failing this is a compile time error.\n\n#### Foreach index\n\nIf a variable name is added before the foreach variable, then this variable will receive the index of the element.\nFor `foreach_r` this mean that the first value of the index will be `len - 1`.\n\nThe index type defaults to `usz`.\n\nIf an optional type is added to the index, the index will be converted to this type. The type must be an\ninteger type. The conversion happens as if the conversion was a direct cast. If the actual index value\nwould exceed the maximum representable value of the type, this does not affect the actual iteration, but\nmay cause the index value to take on an incorrect value due to the cast.\n\nFor example, if the optional index type is `char` and the actual index is `256`, then the index value would show `0`\nas `(char)256` evaluates to zero.\n\nModifying the index variable will not affect the foreach iteration.\n\n#### Foreach support\n\nForeach is natively supported for any slice, array, pointer to an array, vector and pointer to a vector.\nThese types support both iteration by value and reference.\n\nIn addition, a type with **operator overload** for `len` and `[]` will support iteration by value,\nand a type with **operator overload** for `len` and `&[]` will support iteration by reference.\n\n### Return statement\n\nThe return statement evaluates its expression (if present) and returns the result.\n\n```\nreturn_stmt        ::= \"return\" expr? \";\"\n```\n\n#### Jumps in return statements\n\nIf the expression should in itself cause an implicit return, for example due to the rethrow operator `!`, then this\njump will happen before the return.\n\nAn example:\n\n    return foo()!;\n    // is equivalent to:\n    int temp = foo()!;\n    return temp;\n\n#### Empty returns\n\nAn empty return is equivalent to a return with a void type. Consequently constructs like `foo(); return;`\nand `return (void)foo();`\nare equivalent.\n\n#### Unreachable code\n\nAny statement directly following a return in the same scope are considered unreachable.\n\n### While statement\n\nThe while statement evaluates the cond expression and executes the statement if it evaluates to true.\nAfter this the cond expression is evaluated again and the process is repeated until cond expression returns false.\n\n```\nwhile_stmt         ::= \"while\" label? \"(\" cond_expr \")\" stmt\n```\n\n#### Unreachable code\n\nThe statement after a while is considered unreachable if the cond expression cannot ever be false\nand there is no `break` out of the while.\n\n#### Break\n\n`break` will exit the while with execution continuing on the following statement.\n\n#### Continue\n\n`continue` will jump directly to the evaluation of the cond, as if the end of the statement had been reached.\n\n### Var statement\n\nA var statement declares a variable with inferred type, or a compile time type variable. It can be used both\nfor runtime and compile time variables. The use for runtime variables is limited to macros.\n\n```\nvar_stmt           ::= \"var\" IDENTIFIER | CT_IDENT | CT_TYPE_IDENT (\"=\" expr)? \";\" \n```\n\n#### Inferring type\n\nIn the case of a runtime variable, the type is inferred from the expression. Not providing an expression\nis a compile time error. The expression must resolve to a runtime type.\n\nFor compile time variables, the expression is optional. The expression may resolve to a runtime or compile time type.\n\n#### Scope\n\nRuntime variables will follow the runtime scopes, identical to behaviour in a declaration statement. The compile\ntime variables will follow the compile time scopes which are delimited by scoping compile time\nstatements (`$if`, `$switch`,\n`$foreach` and `$for`).\n\n## Attributes\n\nAttributes are modifiers attached to modules, variables, type declarations etc.\n\n| name            | used with                                                                         |\n|-----------------|-----------------------------------------------------------------------------------|\n| `@align`        | fn, const, variables, user-defined types, struct member                           |\n| `@benchmark`    | module, fn                                                                        |\n| `@bigendian`    | bitstruct only                                                                    |\n| `@builtin`      | macro, fn, global, constant                                                       |\n| `@callconv`     | fn, call                                                                          |\n| `@deprecated`   | fn, macro, interface, variables, constants, user-defined types, struct member     |\n| `@dynamic`      | fn                                                                                |\n| `@export`       | fn, globals, constants, struct, union, enum, fault                                |\n| `@extern`       | fn, globals, constants, user-defined types                                        |\n| `@if`           | all except local variables and calls                                              |\n| `@inline`       | fn, call                                                                          |\n| `@interface`    | fn                                                                                |\n| `@littleendian` | bitstruct only                                                                    |\n| `@local`        | module, fn, macro, globals, constants, user-defined types, attributes and aliases |\n| `@maydiscard`   | fn, macro                                                                         |\n| `@naked`        | fn                                                                                |\n| `@nodiscard`    | fn, macro                                                                         |\n| `@noinit`       | variables                                                                         |\n| `@noinline`     | fn, call                                                                          |\n| `@noreturn`     | fn, macro                                                                         |\n| `@nostrip`      | fn, globals, constants, struct, union, enum, fault                                |\n| `@obfuscate`    | enum, fault                                                                       |\n| `@operator`     | fn, macro                                                                         |\n| `@optional`     | interface methods                                                                 |\n| `@overlap`      | bitstruct only                                                                    |\n| `@packed`       | struct, union                                                                     |\n| `@priority`     | initializer/finalizer                                                             |\n| `@private`      | module, fn, macro, globals, constants, user-defined types, attributes and aliases |\n| `@public`       | module, fn, macro, globals, constants, user-defined types, attributes and aliases |\n| `@pure`         | call                                                                              |\n| `@reflect`      | fn, globals, constants, user-defined types                                        |\n| `@section`      | fn, globals, constants                                                            |\n| `@test`         | module, fn                                                                        |\n| `@unused`       | all except call and initializer/finalizers                                        |\n| `@used`         | all except call and initializer/finalizers                                        |\n| `@weak`         | fn, globals, constants                                                            |\n| `@winmain`      | fn                                                                                |\n\n#### `@deprecated`\n\nTakes an optional constant string. \nIf the node is in use, print the deprecation and add the optional string if present.\n\n#### `@optional`\n\nMarks an *interface* method as optional, and so does not need to be implemented by\na conforming type.\n\n#### `@winmain`\n\nMarks a `main` function as a win32 winmain function, which is the entrypoint for a windowed \napplication on Windows. This allows the main function to take a different set of \narguments than usual.\n\n#### `@callconv`\n\n`@callconv` can be used with a function or a call. It takes a constant string which is either \"veccall\", \"stdcall\" or \"cdecl\". If more than one `@callconv` \nis applied to a function or call, the last one takes precedence.\n\n### User defined attributes\n\nUser defined attributes group a list of attributes.\n\n```\nattribute_decl     ::= \"def\" AT_TYPE_IDENT (\"(\" parameters \")\")? attribute* \"=\" \"{\" attribute* \"}\" \";\" \n```\n\n#### Empty list of attributes\n\nThe list of attributes may be empty.\n\n#### Parameter arguments\n\nArguments given to user defined attributes will be passed on to the attributes in the list.\n\n#### Expansion\n\nWhen a user defined attribute is encountered, its list of attributes is\ncopied and appended instead of the user defined attribute. Any argument passed to \nthe attribute is evaluated and passed as a constant by the name of the parameter\nto the evaluation of the attribute parameters in the list.\n\n#### Nesting\n\nA user defined attribute can contain other user defined attributes. The definition\nmay not be cyclic.\n\n## Methods\n\n#### Operator overloading\n\n`@operator` overloads may only be added to user defined types (distinct, unions, struct, enum and fault).\n\n##### Indexing operator (`[]`)\n\nThis requires a return type and a method parameter, which is the index.\n\n##### Reference indexing operator (`&[]`)\n\nThis requires a return type and a method parameter, which is the index. If `[]` is implemented,\nit should return a pointer to `[]`.\n\n##### Assigning index operator (`=[]`)\n\nThis has a void return type, and index should match that of `[]` and `&[]`. Value should match that \nof `[]` and be the pointee of the result of `&[]`.\n\n##### Len operator (`len`)\n\nThis must have an integer return type.\n\n#### Dynamic methods\n\n`@dynamic` may be used on methods for any type except `any` and interfaces.\n\n\n## Modules\n\nModule paths are hierarchal, with each sub-path appended with '::' + the name:\n\n```\npath               ::= PATH_SEGMENT (\"::\" PATH_SEGMENT)\n```\n\nEach module declaration starts its own **module section**. All imports and all `@local` declarations\nare only visible in the current **module section**.\n\n```\nmodule_section     ::= \"module\" path opt_generic_params? attributes? \";\"\ngeneric_param      ::= TYPE_IDENT | CONST_IDENT\nopt_generic_params ::= \"(<\" generic_param (\",\" generic_param)* \">)\"\n```\n\nAny visibility attribute defined in a **module section** will be the default visibility in all\ndeclarations in the section.\n\nIf the `@benchmark` attribute is applied to the **module section** then all function declarations\nwill implicitly have the `@benchmark` attribute.\n\nIf the `@test` attribute is applied to the **module section** then all function declarations\nwill implicitly have the `@test` attribute.\n";
						const data = {title:"C3 Specification",description:"C3 Specification",editUrl:true,head:[],template:"doc",sidebar:{order:999,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
