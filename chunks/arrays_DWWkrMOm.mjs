const id = "Previous Versions/v0_6_8/Language Common/arrays.md";
						const collection = "docs";
						const slug = "previous-versions/v0_6_8/language-common/arrays";
						const body = "\nArrays have a central role in programming. C3 offers built-in arrays, [slices](#slice) and [vectors](/language-common/vectors/).\nThe standard library enhances this further with dynamically sized arrays and other collections.\n\n## Fixed Size 1D Arrays\n\nThese are declared as `<type>[<size>]`, e.g. `int[4]`. Fixed arrays are treated as values and will be copied if given as parameter. Unlike C, the number is part of its type. Taking a pointer to a fixed array will create a pointer to a fixed array, e.g. `int[4]*`. \n\nUnlike C, fixed arrays do not decay into pointers. Instead, an `int[4]*` may be implicitly converted into an `int*`.\n\n```c3\n// C\nint foo(int *a) { ... }\n\nint x[3] = { 1, 2, 3 };\nfoo(x);\n\n// C3\nfn int foo(int* a) { ... }\n\nint[3] x = { 1, 2, 3 };\nfoo(&x);\n```\n\nWhen you want to initialize a fixed array without specifying the size, use the `[*]` array syntax:\n```c3\nint[3] a = { 1, 2, 3 };\nint[*] b = { 4, 5, 6 }; // Type inferred to be int[3]\n```\n\nYou can get the length of an array using the `.len` property:\n\n```c3\nint len1 = int[4].len; // 4\nint[3] a = { 1, 2, 3 };\nint len2 = a.len; // 3\nint[*] b = { 1, 2 };\nint len3 = b.len; // 2\n```\n\n## Slice\n\nThe final type is the slice `<type>[]`  e.g. `int[]`. A slice is a view into either a fixed or variable array. Internally it is represented as a struct containing a pointer and a size. Both fixed and variable arrays may be converted into slices, and slices may be implicitly converted to pointers.\n\n```c3\nfn void test() \n{\n    int[4] arr = { 1, 2, 3, 4 };\n    int[4]* ptr = &arr;\n    \n    // Assignments to slices\n    int[] slice1 = &arr;                // Implicit conversion\n    int[] slice2 = ptr;                 // Implicit conversion\n\n    // Assignments from slices\n    int[] slice3 = slice1;              // Assign slices from other slices\n    int* int_ptr = slice1;              // Assign from slice\n    int[4]* arr_ptr = (int[4]*)slice1;  // Cast from slice\n}\n```\n\n### Slicing Arrays\n\nIt's possible to use the range syntax to create slices from pointers, arrays, and other slices.\n\nThis is written `arr[<start-index> .. <end-index>]`, where `end-index` is *inclusive*. \n```c3\nfn void test() \n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b = a[0 .. 4]; // The whole array as a slice.\n    int[] c = a[2 .. 3]; // { 50, 100 }\n}\n```  \n\nYou can also use `arr[<start-index> : <slice-length>]`\n```c3\nfn void test()\n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n    \n    int[] b2 = a[0 : 5]; // { 1, 20, 50, 100, 200 } start-index 0, slice-length 5\n    int[] c2 = a[2 : 2]; // { 50, 100 } start-index 2, slice-length 2\n}\n```\n\nItâ€™s possible to omit the first and last indices of a range:\n- `arr[..<end-index>]` Omitting the start index will default it to 0\n- `arr[<start-index>..]` Omitting the end index will assign it to `arr.len-1` (this is not allowed on pointers)\n\nEquivalently with index offset `arr[:<slice-length>]` you can omit the `start-index` \n\nThe following are all equivalent and slice the whole array\n\n```c3\nfn void test() \n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b = a[0 .. 4];\n    int[] c = a[..4];\n    int[] d = a[0..];\n    int[] e = a[..];\n    \n    int[] f = a[0 : 5];\n    int[] g = a[:5];\n}\n```\n\nYou can also slice in reverse from the end with `^i` where the index is `len-i` for example:\n- `^1` means `len-1`\n- `^2` means `len-2`\n- `^3` means `len-3`\n\nAgain, this is not allowed for pointers since the length is unknown.\n\n```c3\nfn void test() \n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b1 = a[1 .. ^1];  // { 20, 50, 100, 200 } a[1 .. (a.len-1)]\n    int[] b2 = a[1 .. ^2];  // { 20, 50, 100 }      a[1 .. (a.len-2)]\n    int[] b3 = a[1 .. ^3];  // { 20, 50 }           a[1 .. (a.len-3)]\n\n    int[] c1 = a[^1..];     // { 200 }              a[(a.len-1)..]\n    int[] c2 = a[^2..];     // { 100, 200 }         a[(a.len-2)..]\n    int[] c3 = a[^3..];     // { 50, 100, 200 }     a[(a.len-3)..]\n\n    int[] d = a[^3 : 2];    // { 50, 100 }          a[(a.len-3) : 2]\n    \n    // Slicing a whole array, the inclusive index of : gives the difference\n    int[] e = a[0 .. ^1];   // a[0 .. a.len-1]\n    int[] f = a[0 : ^0];    // a[0 : a.len]\n\n}\n```\n\nOne may also assign to slices:\n```c3\nint[3] a = { 1, 20, 50 };\na[1..2] = 0; // a = { 1, 0, 0 }\n```\n\nOr copy slices to slices:\n```c3\nint[3] a = { 1, 20, 50 };\nint[3] b = { 2, 4, 5 };\na[1..2] = b[0..1]; // a = { 1, 2, 4 }\n```\n\nCopying between two overlapping ranges, e.g. `a[1..2] = a[0..1]` is unspecified behaviour.\n    \n### Conversion List\n\n| | `int[4]` | `int[]` | `int[4]*` | `int*` |\n|:-:|:-:|:-:|:-:|:-:|\n| `int[4]` | copy | - | - | - |\n| `int[]` | - | assign | assign | - |\n| `int[4]*` | - | cast | assign | cast |\n| `int*` | - | assign | assign | assign |\n\nNote that all casts above are inherently unsafe and will only work if the type cast is indeed compatible.\n\nFor example:\n\n```c3\nint[4] a;\nint[4]* b = &a;\nint* c = b;\n\n// Safe cast:\nint[4]* d = (int[4]*)c; \nint e = 12;\nint* f = &e;\n\n// Incorrect, but not checked\nint[4]* g = (int[4]*)f;\n\n// Also incorrect but not checked.\nint[] h = f[0..2];\n```\n\n#### Internals\n\nInternally the layout of a slice is guaranteed to be `struct { <type>* ptr; usz len; }`.\n\nThere is a built-in struct `std::core::runtime::SliceRaw` which \nhas the exact data layout of the fat array pointers. It is defined to be\n\n```c3\nstruct SliceRaw\n{\n    void* ptr;\n    usz len;\n}\n```\n\n## Iteration Over Arrays\n\n### `foreach` element by copy\n\nYou may iterate over slices, arrays and vectors using `foreach (Type x : array)`. \nUsing compile-time type inference this can be abbreviated \nto `foreach (x : array)` for example:\n\n```c3\nfn void test()\n{\n    int[4] arr = { 1, 2, 3, 5 };\n    foreach (item : arr)\n    {\n        io::printfn(\"item: %s\", item);\n    }\n\n    // Or equivalently, writing the type:\n    foreach (int x : arr)\n    {\n        /* ... */\n    }\n}\n```\n\n### `foreach` element by reference\nUsing `&` it is possible to get an element by reference rather than by copy.\nProviding two variables to `foreach`, the first is assumed to be the index and the second the value:\n\n```c3\nfn void test()\n{\n    int[4] arr = { };\n    foreach (idx, &item : arr)\n    {\n        *item = 7 + idx; // Mutates the array element\n    }\n\n    // Or equivalently, writing the types\n    foreach (int idx, int* &item : arr)\n    {\n        *item = 7 + idx; // Mutates the array element\n    }\n}\n```\n\n### `foreach_r` reverse iterating\nWith `foreach_r` arrays or slices can be iterated over in reverse order \n\n```c3\nfn void test()\n{\n    float[4] arr = { 1.0, 2.0 };\n    foreach_r (idx, item : arr)\n    {\n        // Prints 2.0, 1.0\n         io::printfn(\"item: %s\", item); \n    }\n\n    // Or equivalently, writing the types\n     foreach_r (int idx, float item : arr)\n    {\n        // Prints 2.0, 1.0\n         io::printfn(\"item: %s\", item); \n    }\n}\n```\n\n## Iteration Over Array-Like types\nIt is possible to enable foreach on any custom type \nby implementing `.len` and `[]` methods and annotating them using the `@operator` attribute:\n\n```c3\nstruct DynamicArray\n{\n    usz count;\n    usz capacity;\n    int* elements;\n}\n\nmacro int DynamicArray.get(DynamicArray* arr, usz element) @operator([])\n{\n    return arr.elements[element];\n}\n\nmacro usz DynamicArray.count(DynamicArray* arr) @operator(len)\n{\n    return arr.count;\n}\n\nfn void DynamicArray.push(DynamicArray* arr, int value)\n{\n    arr.ensure_capacity(arr.count + 1);  // Function not shown in example.\n    arr.elements[arr.count++] = value;\n}\n\nfn void test()\n{\n    DynamicArray v;\n    v.push(3);\n    v.push(7);\n\n    // Will print 3 and 7\n    foreach (int i : v)\n    {\n        io::printfn(\"%d\", i);\n    }\n}\n```\n\nFor more information, see [operator overloading](/generic-programming/operator-overloading/)\n\n## Dynamic Arrays and Lists\n\nThe standard library offers dynamic arrays and other collections in the `std::collections` module.\n\n```c3\ndef ListStr = List(<String>);\n\nfn void test()\n{\n    ListStr list_str;    \n\n    // Initialize the list on the heap.\n    list_str.new_init();    \n\n    list_str.push(\"Hello\");  // Add the string \"Hello\"\n    list_str.push(\"World\");\n\n    foreach (str : list_str)\n    {\n        io::printn(str);   // Prints \"Hello\", then \"World\"\n    }\n    String str = list_str[1]; // str == \"World\"\n    list_str.free();        // Free all memory associated with list.\n}\n```\n\n## Fixed Size Multi-Dimensional Arrays\n\nTo declare two dimensional fixed arrays as `<type>[<x-size>, <y-size>] arr`, like `int[4][2] arr`. Below you can see how this compares to C:\n```c\n// C \n// Uses: name[<rows>][<columns>]\nint array_in_c[4][2] = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// C3\n// Uses: <type>[<x-size>][<y-size>]\n// C3 declares the dimensions, inner-most to outer-most\nint[4][2] array = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n};\n\n// To match C we must invert the order of the dimensions \nint[2][4] array = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// C3 also supports Irregular arrays, for example:\nint[][4] array = {\n    { 1 },\n    { 2, 3 },\n    { 4, 5, 6 },\n    { 7, 8, 9, 10 },\n};\n```\n\n:::note\nAccessing the multi-dimensional fixed array has inverted array index order to when the array was declared.\n\n```c3\n// Uses: <type>[<x-size>][<y-size>]\nint[2][4] array = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// Access fixed array using: array[<row>][<column>]\nint value = array[3][1]; // 8\n```\n:::\n\n";
						const data = {title:"Arrays",description:"Arrays",editUrl:true,head:[],template:"doc",sidebar:{order:60,hidden:false,attrs:{}},pagefind:true,draft:false};
						const _internal = {
							type: 'content',
							filePath: "/home/josh/git/c3_tests/experimental-site-testing-only__local_changes/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
